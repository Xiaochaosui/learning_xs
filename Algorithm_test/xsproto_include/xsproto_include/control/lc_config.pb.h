// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: control/lc_config.proto

#ifndef PROTOBUF_control_2flc_5fconfig_2eproto__INCLUDED
#define PROTOBUF_control_2flc_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_control_2flc_5fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsLonControlParamImpl();
void InitDefaultsLonControlParam();
void InitDefaultsReverseStationPidConfigureImpl();
void InitDefaultsReverseStationPidConfigure();
void InitDefaultsReverseSpeedPidConfigureImpl();
void InitDefaultsReverseSpeedPidConfigure();
void InitDefaultsLowSpeedPidConfigureImpl();
void InitDefaultsLowSpeedPidConfigure();
void InitDefaultsHighSpeedPidConfigureImpl();
void InitDefaultsHighSpeedPidConfigure();
void InitDefaultsStationPidConfigureImpl();
void InitDefaultsStationPidConfigure();
void InitDefaultsOtherParamConfigureImpl();
void InitDefaultsOtherParamConfigure();
inline void InitDefaults() {
  InitDefaultsLonControlParam();
  InitDefaultsReverseStationPidConfigure();
  InitDefaultsReverseSpeedPidConfigure();
  InitDefaultsLowSpeedPidConfigure();
  InitDefaultsHighSpeedPidConfigure();
  InitDefaultsStationPidConfigure();
  InitDefaultsOtherParamConfigure();
}
}  // namespace protobuf_control_2flc_5fconfig_2eproto
namespace LC {
class HighSpeedPidConfigure;
class HighSpeedPidConfigureDefaultTypeInternal;
extern HighSpeedPidConfigureDefaultTypeInternal _HighSpeedPidConfigure_default_instance_;
class LonControlParam;
class LonControlParamDefaultTypeInternal;
extern LonControlParamDefaultTypeInternal _LonControlParam_default_instance_;
class LowSpeedPidConfigure;
class LowSpeedPidConfigureDefaultTypeInternal;
extern LowSpeedPidConfigureDefaultTypeInternal _LowSpeedPidConfigure_default_instance_;
class OtherParamConfigure;
class OtherParamConfigureDefaultTypeInternal;
extern OtherParamConfigureDefaultTypeInternal _OtherParamConfigure_default_instance_;
class ReverseSpeedPidConfigure;
class ReverseSpeedPidConfigureDefaultTypeInternal;
extern ReverseSpeedPidConfigureDefaultTypeInternal _ReverseSpeedPidConfigure_default_instance_;
class ReverseStationPidConfigure;
class ReverseStationPidConfigureDefaultTypeInternal;
extern ReverseStationPidConfigureDefaultTypeInternal _ReverseStationPidConfigure_default_instance_;
class StationPidConfigure;
class StationPidConfigureDefaultTypeInternal;
extern StationPidConfigureDefaultTypeInternal _StationPidConfigure_default_instance_;
}  // namespace LC
namespace LC {

// ===================================================================

class LonControlParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LC.LonControlParam) */ {
 public:
  LonControlParam();
  virtual ~LonControlParam();

  LonControlParam(const LonControlParam& from);

  inline LonControlParam& operator=(const LonControlParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LonControlParam(LonControlParam&& from) noexcept
    : LonControlParam() {
    *this = ::std::move(from);
  }

  inline LonControlParam& operator=(LonControlParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LonControlParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LonControlParam* internal_default_instance() {
    return reinterpret_cast<const LonControlParam*>(
               &_LonControlParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LonControlParam* other);
  friend void swap(LonControlParam& a, LonControlParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LonControlParam* New() const PROTOBUF_FINAL { return New(NULL); }

  LonControlParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LonControlParam& from);
  void MergeFrom(const LonControlParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LonControlParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .LC.ReverseStationPidConfigure reverse_station_pid_configure = 1;
  bool has_reverse_station_pid_configure() const;
  void clear_reverse_station_pid_configure();
  static const int kReverseStationPidConfigureFieldNumber = 1;
  const ::LC::ReverseStationPidConfigure& reverse_station_pid_configure() const;
  ::LC::ReverseStationPidConfigure* release_reverse_station_pid_configure();
  ::LC::ReverseStationPidConfigure* mutable_reverse_station_pid_configure();
  void set_allocated_reverse_station_pid_configure(::LC::ReverseStationPidConfigure* reverse_station_pid_configure);

  // optional .LC.ReverseSpeedPidConfigure reverse_speed_pid_configure = 2;
  bool has_reverse_speed_pid_configure() const;
  void clear_reverse_speed_pid_configure();
  static const int kReverseSpeedPidConfigureFieldNumber = 2;
  const ::LC::ReverseSpeedPidConfigure& reverse_speed_pid_configure() const;
  ::LC::ReverseSpeedPidConfigure* release_reverse_speed_pid_configure();
  ::LC::ReverseSpeedPidConfigure* mutable_reverse_speed_pid_configure();
  void set_allocated_reverse_speed_pid_configure(::LC::ReverseSpeedPidConfigure* reverse_speed_pid_configure);

  // optional .LC.LowSpeedPidConfigure low_speed_pid_configure = 3;
  bool has_low_speed_pid_configure() const;
  void clear_low_speed_pid_configure();
  static const int kLowSpeedPidConfigureFieldNumber = 3;
  const ::LC::LowSpeedPidConfigure& low_speed_pid_configure() const;
  ::LC::LowSpeedPidConfigure* release_low_speed_pid_configure();
  ::LC::LowSpeedPidConfigure* mutable_low_speed_pid_configure();
  void set_allocated_low_speed_pid_configure(::LC::LowSpeedPidConfigure* low_speed_pid_configure);

  // optional .LC.HighSpeedPidConfigure high_speed_pid_configure = 4;
  bool has_high_speed_pid_configure() const;
  void clear_high_speed_pid_configure();
  static const int kHighSpeedPidConfigureFieldNumber = 4;
  const ::LC::HighSpeedPidConfigure& high_speed_pid_configure() const;
  ::LC::HighSpeedPidConfigure* release_high_speed_pid_configure();
  ::LC::HighSpeedPidConfigure* mutable_high_speed_pid_configure();
  void set_allocated_high_speed_pid_configure(::LC::HighSpeedPidConfigure* high_speed_pid_configure);

  // optional .LC.StationPidConfigure station_pid_configure = 5;
  bool has_station_pid_configure() const;
  void clear_station_pid_configure();
  static const int kStationPidConfigureFieldNumber = 5;
  const ::LC::StationPidConfigure& station_pid_configure() const;
  ::LC::StationPidConfigure* release_station_pid_configure();
  ::LC::StationPidConfigure* mutable_station_pid_configure();
  void set_allocated_station_pid_configure(::LC::StationPidConfigure* station_pid_configure);

  // optional .LC.OtherParamConfigure other_param_configure = 6;
  bool has_other_param_configure() const;
  void clear_other_param_configure();
  static const int kOtherParamConfigureFieldNumber = 6;
  const ::LC::OtherParamConfigure& other_param_configure() const;
  ::LC::OtherParamConfigure* release_other_param_configure();
  ::LC::OtherParamConfigure* mutable_other_param_configure();
  void set_allocated_other_param_configure(::LC::OtherParamConfigure* other_param_configure);

  // @@protoc_insertion_point(class_scope:LC.LonControlParam)
 private:
  void set_has_reverse_station_pid_configure();
  void clear_has_reverse_station_pid_configure();
  void set_has_reverse_speed_pid_configure();
  void clear_has_reverse_speed_pid_configure();
  void set_has_low_speed_pid_configure();
  void clear_has_low_speed_pid_configure();
  void set_has_high_speed_pid_configure();
  void clear_has_high_speed_pid_configure();
  void set_has_station_pid_configure();
  void clear_has_station_pid_configure();
  void set_has_other_param_configure();
  void clear_has_other_param_configure();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::LC::ReverseStationPidConfigure* reverse_station_pid_configure_;
  ::LC::ReverseSpeedPidConfigure* reverse_speed_pid_configure_;
  ::LC::LowSpeedPidConfigure* low_speed_pid_configure_;
  ::LC::HighSpeedPidConfigure* high_speed_pid_configure_;
  ::LC::StationPidConfigure* station_pid_configure_;
  ::LC::OtherParamConfigure* other_param_configure_;
  friend struct ::protobuf_control_2flc_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flc_5fconfig_2eproto::InitDefaultsLonControlParamImpl();
};
// -------------------------------------------------------------------

class ReverseStationPidConfigure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LC.ReverseStationPidConfigure) */ {
 public:
  ReverseStationPidConfigure();
  virtual ~ReverseStationPidConfigure();

  ReverseStationPidConfigure(const ReverseStationPidConfigure& from);

  inline ReverseStationPidConfigure& operator=(const ReverseStationPidConfigure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReverseStationPidConfigure(ReverseStationPidConfigure&& from) noexcept
    : ReverseStationPidConfigure() {
    *this = ::std::move(from);
  }

  inline ReverseStationPidConfigure& operator=(ReverseStationPidConfigure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReverseStationPidConfigure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReverseStationPidConfigure* internal_default_instance() {
    return reinterpret_cast<const ReverseStationPidConfigure*>(
               &_ReverseStationPidConfigure_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ReverseStationPidConfigure* other);
  friend void swap(ReverseStationPidConfigure& a, ReverseStationPidConfigure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReverseStationPidConfigure* New() const PROTOBUF_FINAL { return New(NULL); }

  ReverseStationPidConfigure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReverseStationPidConfigure& from);
  void MergeFrom(const ReverseStationPidConfigure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReverseStationPidConfigure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool integrator_enable = 1;
  bool has_integrator_enable() const;
  void clear_integrator_enable();
  static const int kIntegratorEnableFieldNumber = 1;
  bool integrator_enable() const;
  void set_integrator_enable(bool value);

  // optional float integrator_saturation_level = 2;
  bool has_integrator_saturation_level() const;
  void clear_integrator_saturation_level();
  static const int kIntegratorSaturationLevelFieldNumber = 2;
  float integrator_saturation_level() const;
  void set_integrator_saturation_level(float value);

  // optional float kp = 3;
  bool has_kp() const;
  void clear_kp();
  static const int kKpFieldNumber = 3;
  float kp() const;
  void set_kp(float value);

  // optional float ki = 4;
  bool has_ki() const;
  void clear_ki();
  static const int kKiFieldNumber = 4;
  float ki() const;
  void set_ki(float value);

  // optional float kd = 5;
  bool has_kd() const;
  void clear_kd();
  static const int kKdFieldNumber = 5;
  float kd() const;
  void set_kd(float value);

  // @@protoc_insertion_point(class_scope:LC.ReverseStationPidConfigure)
 private:
  void set_has_integrator_enable();
  void clear_has_integrator_enable();
  void set_has_integrator_saturation_level();
  void clear_has_integrator_saturation_level();
  void set_has_kp();
  void clear_has_kp();
  void set_has_ki();
  void clear_has_ki();
  void set_has_kd();
  void clear_has_kd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool integrator_enable_;
  float integrator_saturation_level_;
  float kp_;
  float ki_;
  float kd_;
  friend struct ::protobuf_control_2flc_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flc_5fconfig_2eproto::InitDefaultsReverseStationPidConfigureImpl();
};
// -------------------------------------------------------------------

class ReverseSpeedPidConfigure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LC.ReverseSpeedPidConfigure) */ {
 public:
  ReverseSpeedPidConfigure();
  virtual ~ReverseSpeedPidConfigure();

  ReverseSpeedPidConfigure(const ReverseSpeedPidConfigure& from);

  inline ReverseSpeedPidConfigure& operator=(const ReverseSpeedPidConfigure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReverseSpeedPidConfigure(ReverseSpeedPidConfigure&& from) noexcept
    : ReverseSpeedPidConfigure() {
    *this = ::std::move(from);
  }

  inline ReverseSpeedPidConfigure& operator=(ReverseSpeedPidConfigure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReverseSpeedPidConfigure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReverseSpeedPidConfigure* internal_default_instance() {
    return reinterpret_cast<const ReverseSpeedPidConfigure*>(
               &_ReverseSpeedPidConfigure_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ReverseSpeedPidConfigure* other);
  friend void swap(ReverseSpeedPidConfigure& a, ReverseSpeedPidConfigure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReverseSpeedPidConfigure* New() const PROTOBUF_FINAL { return New(NULL); }

  ReverseSpeedPidConfigure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReverseSpeedPidConfigure& from);
  void MergeFrom(const ReverseSpeedPidConfigure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReverseSpeedPidConfigure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool integrator_enable = 1;
  bool has_integrator_enable() const;
  void clear_integrator_enable();
  static const int kIntegratorEnableFieldNumber = 1;
  bool integrator_enable() const;
  void set_integrator_enable(bool value);

  // optional float integrator_saturation_level = 2;
  bool has_integrator_saturation_level() const;
  void clear_integrator_saturation_level();
  static const int kIntegratorSaturationLevelFieldNumber = 2;
  float integrator_saturation_level() const;
  void set_integrator_saturation_level(float value);

  // optional float kp = 3;
  bool has_kp() const;
  void clear_kp();
  static const int kKpFieldNumber = 3;
  float kp() const;
  void set_kp(float value);

  // optional float ki = 4;
  bool has_ki() const;
  void clear_ki();
  static const int kKiFieldNumber = 4;
  float ki() const;
  void set_ki(float value);

  // optional float kd = 5;
  bool has_kd() const;
  void clear_kd();
  static const int kKdFieldNumber = 5;
  float kd() const;
  void set_kd(float value);

  // @@protoc_insertion_point(class_scope:LC.ReverseSpeedPidConfigure)
 private:
  void set_has_integrator_enable();
  void clear_has_integrator_enable();
  void set_has_integrator_saturation_level();
  void clear_has_integrator_saturation_level();
  void set_has_kp();
  void clear_has_kp();
  void set_has_ki();
  void clear_has_ki();
  void set_has_kd();
  void clear_has_kd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool integrator_enable_;
  float integrator_saturation_level_;
  float kp_;
  float ki_;
  float kd_;
  friend struct ::protobuf_control_2flc_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flc_5fconfig_2eproto::InitDefaultsReverseSpeedPidConfigureImpl();
};
// -------------------------------------------------------------------

class LowSpeedPidConfigure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LC.LowSpeedPidConfigure) */ {
 public:
  LowSpeedPidConfigure();
  virtual ~LowSpeedPidConfigure();

  LowSpeedPidConfigure(const LowSpeedPidConfigure& from);

  inline LowSpeedPidConfigure& operator=(const LowSpeedPidConfigure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LowSpeedPidConfigure(LowSpeedPidConfigure&& from) noexcept
    : LowSpeedPidConfigure() {
    *this = ::std::move(from);
  }

  inline LowSpeedPidConfigure& operator=(LowSpeedPidConfigure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LowSpeedPidConfigure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LowSpeedPidConfigure* internal_default_instance() {
    return reinterpret_cast<const LowSpeedPidConfigure*>(
               &_LowSpeedPidConfigure_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(LowSpeedPidConfigure* other);
  friend void swap(LowSpeedPidConfigure& a, LowSpeedPidConfigure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LowSpeedPidConfigure* New() const PROTOBUF_FINAL { return New(NULL); }

  LowSpeedPidConfigure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LowSpeedPidConfigure& from);
  void MergeFrom(const LowSpeedPidConfigure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LowSpeedPidConfigure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool integrator_enable = 1;
  bool has_integrator_enable() const;
  void clear_integrator_enable();
  static const int kIntegratorEnableFieldNumber = 1;
  bool integrator_enable() const;
  void set_integrator_enable(bool value);

  // optional float integrator_saturation_level = 2;
  bool has_integrator_saturation_level() const;
  void clear_integrator_saturation_level();
  static const int kIntegratorSaturationLevelFieldNumber = 2;
  float integrator_saturation_level() const;
  void set_integrator_saturation_level(float value);

  // optional float kp = 3;
  bool has_kp() const;
  void clear_kp();
  static const int kKpFieldNumber = 3;
  float kp() const;
  void set_kp(float value);

  // optional float ki = 4;
  bool has_ki() const;
  void clear_ki();
  static const int kKiFieldNumber = 4;
  float ki() const;
  void set_ki(float value);

  // optional float kd = 5;
  bool has_kd() const;
  void clear_kd();
  static const int kKdFieldNumber = 5;
  float kd() const;
  void set_kd(float value);

  // @@protoc_insertion_point(class_scope:LC.LowSpeedPidConfigure)
 private:
  void set_has_integrator_enable();
  void clear_has_integrator_enable();
  void set_has_integrator_saturation_level();
  void clear_has_integrator_saturation_level();
  void set_has_kp();
  void clear_has_kp();
  void set_has_ki();
  void clear_has_ki();
  void set_has_kd();
  void clear_has_kd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool integrator_enable_;
  float integrator_saturation_level_;
  float kp_;
  float ki_;
  float kd_;
  friend struct ::protobuf_control_2flc_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flc_5fconfig_2eproto::InitDefaultsLowSpeedPidConfigureImpl();
};
// -------------------------------------------------------------------

class HighSpeedPidConfigure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LC.HighSpeedPidConfigure) */ {
 public:
  HighSpeedPidConfigure();
  virtual ~HighSpeedPidConfigure();

  HighSpeedPidConfigure(const HighSpeedPidConfigure& from);

  inline HighSpeedPidConfigure& operator=(const HighSpeedPidConfigure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HighSpeedPidConfigure(HighSpeedPidConfigure&& from) noexcept
    : HighSpeedPidConfigure() {
    *this = ::std::move(from);
  }

  inline HighSpeedPidConfigure& operator=(HighSpeedPidConfigure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HighSpeedPidConfigure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HighSpeedPidConfigure* internal_default_instance() {
    return reinterpret_cast<const HighSpeedPidConfigure*>(
               &_HighSpeedPidConfigure_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(HighSpeedPidConfigure* other);
  friend void swap(HighSpeedPidConfigure& a, HighSpeedPidConfigure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HighSpeedPidConfigure* New() const PROTOBUF_FINAL { return New(NULL); }

  HighSpeedPidConfigure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HighSpeedPidConfigure& from);
  void MergeFrom(const HighSpeedPidConfigure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HighSpeedPidConfigure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool integrator_enable = 1;
  bool has_integrator_enable() const;
  void clear_integrator_enable();
  static const int kIntegratorEnableFieldNumber = 1;
  bool integrator_enable() const;
  void set_integrator_enable(bool value);

  // optional float integrator_saturation_level = 2;
  bool has_integrator_saturation_level() const;
  void clear_integrator_saturation_level();
  static const int kIntegratorSaturationLevelFieldNumber = 2;
  float integrator_saturation_level() const;
  void set_integrator_saturation_level(float value);

  // optional float kp = 3;
  bool has_kp() const;
  void clear_kp();
  static const int kKpFieldNumber = 3;
  float kp() const;
  void set_kp(float value);

  // optional float ki = 4;
  bool has_ki() const;
  void clear_ki();
  static const int kKiFieldNumber = 4;
  float ki() const;
  void set_ki(float value);

  // optional float kd = 5;
  bool has_kd() const;
  void clear_kd();
  static const int kKdFieldNumber = 5;
  float kd() const;
  void set_kd(float value);

  // @@protoc_insertion_point(class_scope:LC.HighSpeedPidConfigure)
 private:
  void set_has_integrator_enable();
  void clear_has_integrator_enable();
  void set_has_integrator_saturation_level();
  void clear_has_integrator_saturation_level();
  void set_has_kp();
  void clear_has_kp();
  void set_has_ki();
  void clear_has_ki();
  void set_has_kd();
  void clear_has_kd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool integrator_enable_;
  float integrator_saturation_level_;
  float kp_;
  float ki_;
  float kd_;
  friend struct ::protobuf_control_2flc_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flc_5fconfig_2eproto::InitDefaultsHighSpeedPidConfigureImpl();
};
// -------------------------------------------------------------------

class StationPidConfigure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LC.StationPidConfigure) */ {
 public:
  StationPidConfigure();
  virtual ~StationPidConfigure();

  StationPidConfigure(const StationPidConfigure& from);

  inline StationPidConfigure& operator=(const StationPidConfigure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StationPidConfigure(StationPidConfigure&& from) noexcept
    : StationPidConfigure() {
    *this = ::std::move(from);
  }

  inline StationPidConfigure& operator=(StationPidConfigure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StationPidConfigure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StationPidConfigure* internal_default_instance() {
    return reinterpret_cast<const StationPidConfigure*>(
               &_StationPidConfigure_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(StationPidConfigure* other);
  friend void swap(StationPidConfigure& a, StationPidConfigure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StationPidConfigure* New() const PROTOBUF_FINAL { return New(NULL); }

  StationPidConfigure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StationPidConfigure& from);
  void MergeFrom(const StationPidConfigure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StationPidConfigure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool integrator_enable = 1;
  bool has_integrator_enable() const;
  void clear_integrator_enable();
  static const int kIntegratorEnableFieldNumber = 1;
  bool integrator_enable() const;
  void set_integrator_enable(bool value);

  // optional float integrator_saturation_level = 2;
  bool has_integrator_saturation_level() const;
  void clear_integrator_saturation_level();
  static const int kIntegratorSaturationLevelFieldNumber = 2;
  float integrator_saturation_level() const;
  void set_integrator_saturation_level(float value);

  // optional float kp = 3;
  bool has_kp() const;
  void clear_kp();
  static const int kKpFieldNumber = 3;
  float kp() const;
  void set_kp(float value);

  // optional float ki = 4;
  bool has_ki() const;
  void clear_ki();
  static const int kKiFieldNumber = 4;
  float ki() const;
  void set_ki(float value);

  // optional float kd = 5;
  bool has_kd() const;
  void clear_kd();
  static const int kKdFieldNumber = 5;
  float kd() const;
  void set_kd(float value);

  // @@protoc_insertion_point(class_scope:LC.StationPidConfigure)
 private:
  void set_has_integrator_enable();
  void clear_has_integrator_enable();
  void set_has_integrator_saturation_level();
  void clear_has_integrator_saturation_level();
  void set_has_kp();
  void clear_has_kp();
  void set_has_ki();
  void clear_has_ki();
  void set_has_kd();
  void clear_has_kd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool integrator_enable_;
  float integrator_saturation_level_;
  float kp_;
  float ki_;
  float kd_;
  friend struct ::protobuf_control_2flc_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flc_5fconfig_2eproto::InitDefaultsStationPidConfigureImpl();
};
// -------------------------------------------------------------------

class OtherParamConfigure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LC.OtherParamConfigure) */ {
 public:
  OtherParamConfigure();
  virtual ~OtherParamConfigure();

  OtherParamConfigure(const OtherParamConfigure& from);

  inline OtherParamConfigure& operator=(const OtherParamConfigure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OtherParamConfigure(OtherParamConfigure&& from) noexcept
    : OtherParamConfigure() {
    *this = ::std::move(from);
  }

  inline OtherParamConfigure& operator=(OtherParamConfigure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OtherParamConfigure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OtherParamConfigure* internal_default_instance() {
    return reinterpret_cast<const OtherParamConfigure*>(
               &_OtherParamConfigure_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(OtherParamConfigure* other);
  friend void swap(OtherParamConfigure& a, OtherParamConfigure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OtherParamConfigure* New() const PROTOBUF_FINAL { return New(NULL); }

  OtherParamConfigure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OtherParamConfigure& from);
  void MergeFrom(const OtherParamConfigure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OtherParamConfigure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 speed_offset_enable = 1;
  bool has_speed_offset_enable() const;
  void clear_speed_offset_enable();
  static const int kSpeedOffsetEnableFieldNumber = 1;
  ::google::protobuf::int32 speed_offset_enable() const;
  void set_speed_offset_enable(::google::protobuf::int32 value);

  // optional float sample_time = 2;
  bool has_sample_time() const;
  void clear_sample_time();
  static const int kSampleTimeFieldNumber = 2;
  float sample_time() const;
  void set_sample_time(float value);

  // optional float static_speed = 3;
  bool has_static_speed() const;
  void clear_static_speed();
  static const int kStaticSpeedFieldNumber = 3;
  float static_speed() const;
  void set_static_speed(float value);

  // optional float acc_min = 4;
  bool has_acc_min() const;
  void clear_acc_min();
  static const int kAccMinFieldNumber = 4;
  float acc_min() const;
  void set_acc_min(float value);

  // optional float acc_max = 5;
  bool has_acc_max() const;
  void clear_acc_max();
  static const int kAccMaxFieldNumber = 5;
  float acc_max() const;
  void set_acc_max(float value);

  // optional float high_low_speed_standard = 6;
  bool has_high_low_speed_standard() const;
  void clear_high_low_speed_standard();
  static const int kHighLowSpeedStandardFieldNumber = 6;
  float high_low_speed_standard() const;
  void set_high_low_speed_standard(float value);

  // optional float station_error_limit = 7;
  bool has_station_error_limit() const;
  void clear_station_error_limit();
  static const int kStationErrorLimitFieldNumber = 7;
  float station_error_limit() const;
  void set_station_error_limit(float value);

  // optional float speed_controller_input_limit = 8;
  bool has_speed_controller_input_limit() const;
  void clear_speed_controller_input_limit();
  static const int kSpeedControllerInputLimitFieldNumber = 8;
  float speed_controller_input_limit() const;
  void set_speed_controller_input_limit(float value);

  // optional int32 track_point_flag = 9;
  bool has_track_point_flag() const;
  void clear_track_point_flag();
  static const int kTrackPointFlagFieldNumber = 9;
  ::google::protobuf::int32 track_point_flag() const;
  void set_track_point_flag(::google::protobuf::int32 value);

  // optional int32 reference_acc_flag = 10;
  bool has_reference_acc_flag() const;
  void clear_reference_acc_flag();
  static const int kReferenceAccFlagFieldNumber = 10;
  ::google::protobuf::int32 reference_acc_flag() const;
  void set_reference_acc_flag(::google::protobuf::int32 value);

  // optional float min_start_acc = 11;
  bool has_min_start_acc() const;
  void clear_min_start_acc();
  static const int kMinStartAccFieldNumber = 11;
  float min_start_acc() const;
  void set_min_start_acc(float value);

  // optional int32 next_num = 12;
  bool has_next_num() const;
  void clear_next_num();
  static const int kNextNumFieldNumber = 12;
  ::google::protobuf::int32 next_num() const;
  void set_next_num(::google::protobuf::int32 value);

  // optional float speed_quicken = 13;
  bool has_speed_quicken() const;
  void clear_speed_quicken();
  static const int kSpeedQuickenFieldNumber = 13;
  float speed_quicken() const;
  void set_speed_quicken(float value);

  // optional float speed_decelerate = 14;
  bool has_speed_decelerate() const;
  void clear_speed_decelerate();
  static const int kSpeedDecelerateFieldNumber = 14;
  float speed_decelerate() const;
  void set_speed_decelerate(float value);

  // optional float min_start_dec = 15;
  bool has_min_start_dec() const;
  void clear_min_start_dec();
  static const int kMinStartDecFieldNumber = 15;
  float min_start_dec() const;
  void set_min_start_dec(float value);

  // optional float delta_acc = 16;
  bool has_delta_acc() const;
  void clear_delta_acc();
  static const int kDeltaAccFieldNumber = 16;
  float delta_acc() const;
  void set_delta_acc(float value);

  // optional float delta_dec = 17;
  bool has_delta_dec() const;
  void clear_delta_dec();
  static const int kDeltaDecFieldNumber = 17;
  float delta_dec() const;
  void set_delta_dec(float value);

  // @@protoc_insertion_point(class_scope:LC.OtherParamConfigure)
 private:
  void set_has_speed_offset_enable();
  void clear_has_speed_offset_enable();
  void set_has_sample_time();
  void clear_has_sample_time();
  void set_has_static_speed();
  void clear_has_static_speed();
  void set_has_acc_min();
  void clear_has_acc_min();
  void set_has_acc_max();
  void clear_has_acc_max();
  void set_has_high_low_speed_standard();
  void clear_has_high_low_speed_standard();
  void set_has_station_error_limit();
  void clear_has_station_error_limit();
  void set_has_speed_controller_input_limit();
  void clear_has_speed_controller_input_limit();
  void set_has_track_point_flag();
  void clear_has_track_point_flag();
  void set_has_reference_acc_flag();
  void clear_has_reference_acc_flag();
  void set_has_min_start_acc();
  void clear_has_min_start_acc();
  void set_has_next_num();
  void clear_has_next_num();
  void set_has_speed_quicken();
  void clear_has_speed_quicken();
  void set_has_speed_decelerate();
  void clear_has_speed_decelerate();
  void set_has_min_start_dec();
  void clear_has_min_start_dec();
  void set_has_delta_acc();
  void clear_has_delta_acc();
  void set_has_delta_dec();
  void clear_has_delta_dec();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 speed_offset_enable_;
  float sample_time_;
  float static_speed_;
  float acc_min_;
  float acc_max_;
  float high_low_speed_standard_;
  float station_error_limit_;
  float speed_controller_input_limit_;
  ::google::protobuf::int32 track_point_flag_;
  ::google::protobuf::int32 reference_acc_flag_;
  float min_start_acc_;
  ::google::protobuf::int32 next_num_;
  float speed_quicken_;
  float speed_decelerate_;
  float min_start_dec_;
  float delta_acc_;
  float delta_dec_;
  friend struct ::protobuf_control_2flc_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flc_5fconfig_2eproto::InitDefaultsOtherParamConfigureImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LonControlParam

// optional .LC.ReverseStationPidConfigure reverse_station_pid_configure = 1;
inline bool LonControlParam::has_reverse_station_pid_configure() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LonControlParam::set_has_reverse_station_pid_configure() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LonControlParam::clear_has_reverse_station_pid_configure() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LonControlParam::clear_reverse_station_pid_configure() {
  if (reverse_station_pid_configure_ != NULL) reverse_station_pid_configure_->Clear();
  clear_has_reverse_station_pid_configure();
}
inline const ::LC::ReverseStationPidConfigure& LonControlParam::reverse_station_pid_configure() const {
  const ::LC::ReverseStationPidConfigure* p = reverse_station_pid_configure_;
  // @@protoc_insertion_point(field_get:LC.LonControlParam.reverse_station_pid_configure)
  return p != NULL ? *p : *reinterpret_cast<const ::LC::ReverseStationPidConfigure*>(
      &::LC::_ReverseStationPidConfigure_default_instance_);
}
inline ::LC::ReverseStationPidConfigure* LonControlParam::release_reverse_station_pid_configure() {
  // @@protoc_insertion_point(field_release:LC.LonControlParam.reverse_station_pid_configure)
  clear_has_reverse_station_pid_configure();
  ::LC::ReverseStationPidConfigure* temp = reverse_station_pid_configure_;
  reverse_station_pid_configure_ = NULL;
  return temp;
}
inline ::LC::ReverseStationPidConfigure* LonControlParam::mutable_reverse_station_pid_configure() {
  set_has_reverse_station_pid_configure();
  if (reverse_station_pid_configure_ == NULL) {
    reverse_station_pid_configure_ = new ::LC::ReverseStationPidConfigure;
  }
  // @@protoc_insertion_point(field_mutable:LC.LonControlParam.reverse_station_pid_configure)
  return reverse_station_pid_configure_;
}
inline void LonControlParam::set_allocated_reverse_station_pid_configure(::LC::ReverseStationPidConfigure* reverse_station_pid_configure) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reverse_station_pid_configure_;
  }
  if (reverse_station_pid_configure) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reverse_station_pid_configure = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reverse_station_pid_configure, submessage_arena);
    }
    set_has_reverse_station_pid_configure();
  } else {
    clear_has_reverse_station_pid_configure();
  }
  reverse_station_pid_configure_ = reverse_station_pid_configure;
  // @@protoc_insertion_point(field_set_allocated:LC.LonControlParam.reverse_station_pid_configure)
}

// optional .LC.ReverseSpeedPidConfigure reverse_speed_pid_configure = 2;
inline bool LonControlParam::has_reverse_speed_pid_configure() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LonControlParam::set_has_reverse_speed_pid_configure() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LonControlParam::clear_has_reverse_speed_pid_configure() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LonControlParam::clear_reverse_speed_pid_configure() {
  if (reverse_speed_pid_configure_ != NULL) reverse_speed_pid_configure_->Clear();
  clear_has_reverse_speed_pid_configure();
}
inline const ::LC::ReverseSpeedPidConfigure& LonControlParam::reverse_speed_pid_configure() const {
  const ::LC::ReverseSpeedPidConfigure* p = reverse_speed_pid_configure_;
  // @@protoc_insertion_point(field_get:LC.LonControlParam.reverse_speed_pid_configure)
  return p != NULL ? *p : *reinterpret_cast<const ::LC::ReverseSpeedPidConfigure*>(
      &::LC::_ReverseSpeedPidConfigure_default_instance_);
}
inline ::LC::ReverseSpeedPidConfigure* LonControlParam::release_reverse_speed_pid_configure() {
  // @@protoc_insertion_point(field_release:LC.LonControlParam.reverse_speed_pid_configure)
  clear_has_reverse_speed_pid_configure();
  ::LC::ReverseSpeedPidConfigure* temp = reverse_speed_pid_configure_;
  reverse_speed_pid_configure_ = NULL;
  return temp;
}
inline ::LC::ReverseSpeedPidConfigure* LonControlParam::mutable_reverse_speed_pid_configure() {
  set_has_reverse_speed_pid_configure();
  if (reverse_speed_pid_configure_ == NULL) {
    reverse_speed_pid_configure_ = new ::LC::ReverseSpeedPidConfigure;
  }
  // @@protoc_insertion_point(field_mutable:LC.LonControlParam.reverse_speed_pid_configure)
  return reverse_speed_pid_configure_;
}
inline void LonControlParam::set_allocated_reverse_speed_pid_configure(::LC::ReverseSpeedPidConfigure* reverse_speed_pid_configure) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reverse_speed_pid_configure_;
  }
  if (reverse_speed_pid_configure) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      reverse_speed_pid_configure = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, reverse_speed_pid_configure, submessage_arena);
    }
    set_has_reverse_speed_pid_configure();
  } else {
    clear_has_reverse_speed_pid_configure();
  }
  reverse_speed_pid_configure_ = reverse_speed_pid_configure;
  // @@protoc_insertion_point(field_set_allocated:LC.LonControlParam.reverse_speed_pid_configure)
}

// optional .LC.LowSpeedPidConfigure low_speed_pid_configure = 3;
inline bool LonControlParam::has_low_speed_pid_configure() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LonControlParam::set_has_low_speed_pid_configure() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LonControlParam::clear_has_low_speed_pid_configure() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LonControlParam::clear_low_speed_pid_configure() {
  if (low_speed_pid_configure_ != NULL) low_speed_pid_configure_->Clear();
  clear_has_low_speed_pid_configure();
}
inline const ::LC::LowSpeedPidConfigure& LonControlParam::low_speed_pid_configure() const {
  const ::LC::LowSpeedPidConfigure* p = low_speed_pid_configure_;
  // @@protoc_insertion_point(field_get:LC.LonControlParam.low_speed_pid_configure)
  return p != NULL ? *p : *reinterpret_cast<const ::LC::LowSpeedPidConfigure*>(
      &::LC::_LowSpeedPidConfigure_default_instance_);
}
inline ::LC::LowSpeedPidConfigure* LonControlParam::release_low_speed_pid_configure() {
  // @@protoc_insertion_point(field_release:LC.LonControlParam.low_speed_pid_configure)
  clear_has_low_speed_pid_configure();
  ::LC::LowSpeedPidConfigure* temp = low_speed_pid_configure_;
  low_speed_pid_configure_ = NULL;
  return temp;
}
inline ::LC::LowSpeedPidConfigure* LonControlParam::mutable_low_speed_pid_configure() {
  set_has_low_speed_pid_configure();
  if (low_speed_pid_configure_ == NULL) {
    low_speed_pid_configure_ = new ::LC::LowSpeedPidConfigure;
  }
  // @@protoc_insertion_point(field_mutable:LC.LonControlParam.low_speed_pid_configure)
  return low_speed_pid_configure_;
}
inline void LonControlParam::set_allocated_low_speed_pid_configure(::LC::LowSpeedPidConfigure* low_speed_pid_configure) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete low_speed_pid_configure_;
  }
  if (low_speed_pid_configure) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      low_speed_pid_configure = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, low_speed_pid_configure, submessage_arena);
    }
    set_has_low_speed_pid_configure();
  } else {
    clear_has_low_speed_pid_configure();
  }
  low_speed_pid_configure_ = low_speed_pid_configure;
  // @@protoc_insertion_point(field_set_allocated:LC.LonControlParam.low_speed_pid_configure)
}

// optional .LC.HighSpeedPidConfigure high_speed_pid_configure = 4;
inline bool LonControlParam::has_high_speed_pid_configure() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LonControlParam::set_has_high_speed_pid_configure() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LonControlParam::clear_has_high_speed_pid_configure() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LonControlParam::clear_high_speed_pid_configure() {
  if (high_speed_pid_configure_ != NULL) high_speed_pid_configure_->Clear();
  clear_has_high_speed_pid_configure();
}
inline const ::LC::HighSpeedPidConfigure& LonControlParam::high_speed_pid_configure() const {
  const ::LC::HighSpeedPidConfigure* p = high_speed_pid_configure_;
  // @@protoc_insertion_point(field_get:LC.LonControlParam.high_speed_pid_configure)
  return p != NULL ? *p : *reinterpret_cast<const ::LC::HighSpeedPidConfigure*>(
      &::LC::_HighSpeedPidConfigure_default_instance_);
}
inline ::LC::HighSpeedPidConfigure* LonControlParam::release_high_speed_pid_configure() {
  // @@protoc_insertion_point(field_release:LC.LonControlParam.high_speed_pid_configure)
  clear_has_high_speed_pid_configure();
  ::LC::HighSpeedPidConfigure* temp = high_speed_pid_configure_;
  high_speed_pid_configure_ = NULL;
  return temp;
}
inline ::LC::HighSpeedPidConfigure* LonControlParam::mutable_high_speed_pid_configure() {
  set_has_high_speed_pid_configure();
  if (high_speed_pid_configure_ == NULL) {
    high_speed_pid_configure_ = new ::LC::HighSpeedPidConfigure;
  }
  // @@protoc_insertion_point(field_mutable:LC.LonControlParam.high_speed_pid_configure)
  return high_speed_pid_configure_;
}
inline void LonControlParam::set_allocated_high_speed_pid_configure(::LC::HighSpeedPidConfigure* high_speed_pid_configure) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete high_speed_pid_configure_;
  }
  if (high_speed_pid_configure) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      high_speed_pid_configure = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, high_speed_pid_configure, submessage_arena);
    }
    set_has_high_speed_pid_configure();
  } else {
    clear_has_high_speed_pid_configure();
  }
  high_speed_pid_configure_ = high_speed_pid_configure;
  // @@protoc_insertion_point(field_set_allocated:LC.LonControlParam.high_speed_pid_configure)
}

// optional .LC.StationPidConfigure station_pid_configure = 5;
inline bool LonControlParam::has_station_pid_configure() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LonControlParam::set_has_station_pid_configure() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LonControlParam::clear_has_station_pid_configure() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LonControlParam::clear_station_pid_configure() {
  if (station_pid_configure_ != NULL) station_pid_configure_->Clear();
  clear_has_station_pid_configure();
}
inline const ::LC::StationPidConfigure& LonControlParam::station_pid_configure() const {
  const ::LC::StationPidConfigure* p = station_pid_configure_;
  // @@protoc_insertion_point(field_get:LC.LonControlParam.station_pid_configure)
  return p != NULL ? *p : *reinterpret_cast<const ::LC::StationPidConfigure*>(
      &::LC::_StationPidConfigure_default_instance_);
}
inline ::LC::StationPidConfigure* LonControlParam::release_station_pid_configure() {
  // @@protoc_insertion_point(field_release:LC.LonControlParam.station_pid_configure)
  clear_has_station_pid_configure();
  ::LC::StationPidConfigure* temp = station_pid_configure_;
  station_pid_configure_ = NULL;
  return temp;
}
inline ::LC::StationPidConfigure* LonControlParam::mutable_station_pid_configure() {
  set_has_station_pid_configure();
  if (station_pid_configure_ == NULL) {
    station_pid_configure_ = new ::LC::StationPidConfigure;
  }
  // @@protoc_insertion_point(field_mutable:LC.LonControlParam.station_pid_configure)
  return station_pid_configure_;
}
inline void LonControlParam::set_allocated_station_pid_configure(::LC::StationPidConfigure* station_pid_configure) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete station_pid_configure_;
  }
  if (station_pid_configure) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      station_pid_configure = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, station_pid_configure, submessage_arena);
    }
    set_has_station_pid_configure();
  } else {
    clear_has_station_pid_configure();
  }
  station_pid_configure_ = station_pid_configure;
  // @@protoc_insertion_point(field_set_allocated:LC.LonControlParam.station_pid_configure)
}

// optional .LC.OtherParamConfigure other_param_configure = 6;
inline bool LonControlParam::has_other_param_configure() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LonControlParam::set_has_other_param_configure() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LonControlParam::clear_has_other_param_configure() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LonControlParam::clear_other_param_configure() {
  if (other_param_configure_ != NULL) other_param_configure_->Clear();
  clear_has_other_param_configure();
}
inline const ::LC::OtherParamConfigure& LonControlParam::other_param_configure() const {
  const ::LC::OtherParamConfigure* p = other_param_configure_;
  // @@protoc_insertion_point(field_get:LC.LonControlParam.other_param_configure)
  return p != NULL ? *p : *reinterpret_cast<const ::LC::OtherParamConfigure*>(
      &::LC::_OtherParamConfigure_default_instance_);
}
inline ::LC::OtherParamConfigure* LonControlParam::release_other_param_configure() {
  // @@protoc_insertion_point(field_release:LC.LonControlParam.other_param_configure)
  clear_has_other_param_configure();
  ::LC::OtherParamConfigure* temp = other_param_configure_;
  other_param_configure_ = NULL;
  return temp;
}
inline ::LC::OtherParamConfigure* LonControlParam::mutable_other_param_configure() {
  set_has_other_param_configure();
  if (other_param_configure_ == NULL) {
    other_param_configure_ = new ::LC::OtherParamConfigure;
  }
  // @@protoc_insertion_point(field_mutable:LC.LonControlParam.other_param_configure)
  return other_param_configure_;
}
inline void LonControlParam::set_allocated_other_param_configure(::LC::OtherParamConfigure* other_param_configure) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete other_param_configure_;
  }
  if (other_param_configure) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      other_param_configure = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, other_param_configure, submessage_arena);
    }
    set_has_other_param_configure();
  } else {
    clear_has_other_param_configure();
  }
  other_param_configure_ = other_param_configure;
  // @@protoc_insertion_point(field_set_allocated:LC.LonControlParam.other_param_configure)
}

// -------------------------------------------------------------------

// ReverseStationPidConfigure

// optional bool integrator_enable = 1;
inline bool ReverseStationPidConfigure::has_integrator_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReverseStationPidConfigure::set_has_integrator_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReverseStationPidConfigure::clear_has_integrator_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReverseStationPidConfigure::clear_integrator_enable() {
  integrator_enable_ = false;
  clear_has_integrator_enable();
}
inline bool ReverseStationPidConfigure::integrator_enable() const {
  // @@protoc_insertion_point(field_get:LC.ReverseStationPidConfigure.integrator_enable)
  return integrator_enable_;
}
inline void ReverseStationPidConfigure::set_integrator_enable(bool value) {
  set_has_integrator_enable();
  integrator_enable_ = value;
  // @@protoc_insertion_point(field_set:LC.ReverseStationPidConfigure.integrator_enable)
}

// optional float integrator_saturation_level = 2;
inline bool ReverseStationPidConfigure::has_integrator_saturation_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReverseStationPidConfigure::set_has_integrator_saturation_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReverseStationPidConfigure::clear_has_integrator_saturation_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReverseStationPidConfigure::clear_integrator_saturation_level() {
  integrator_saturation_level_ = 0;
  clear_has_integrator_saturation_level();
}
inline float ReverseStationPidConfigure::integrator_saturation_level() const {
  // @@protoc_insertion_point(field_get:LC.ReverseStationPidConfigure.integrator_saturation_level)
  return integrator_saturation_level_;
}
inline void ReverseStationPidConfigure::set_integrator_saturation_level(float value) {
  set_has_integrator_saturation_level();
  integrator_saturation_level_ = value;
  // @@protoc_insertion_point(field_set:LC.ReverseStationPidConfigure.integrator_saturation_level)
}

// optional float kp = 3;
inline bool ReverseStationPidConfigure::has_kp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReverseStationPidConfigure::set_has_kp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReverseStationPidConfigure::clear_has_kp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReverseStationPidConfigure::clear_kp() {
  kp_ = 0;
  clear_has_kp();
}
inline float ReverseStationPidConfigure::kp() const {
  // @@protoc_insertion_point(field_get:LC.ReverseStationPidConfigure.kp)
  return kp_;
}
inline void ReverseStationPidConfigure::set_kp(float value) {
  set_has_kp();
  kp_ = value;
  // @@protoc_insertion_point(field_set:LC.ReverseStationPidConfigure.kp)
}

// optional float ki = 4;
inline bool ReverseStationPidConfigure::has_ki() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReverseStationPidConfigure::set_has_ki() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReverseStationPidConfigure::clear_has_ki() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReverseStationPidConfigure::clear_ki() {
  ki_ = 0;
  clear_has_ki();
}
inline float ReverseStationPidConfigure::ki() const {
  // @@protoc_insertion_point(field_get:LC.ReverseStationPidConfigure.ki)
  return ki_;
}
inline void ReverseStationPidConfigure::set_ki(float value) {
  set_has_ki();
  ki_ = value;
  // @@protoc_insertion_point(field_set:LC.ReverseStationPidConfigure.ki)
}

// optional float kd = 5;
inline bool ReverseStationPidConfigure::has_kd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReverseStationPidConfigure::set_has_kd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReverseStationPidConfigure::clear_has_kd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReverseStationPidConfigure::clear_kd() {
  kd_ = 0;
  clear_has_kd();
}
inline float ReverseStationPidConfigure::kd() const {
  // @@protoc_insertion_point(field_get:LC.ReverseStationPidConfigure.kd)
  return kd_;
}
inline void ReverseStationPidConfigure::set_kd(float value) {
  set_has_kd();
  kd_ = value;
  // @@protoc_insertion_point(field_set:LC.ReverseStationPidConfigure.kd)
}

// -------------------------------------------------------------------

// ReverseSpeedPidConfigure

// optional bool integrator_enable = 1;
inline bool ReverseSpeedPidConfigure::has_integrator_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReverseSpeedPidConfigure::set_has_integrator_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReverseSpeedPidConfigure::clear_has_integrator_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReverseSpeedPidConfigure::clear_integrator_enable() {
  integrator_enable_ = false;
  clear_has_integrator_enable();
}
inline bool ReverseSpeedPidConfigure::integrator_enable() const {
  // @@protoc_insertion_point(field_get:LC.ReverseSpeedPidConfigure.integrator_enable)
  return integrator_enable_;
}
inline void ReverseSpeedPidConfigure::set_integrator_enable(bool value) {
  set_has_integrator_enable();
  integrator_enable_ = value;
  // @@protoc_insertion_point(field_set:LC.ReverseSpeedPidConfigure.integrator_enable)
}

// optional float integrator_saturation_level = 2;
inline bool ReverseSpeedPidConfigure::has_integrator_saturation_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReverseSpeedPidConfigure::set_has_integrator_saturation_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReverseSpeedPidConfigure::clear_has_integrator_saturation_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReverseSpeedPidConfigure::clear_integrator_saturation_level() {
  integrator_saturation_level_ = 0;
  clear_has_integrator_saturation_level();
}
inline float ReverseSpeedPidConfigure::integrator_saturation_level() const {
  // @@protoc_insertion_point(field_get:LC.ReverseSpeedPidConfigure.integrator_saturation_level)
  return integrator_saturation_level_;
}
inline void ReverseSpeedPidConfigure::set_integrator_saturation_level(float value) {
  set_has_integrator_saturation_level();
  integrator_saturation_level_ = value;
  // @@protoc_insertion_point(field_set:LC.ReverseSpeedPidConfigure.integrator_saturation_level)
}

// optional float kp = 3;
inline bool ReverseSpeedPidConfigure::has_kp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReverseSpeedPidConfigure::set_has_kp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReverseSpeedPidConfigure::clear_has_kp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReverseSpeedPidConfigure::clear_kp() {
  kp_ = 0;
  clear_has_kp();
}
inline float ReverseSpeedPidConfigure::kp() const {
  // @@protoc_insertion_point(field_get:LC.ReverseSpeedPidConfigure.kp)
  return kp_;
}
inline void ReverseSpeedPidConfigure::set_kp(float value) {
  set_has_kp();
  kp_ = value;
  // @@protoc_insertion_point(field_set:LC.ReverseSpeedPidConfigure.kp)
}

// optional float ki = 4;
inline bool ReverseSpeedPidConfigure::has_ki() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReverseSpeedPidConfigure::set_has_ki() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReverseSpeedPidConfigure::clear_has_ki() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReverseSpeedPidConfigure::clear_ki() {
  ki_ = 0;
  clear_has_ki();
}
inline float ReverseSpeedPidConfigure::ki() const {
  // @@protoc_insertion_point(field_get:LC.ReverseSpeedPidConfigure.ki)
  return ki_;
}
inline void ReverseSpeedPidConfigure::set_ki(float value) {
  set_has_ki();
  ki_ = value;
  // @@protoc_insertion_point(field_set:LC.ReverseSpeedPidConfigure.ki)
}

// optional float kd = 5;
inline bool ReverseSpeedPidConfigure::has_kd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReverseSpeedPidConfigure::set_has_kd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReverseSpeedPidConfigure::clear_has_kd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReverseSpeedPidConfigure::clear_kd() {
  kd_ = 0;
  clear_has_kd();
}
inline float ReverseSpeedPidConfigure::kd() const {
  // @@protoc_insertion_point(field_get:LC.ReverseSpeedPidConfigure.kd)
  return kd_;
}
inline void ReverseSpeedPidConfigure::set_kd(float value) {
  set_has_kd();
  kd_ = value;
  // @@protoc_insertion_point(field_set:LC.ReverseSpeedPidConfigure.kd)
}

// -------------------------------------------------------------------

// LowSpeedPidConfigure

// optional bool integrator_enable = 1;
inline bool LowSpeedPidConfigure::has_integrator_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LowSpeedPidConfigure::set_has_integrator_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LowSpeedPidConfigure::clear_has_integrator_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LowSpeedPidConfigure::clear_integrator_enable() {
  integrator_enable_ = false;
  clear_has_integrator_enable();
}
inline bool LowSpeedPidConfigure::integrator_enable() const {
  // @@protoc_insertion_point(field_get:LC.LowSpeedPidConfigure.integrator_enable)
  return integrator_enable_;
}
inline void LowSpeedPidConfigure::set_integrator_enable(bool value) {
  set_has_integrator_enable();
  integrator_enable_ = value;
  // @@protoc_insertion_point(field_set:LC.LowSpeedPidConfigure.integrator_enable)
}

// optional float integrator_saturation_level = 2;
inline bool LowSpeedPidConfigure::has_integrator_saturation_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LowSpeedPidConfigure::set_has_integrator_saturation_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LowSpeedPidConfigure::clear_has_integrator_saturation_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LowSpeedPidConfigure::clear_integrator_saturation_level() {
  integrator_saturation_level_ = 0;
  clear_has_integrator_saturation_level();
}
inline float LowSpeedPidConfigure::integrator_saturation_level() const {
  // @@protoc_insertion_point(field_get:LC.LowSpeedPidConfigure.integrator_saturation_level)
  return integrator_saturation_level_;
}
inline void LowSpeedPidConfigure::set_integrator_saturation_level(float value) {
  set_has_integrator_saturation_level();
  integrator_saturation_level_ = value;
  // @@protoc_insertion_point(field_set:LC.LowSpeedPidConfigure.integrator_saturation_level)
}

// optional float kp = 3;
inline bool LowSpeedPidConfigure::has_kp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LowSpeedPidConfigure::set_has_kp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LowSpeedPidConfigure::clear_has_kp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LowSpeedPidConfigure::clear_kp() {
  kp_ = 0;
  clear_has_kp();
}
inline float LowSpeedPidConfigure::kp() const {
  // @@protoc_insertion_point(field_get:LC.LowSpeedPidConfigure.kp)
  return kp_;
}
inline void LowSpeedPidConfigure::set_kp(float value) {
  set_has_kp();
  kp_ = value;
  // @@protoc_insertion_point(field_set:LC.LowSpeedPidConfigure.kp)
}

// optional float ki = 4;
inline bool LowSpeedPidConfigure::has_ki() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LowSpeedPidConfigure::set_has_ki() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LowSpeedPidConfigure::clear_has_ki() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LowSpeedPidConfigure::clear_ki() {
  ki_ = 0;
  clear_has_ki();
}
inline float LowSpeedPidConfigure::ki() const {
  // @@protoc_insertion_point(field_get:LC.LowSpeedPidConfigure.ki)
  return ki_;
}
inline void LowSpeedPidConfigure::set_ki(float value) {
  set_has_ki();
  ki_ = value;
  // @@protoc_insertion_point(field_set:LC.LowSpeedPidConfigure.ki)
}

// optional float kd = 5;
inline bool LowSpeedPidConfigure::has_kd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LowSpeedPidConfigure::set_has_kd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LowSpeedPidConfigure::clear_has_kd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LowSpeedPidConfigure::clear_kd() {
  kd_ = 0;
  clear_has_kd();
}
inline float LowSpeedPidConfigure::kd() const {
  // @@protoc_insertion_point(field_get:LC.LowSpeedPidConfigure.kd)
  return kd_;
}
inline void LowSpeedPidConfigure::set_kd(float value) {
  set_has_kd();
  kd_ = value;
  // @@protoc_insertion_point(field_set:LC.LowSpeedPidConfigure.kd)
}

// -------------------------------------------------------------------

// HighSpeedPidConfigure

// optional bool integrator_enable = 1;
inline bool HighSpeedPidConfigure::has_integrator_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HighSpeedPidConfigure::set_has_integrator_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HighSpeedPidConfigure::clear_has_integrator_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HighSpeedPidConfigure::clear_integrator_enable() {
  integrator_enable_ = false;
  clear_has_integrator_enable();
}
inline bool HighSpeedPidConfigure::integrator_enable() const {
  // @@protoc_insertion_point(field_get:LC.HighSpeedPidConfigure.integrator_enable)
  return integrator_enable_;
}
inline void HighSpeedPidConfigure::set_integrator_enable(bool value) {
  set_has_integrator_enable();
  integrator_enable_ = value;
  // @@protoc_insertion_point(field_set:LC.HighSpeedPidConfigure.integrator_enable)
}

// optional float integrator_saturation_level = 2;
inline bool HighSpeedPidConfigure::has_integrator_saturation_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HighSpeedPidConfigure::set_has_integrator_saturation_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HighSpeedPidConfigure::clear_has_integrator_saturation_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HighSpeedPidConfigure::clear_integrator_saturation_level() {
  integrator_saturation_level_ = 0;
  clear_has_integrator_saturation_level();
}
inline float HighSpeedPidConfigure::integrator_saturation_level() const {
  // @@protoc_insertion_point(field_get:LC.HighSpeedPidConfigure.integrator_saturation_level)
  return integrator_saturation_level_;
}
inline void HighSpeedPidConfigure::set_integrator_saturation_level(float value) {
  set_has_integrator_saturation_level();
  integrator_saturation_level_ = value;
  // @@protoc_insertion_point(field_set:LC.HighSpeedPidConfigure.integrator_saturation_level)
}

// optional float kp = 3;
inline bool HighSpeedPidConfigure::has_kp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HighSpeedPidConfigure::set_has_kp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HighSpeedPidConfigure::clear_has_kp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HighSpeedPidConfigure::clear_kp() {
  kp_ = 0;
  clear_has_kp();
}
inline float HighSpeedPidConfigure::kp() const {
  // @@protoc_insertion_point(field_get:LC.HighSpeedPidConfigure.kp)
  return kp_;
}
inline void HighSpeedPidConfigure::set_kp(float value) {
  set_has_kp();
  kp_ = value;
  // @@protoc_insertion_point(field_set:LC.HighSpeedPidConfigure.kp)
}

// optional float ki = 4;
inline bool HighSpeedPidConfigure::has_ki() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HighSpeedPidConfigure::set_has_ki() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HighSpeedPidConfigure::clear_has_ki() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HighSpeedPidConfigure::clear_ki() {
  ki_ = 0;
  clear_has_ki();
}
inline float HighSpeedPidConfigure::ki() const {
  // @@protoc_insertion_point(field_get:LC.HighSpeedPidConfigure.ki)
  return ki_;
}
inline void HighSpeedPidConfigure::set_ki(float value) {
  set_has_ki();
  ki_ = value;
  // @@protoc_insertion_point(field_set:LC.HighSpeedPidConfigure.ki)
}

// optional float kd = 5;
inline bool HighSpeedPidConfigure::has_kd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HighSpeedPidConfigure::set_has_kd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HighSpeedPidConfigure::clear_has_kd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HighSpeedPidConfigure::clear_kd() {
  kd_ = 0;
  clear_has_kd();
}
inline float HighSpeedPidConfigure::kd() const {
  // @@protoc_insertion_point(field_get:LC.HighSpeedPidConfigure.kd)
  return kd_;
}
inline void HighSpeedPidConfigure::set_kd(float value) {
  set_has_kd();
  kd_ = value;
  // @@protoc_insertion_point(field_set:LC.HighSpeedPidConfigure.kd)
}

// -------------------------------------------------------------------

// StationPidConfigure

// optional bool integrator_enable = 1;
inline bool StationPidConfigure::has_integrator_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StationPidConfigure::set_has_integrator_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StationPidConfigure::clear_has_integrator_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StationPidConfigure::clear_integrator_enable() {
  integrator_enable_ = false;
  clear_has_integrator_enable();
}
inline bool StationPidConfigure::integrator_enable() const {
  // @@protoc_insertion_point(field_get:LC.StationPidConfigure.integrator_enable)
  return integrator_enable_;
}
inline void StationPidConfigure::set_integrator_enable(bool value) {
  set_has_integrator_enable();
  integrator_enable_ = value;
  // @@protoc_insertion_point(field_set:LC.StationPidConfigure.integrator_enable)
}

// optional float integrator_saturation_level = 2;
inline bool StationPidConfigure::has_integrator_saturation_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StationPidConfigure::set_has_integrator_saturation_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StationPidConfigure::clear_has_integrator_saturation_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StationPidConfigure::clear_integrator_saturation_level() {
  integrator_saturation_level_ = 0;
  clear_has_integrator_saturation_level();
}
inline float StationPidConfigure::integrator_saturation_level() const {
  // @@protoc_insertion_point(field_get:LC.StationPidConfigure.integrator_saturation_level)
  return integrator_saturation_level_;
}
inline void StationPidConfigure::set_integrator_saturation_level(float value) {
  set_has_integrator_saturation_level();
  integrator_saturation_level_ = value;
  // @@protoc_insertion_point(field_set:LC.StationPidConfigure.integrator_saturation_level)
}

// optional float kp = 3;
inline bool StationPidConfigure::has_kp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StationPidConfigure::set_has_kp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StationPidConfigure::clear_has_kp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StationPidConfigure::clear_kp() {
  kp_ = 0;
  clear_has_kp();
}
inline float StationPidConfigure::kp() const {
  // @@protoc_insertion_point(field_get:LC.StationPidConfigure.kp)
  return kp_;
}
inline void StationPidConfigure::set_kp(float value) {
  set_has_kp();
  kp_ = value;
  // @@protoc_insertion_point(field_set:LC.StationPidConfigure.kp)
}

// optional float ki = 4;
inline bool StationPidConfigure::has_ki() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StationPidConfigure::set_has_ki() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StationPidConfigure::clear_has_ki() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StationPidConfigure::clear_ki() {
  ki_ = 0;
  clear_has_ki();
}
inline float StationPidConfigure::ki() const {
  // @@protoc_insertion_point(field_get:LC.StationPidConfigure.ki)
  return ki_;
}
inline void StationPidConfigure::set_ki(float value) {
  set_has_ki();
  ki_ = value;
  // @@protoc_insertion_point(field_set:LC.StationPidConfigure.ki)
}

// optional float kd = 5;
inline bool StationPidConfigure::has_kd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StationPidConfigure::set_has_kd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StationPidConfigure::clear_has_kd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StationPidConfigure::clear_kd() {
  kd_ = 0;
  clear_has_kd();
}
inline float StationPidConfigure::kd() const {
  // @@protoc_insertion_point(field_get:LC.StationPidConfigure.kd)
  return kd_;
}
inline void StationPidConfigure::set_kd(float value) {
  set_has_kd();
  kd_ = value;
  // @@protoc_insertion_point(field_set:LC.StationPidConfigure.kd)
}

// -------------------------------------------------------------------

// OtherParamConfigure

// optional int32 speed_offset_enable = 1;
inline bool OtherParamConfigure::has_speed_offset_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OtherParamConfigure::set_has_speed_offset_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OtherParamConfigure::clear_has_speed_offset_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OtherParamConfigure::clear_speed_offset_enable() {
  speed_offset_enable_ = 0;
  clear_has_speed_offset_enable();
}
inline ::google::protobuf::int32 OtherParamConfigure::speed_offset_enable() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.speed_offset_enable)
  return speed_offset_enable_;
}
inline void OtherParamConfigure::set_speed_offset_enable(::google::protobuf::int32 value) {
  set_has_speed_offset_enable();
  speed_offset_enable_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.speed_offset_enable)
}

// optional float sample_time = 2;
inline bool OtherParamConfigure::has_sample_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OtherParamConfigure::set_has_sample_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OtherParamConfigure::clear_has_sample_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OtherParamConfigure::clear_sample_time() {
  sample_time_ = 0;
  clear_has_sample_time();
}
inline float OtherParamConfigure::sample_time() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.sample_time)
  return sample_time_;
}
inline void OtherParamConfigure::set_sample_time(float value) {
  set_has_sample_time();
  sample_time_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.sample_time)
}

// optional float static_speed = 3;
inline bool OtherParamConfigure::has_static_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OtherParamConfigure::set_has_static_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OtherParamConfigure::clear_has_static_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OtherParamConfigure::clear_static_speed() {
  static_speed_ = 0;
  clear_has_static_speed();
}
inline float OtherParamConfigure::static_speed() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.static_speed)
  return static_speed_;
}
inline void OtherParamConfigure::set_static_speed(float value) {
  set_has_static_speed();
  static_speed_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.static_speed)
}

// optional float acc_min = 4;
inline bool OtherParamConfigure::has_acc_min() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OtherParamConfigure::set_has_acc_min() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OtherParamConfigure::clear_has_acc_min() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OtherParamConfigure::clear_acc_min() {
  acc_min_ = 0;
  clear_has_acc_min();
}
inline float OtherParamConfigure::acc_min() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.acc_min)
  return acc_min_;
}
inline void OtherParamConfigure::set_acc_min(float value) {
  set_has_acc_min();
  acc_min_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.acc_min)
}

// optional float acc_max = 5;
inline bool OtherParamConfigure::has_acc_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OtherParamConfigure::set_has_acc_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OtherParamConfigure::clear_has_acc_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OtherParamConfigure::clear_acc_max() {
  acc_max_ = 0;
  clear_has_acc_max();
}
inline float OtherParamConfigure::acc_max() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.acc_max)
  return acc_max_;
}
inline void OtherParamConfigure::set_acc_max(float value) {
  set_has_acc_max();
  acc_max_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.acc_max)
}

// optional float high_low_speed_standard = 6;
inline bool OtherParamConfigure::has_high_low_speed_standard() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OtherParamConfigure::set_has_high_low_speed_standard() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OtherParamConfigure::clear_has_high_low_speed_standard() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OtherParamConfigure::clear_high_low_speed_standard() {
  high_low_speed_standard_ = 0;
  clear_has_high_low_speed_standard();
}
inline float OtherParamConfigure::high_low_speed_standard() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.high_low_speed_standard)
  return high_low_speed_standard_;
}
inline void OtherParamConfigure::set_high_low_speed_standard(float value) {
  set_has_high_low_speed_standard();
  high_low_speed_standard_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.high_low_speed_standard)
}

// optional float station_error_limit = 7;
inline bool OtherParamConfigure::has_station_error_limit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OtherParamConfigure::set_has_station_error_limit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OtherParamConfigure::clear_has_station_error_limit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OtherParamConfigure::clear_station_error_limit() {
  station_error_limit_ = 0;
  clear_has_station_error_limit();
}
inline float OtherParamConfigure::station_error_limit() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.station_error_limit)
  return station_error_limit_;
}
inline void OtherParamConfigure::set_station_error_limit(float value) {
  set_has_station_error_limit();
  station_error_limit_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.station_error_limit)
}

// optional float speed_controller_input_limit = 8;
inline bool OtherParamConfigure::has_speed_controller_input_limit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OtherParamConfigure::set_has_speed_controller_input_limit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OtherParamConfigure::clear_has_speed_controller_input_limit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OtherParamConfigure::clear_speed_controller_input_limit() {
  speed_controller_input_limit_ = 0;
  clear_has_speed_controller_input_limit();
}
inline float OtherParamConfigure::speed_controller_input_limit() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.speed_controller_input_limit)
  return speed_controller_input_limit_;
}
inline void OtherParamConfigure::set_speed_controller_input_limit(float value) {
  set_has_speed_controller_input_limit();
  speed_controller_input_limit_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.speed_controller_input_limit)
}

// optional int32 track_point_flag = 9;
inline bool OtherParamConfigure::has_track_point_flag() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OtherParamConfigure::set_has_track_point_flag() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OtherParamConfigure::clear_has_track_point_flag() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OtherParamConfigure::clear_track_point_flag() {
  track_point_flag_ = 0;
  clear_has_track_point_flag();
}
inline ::google::protobuf::int32 OtherParamConfigure::track_point_flag() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.track_point_flag)
  return track_point_flag_;
}
inline void OtherParamConfigure::set_track_point_flag(::google::protobuf::int32 value) {
  set_has_track_point_flag();
  track_point_flag_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.track_point_flag)
}

// optional int32 reference_acc_flag = 10;
inline bool OtherParamConfigure::has_reference_acc_flag() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OtherParamConfigure::set_has_reference_acc_flag() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OtherParamConfigure::clear_has_reference_acc_flag() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OtherParamConfigure::clear_reference_acc_flag() {
  reference_acc_flag_ = 0;
  clear_has_reference_acc_flag();
}
inline ::google::protobuf::int32 OtherParamConfigure::reference_acc_flag() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.reference_acc_flag)
  return reference_acc_flag_;
}
inline void OtherParamConfigure::set_reference_acc_flag(::google::protobuf::int32 value) {
  set_has_reference_acc_flag();
  reference_acc_flag_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.reference_acc_flag)
}

// optional float min_start_acc = 11;
inline bool OtherParamConfigure::has_min_start_acc() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OtherParamConfigure::set_has_min_start_acc() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OtherParamConfigure::clear_has_min_start_acc() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OtherParamConfigure::clear_min_start_acc() {
  min_start_acc_ = 0;
  clear_has_min_start_acc();
}
inline float OtherParamConfigure::min_start_acc() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.min_start_acc)
  return min_start_acc_;
}
inline void OtherParamConfigure::set_min_start_acc(float value) {
  set_has_min_start_acc();
  min_start_acc_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.min_start_acc)
}

// optional int32 next_num = 12;
inline bool OtherParamConfigure::has_next_num() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OtherParamConfigure::set_has_next_num() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OtherParamConfigure::clear_has_next_num() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OtherParamConfigure::clear_next_num() {
  next_num_ = 0;
  clear_has_next_num();
}
inline ::google::protobuf::int32 OtherParamConfigure::next_num() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.next_num)
  return next_num_;
}
inline void OtherParamConfigure::set_next_num(::google::protobuf::int32 value) {
  set_has_next_num();
  next_num_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.next_num)
}

// optional float speed_quicken = 13;
inline bool OtherParamConfigure::has_speed_quicken() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OtherParamConfigure::set_has_speed_quicken() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OtherParamConfigure::clear_has_speed_quicken() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OtherParamConfigure::clear_speed_quicken() {
  speed_quicken_ = 0;
  clear_has_speed_quicken();
}
inline float OtherParamConfigure::speed_quicken() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.speed_quicken)
  return speed_quicken_;
}
inline void OtherParamConfigure::set_speed_quicken(float value) {
  set_has_speed_quicken();
  speed_quicken_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.speed_quicken)
}

// optional float speed_decelerate = 14;
inline bool OtherParamConfigure::has_speed_decelerate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void OtherParamConfigure::set_has_speed_decelerate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void OtherParamConfigure::clear_has_speed_decelerate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void OtherParamConfigure::clear_speed_decelerate() {
  speed_decelerate_ = 0;
  clear_has_speed_decelerate();
}
inline float OtherParamConfigure::speed_decelerate() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.speed_decelerate)
  return speed_decelerate_;
}
inline void OtherParamConfigure::set_speed_decelerate(float value) {
  set_has_speed_decelerate();
  speed_decelerate_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.speed_decelerate)
}

// optional float min_start_dec = 15;
inline bool OtherParamConfigure::has_min_start_dec() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void OtherParamConfigure::set_has_min_start_dec() {
  _has_bits_[0] |= 0x00004000u;
}
inline void OtherParamConfigure::clear_has_min_start_dec() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void OtherParamConfigure::clear_min_start_dec() {
  min_start_dec_ = 0;
  clear_has_min_start_dec();
}
inline float OtherParamConfigure::min_start_dec() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.min_start_dec)
  return min_start_dec_;
}
inline void OtherParamConfigure::set_min_start_dec(float value) {
  set_has_min_start_dec();
  min_start_dec_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.min_start_dec)
}

// optional float delta_acc = 16;
inline bool OtherParamConfigure::has_delta_acc() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void OtherParamConfigure::set_has_delta_acc() {
  _has_bits_[0] |= 0x00008000u;
}
inline void OtherParamConfigure::clear_has_delta_acc() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void OtherParamConfigure::clear_delta_acc() {
  delta_acc_ = 0;
  clear_has_delta_acc();
}
inline float OtherParamConfigure::delta_acc() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.delta_acc)
  return delta_acc_;
}
inline void OtherParamConfigure::set_delta_acc(float value) {
  set_has_delta_acc();
  delta_acc_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.delta_acc)
}

// optional float delta_dec = 17;
inline bool OtherParamConfigure::has_delta_dec() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void OtherParamConfigure::set_has_delta_dec() {
  _has_bits_[0] |= 0x00010000u;
}
inline void OtherParamConfigure::clear_has_delta_dec() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void OtherParamConfigure::clear_delta_dec() {
  delta_dec_ = 0;
  clear_has_delta_dec();
}
inline float OtherParamConfigure::delta_dec() const {
  // @@protoc_insertion_point(field_get:LC.OtherParamConfigure.delta_dec)
  return delta_dec_;
}
inline void OtherParamConfigure::set_delta_dec(float value) {
  set_has_delta_dec();
  delta_dec_ = value;
  // @@protoc_insertion_point(field_set:LC.OtherParamConfigure.delta_dec)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace LC

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_control_2flc_5fconfig_2eproto__INCLUDED
