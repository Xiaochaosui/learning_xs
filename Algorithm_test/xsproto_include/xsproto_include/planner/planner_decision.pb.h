// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planner/planner_decision.proto

#ifndef PROTOBUF_planner_2fplanner_5fdecision_2eproto__INCLUDED
#define PROTOBUF_planner_2fplanner_5fdecision_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_planner_2fplanner_5fdecision_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPlannerPointImpl();
void InitDefaultsPlannerPoint();
void InitDefaultsAvoidObstacleParamImpl();
void InitDefaultsAvoidObstacleParam();
void InitDefaultsPlannerDecisionImpl();
void InitDefaultsPlannerDecision();
inline void InitDefaults() {
  InitDefaultsPlannerPoint();
  InitDefaultsAvoidObstacleParam();
  InitDefaultsPlannerDecision();
}
}  // namespace protobuf_planner_2fplanner_5fdecision_2eproto
namespace planner {
class AvoidObstacleParam;
class AvoidObstacleParamDefaultTypeInternal;
extern AvoidObstacleParamDefaultTypeInternal _AvoidObstacleParam_default_instance_;
class PlannerDecision;
class PlannerDecisionDefaultTypeInternal;
extern PlannerDecisionDefaultTypeInternal _PlannerDecision_default_instance_;
class PlannerPoint;
class PlannerPointDefaultTypeInternal;
extern PlannerPointDefaultTypeInternal _PlannerPoint_default_instance_;
}  // namespace planner
namespace planner {

enum SearchDecisionType {
  SEARCH_DECISION_NORMAL = 0
};
bool SearchDecisionType_IsValid(int value);
const SearchDecisionType SearchDecisionType_MIN = SEARCH_DECISION_NORMAL;
const SearchDecisionType SearchDecisionType_MAX = SEARCH_DECISION_NORMAL;
const int SearchDecisionType_ARRAYSIZE = SearchDecisionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SearchDecisionType_descriptor();
inline const ::std::string& SearchDecisionType_Name(SearchDecisionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SearchDecisionType_descriptor(), value);
}
inline bool SearchDecisionType_Parse(
    const ::std::string& name, SearchDecisionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SearchDecisionType>(
    SearchDecisionType_descriptor(), name, value);
}
enum YieldDecisionType {
  YIELD_DECISION_NORMAL = 0,
  YIELD_DECISION_VEHICLE = 1,
  YIELD_DECISION_PEDESTRIAN = 2
};
bool YieldDecisionType_IsValid(int value);
const YieldDecisionType YieldDecisionType_MIN = YIELD_DECISION_NORMAL;
const YieldDecisionType YieldDecisionType_MAX = YIELD_DECISION_PEDESTRIAN;
const int YieldDecisionType_ARRAYSIZE = YieldDecisionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* YieldDecisionType_descriptor();
inline const ::std::string& YieldDecisionType_Name(YieldDecisionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    YieldDecisionType_descriptor(), value);
}
inline bool YieldDecisionType_Parse(
    const ::std::string& name, YieldDecisionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<YieldDecisionType>(
    YieldDecisionType_descriptor(), name, value);
}
enum PrecisionStage {
  PRECISION_NORMAL = 0,
  PRECISION_ABUTTING = 1
};
bool PrecisionStage_IsValid(int value);
const PrecisionStage PrecisionStage_MIN = PRECISION_NORMAL;
const PrecisionStage PrecisionStage_MAX = PRECISION_ABUTTING;
const int PrecisionStage_ARRAYSIZE = PrecisionStage_MAX + 1;

const ::google::protobuf::EnumDescriptor* PrecisionStage_descriptor();
inline const ::std::string& PrecisionStage_Name(PrecisionStage value) {
  return ::google::protobuf::internal::NameOfEnum(
    PrecisionStage_descriptor(), value);
}
inline bool PrecisionStage_Parse(
    const ::std::string& name, PrecisionStage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrecisionStage>(
    PrecisionStage_descriptor(), name, value);
}
// ===================================================================

class PlannerPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planner.PlannerPoint) */ {
 public:
  PlannerPoint();
  virtual ~PlannerPoint();

  PlannerPoint(const PlannerPoint& from);

  inline PlannerPoint& operator=(const PlannerPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlannerPoint(PlannerPoint&& from) noexcept
    : PlannerPoint() {
    *this = ::std::move(from);
  }

  inline PlannerPoint& operator=(PlannerPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlannerPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlannerPoint* internal_default_instance() {
    return reinterpret_cast<const PlannerPoint*>(
               &_PlannerPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PlannerPoint* other);
  friend void swap(PlannerPoint& a, PlannerPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlannerPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  PlannerPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlannerPoint& from);
  void MergeFrom(const PlannerPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlannerPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double hd = 3;
  bool has_hd() const;
  void clear_hd();
  static const int kHdFieldNumber = 3;
  double hd() const;
  void set_hd(double value);

  // @@protoc_insertion_point(class_scope:planner.PlannerPoint)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_hd();
  void clear_has_hd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  double hd_;
  friend struct ::protobuf_planner_2fplanner_5fdecision_2eproto::TableStruct;
  friend void ::protobuf_planner_2fplanner_5fdecision_2eproto::InitDefaultsPlannerPointImpl();
};
// -------------------------------------------------------------------

class AvoidObstacleParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planner.AvoidObstacleParam) */ {
 public:
  AvoidObstacleParam();
  virtual ~AvoidObstacleParam();

  AvoidObstacleParam(const AvoidObstacleParam& from);

  inline AvoidObstacleParam& operator=(const AvoidObstacleParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AvoidObstacleParam(AvoidObstacleParam&& from) noexcept
    : AvoidObstacleParam() {
    *this = ::std::move(from);
  }

  inline AvoidObstacleParam& operator=(AvoidObstacleParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AvoidObstacleParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AvoidObstacleParam* internal_default_instance() {
    return reinterpret_cast<const AvoidObstacleParam*>(
               &_AvoidObstacleParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AvoidObstacleParam* other);
  friend void swap(AvoidObstacleParam& a, AvoidObstacleParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AvoidObstacleParam* New() const PROTOBUF_FINAL { return New(NULL); }

  AvoidObstacleParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AvoidObstacleParam& from);
  void MergeFrom(const AvoidObstacleParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AvoidObstacleParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double distance_a = 1;
  bool has_distance_a() const;
  void clear_distance_a();
  static const int kDistanceAFieldNumber = 1;
  double distance_a() const;
  void set_distance_a(double value);

  // optional double distance_b = 2;
  bool has_distance_b() const;
  void clear_distance_b();
  static const int kDistanceBFieldNumber = 2;
  double distance_b() const;
  void set_distance_b(double value);

  // optional int32 time_a = 3;
  bool has_time_a() const;
  void clear_time_a();
  static const int kTimeAFieldNumber = 3;
  ::google::protobuf::int32 time_a() const;
  void set_time_a(::google::protobuf::int32 value);

  // optional int32 time_b = 4;
  bool has_time_b() const;
  void clear_time_b();
  static const int kTimeBFieldNumber = 4;
  ::google::protobuf::int32 time_b() const;
  void set_time_b(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:planner.AvoidObstacleParam)
 private:
  void set_has_distance_a();
  void clear_has_distance_a();
  void set_has_distance_b();
  void clear_has_distance_b();
  void set_has_time_a();
  void clear_has_time_a();
  void set_has_time_b();
  void clear_has_time_b();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double distance_a_;
  double distance_b_;
  ::google::protobuf::int32 time_a_;
  ::google::protobuf::int32 time_b_;
  friend struct ::protobuf_planner_2fplanner_5fdecision_2eproto::TableStruct;
  friend void ::protobuf_planner_2fplanner_5fdecision_2eproto::InitDefaultsAvoidObstacleParamImpl();
};
// -------------------------------------------------------------------

class PlannerDecision : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:planner.PlannerDecision) */ {
 public:
  PlannerDecision();
  virtual ~PlannerDecision();

  PlannerDecision(const PlannerDecision& from);

  inline PlannerDecision& operator=(const PlannerDecision& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlannerDecision(PlannerDecision&& from) noexcept
    : PlannerDecision() {
    *this = ::std::move(from);
  }

  inline PlannerDecision& operator=(PlannerDecision&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlannerDecision& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlannerDecision* internal_default_instance() {
    return reinterpret_cast<const PlannerDecision*>(
               &_PlannerDecision_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(PlannerDecision* other);
  friend void swap(PlannerDecision& a, PlannerDecision& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlannerDecision* New() const PROTOBUF_FINAL { return New(NULL); }

  PlannerDecision* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlannerDecision& from);
  void MergeFrom(const PlannerDecision& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlannerDecision* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .planner.PlannerPoint precision_point = 9;
  bool has_precision_point() const;
  void clear_precision_point();
  static const int kPrecisionPointFieldNumber = 9;
  const ::planner::PlannerPoint& precision_point() const;
  ::planner::PlannerPoint* release_precision_point();
  ::planner::PlannerPoint* mutable_precision_point();
  void set_allocated_precision_point(::planner::PlannerPoint* precision_point);

  // optional .planner.PlannerPoint segment_endpoint = 11;
  bool has_segment_endpoint() const;
  void clear_segment_endpoint();
  static const int kSegmentEndpointFieldNumber = 11;
  const ::planner::PlannerPoint& segment_endpoint() const;
  ::planner::PlannerPoint* release_segment_endpoint();
  ::planner::PlannerPoint* mutable_segment_endpoint();
  void set_allocated_segment_endpoint(::planner::PlannerPoint* segment_endpoint);

  // optional .planner.AvoidObstacleParam avoid_obstacle_param = 12;
  bool has_avoid_obstacle_param() const;
  void clear_avoid_obstacle_param();
  static const int kAvoidObstacleParamFieldNumber = 12;
  const ::planner::AvoidObstacleParam& avoid_obstacle_param() const;
  ::planner::AvoidObstacleParam* release_avoid_obstacle_param();
  ::planner::AvoidObstacleParam* mutable_avoid_obstacle_param();
  void set_allocated_avoid_obstacle_param(::planner::AvoidObstacleParam* avoid_obstacle_param);

  // optional double decision_time = 1;
  bool has_decision_time() const;
  void clear_decision_time();
  static const int kDecisionTimeFieldNumber = 1;
  double decision_time() const;
  void set_decision_time(double value);

  // optional .planner.SearchDecisionType current_search_type = 2;
  bool has_current_search_type() const;
  void clear_current_search_type();
  static const int kCurrentSearchTypeFieldNumber = 2;
  ::planner::SearchDecisionType current_search_type() const;
  void set_current_search_type(::planner::SearchDecisionType value);

  // optional .planner.SearchDecisionType history_search_type = 3;
  bool has_history_search_type() const;
  void clear_history_search_type();
  static const int kHistorySearchTypeFieldNumber = 3;
  ::planner::SearchDecisionType history_search_type() const;
  void set_history_search_type(::planner::SearchDecisionType value);

  // optional double yield_time = 4;
  bool has_yield_time() const;
  void clear_yield_time();
  static const int kYieldTimeFieldNumber = 4;
  double yield_time() const;
  void set_yield_time(double value);

  // optional .planner.YieldDecisionType current_yield_type = 5;
  bool has_current_yield_type() const;
  void clear_current_yield_type();
  static const int kCurrentYieldTypeFieldNumber = 5;
  ::planner::YieldDecisionType current_yield_type() const;
  void set_current_yield_type(::planner::YieldDecisionType value);

  // optional .planner.YieldDecisionType history_yield_type = 6;
  bool has_history_yield_type() const;
  void clear_history_yield_type();
  static const int kHistoryYieldTypeFieldNumber = 6;
  ::planner::YieldDecisionType history_yield_type() const;
  void set_history_yield_type(::planner::YieldDecisionType value);

  // optional double yield_stop_x = 7;
  bool has_yield_stop_x() const;
  void clear_yield_stop_x();
  static const int kYieldStopXFieldNumber = 7;
  double yield_stop_x() const;
  void set_yield_stop_x(double value);

  // optional double yield_stop_y = 8;
  bool has_yield_stop_y() const;
  void clear_yield_stop_y();
  static const int kYieldStopYFieldNumber = 8;
  double yield_stop_y() const;
  void set_yield_stop_y(double value);

  // optional .planner.PrecisionStage precision_stage = 10;
  bool has_precision_stage() const;
  void clear_precision_stage();
  static const int kPrecisionStageFieldNumber = 10;
  ::planner::PrecisionStage precision_stage() const;
  void set_precision_stage(::planner::PrecisionStage value);

  // @@protoc_insertion_point(class_scope:planner.PlannerDecision)
 private:
  void set_has_decision_time();
  void clear_has_decision_time();
  void set_has_current_search_type();
  void clear_has_current_search_type();
  void set_has_history_search_type();
  void clear_has_history_search_type();
  void set_has_yield_time();
  void clear_has_yield_time();
  void set_has_current_yield_type();
  void clear_has_current_yield_type();
  void set_has_history_yield_type();
  void clear_has_history_yield_type();
  void set_has_yield_stop_x();
  void clear_has_yield_stop_x();
  void set_has_yield_stop_y();
  void clear_has_yield_stop_y();
  void set_has_precision_point();
  void clear_has_precision_point();
  void set_has_precision_stage();
  void clear_has_precision_stage();
  void set_has_segment_endpoint();
  void clear_has_segment_endpoint();
  void set_has_avoid_obstacle_param();
  void clear_has_avoid_obstacle_param();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::planner::PlannerPoint* precision_point_;
  ::planner::PlannerPoint* segment_endpoint_;
  ::planner::AvoidObstacleParam* avoid_obstacle_param_;
  double decision_time_;
  int current_search_type_;
  int history_search_type_;
  double yield_time_;
  int current_yield_type_;
  int history_yield_type_;
  double yield_stop_x_;
  double yield_stop_y_;
  int precision_stage_;
  friend struct ::protobuf_planner_2fplanner_5fdecision_2eproto::TableStruct;
  friend void ::protobuf_planner_2fplanner_5fdecision_2eproto::InitDefaultsPlannerDecisionImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlannerPoint

// optional double x = 1;
inline bool PlannerPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlannerPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlannerPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlannerPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double PlannerPoint::x() const {
  // @@protoc_insertion_point(field_get:planner.PlannerPoint.x)
  return x_;
}
inline void PlannerPoint::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:planner.PlannerPoint.x)
}

// optional double y = 2;
inline bool PlannerPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlannerPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlannerPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlannerPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double PlannerPoint::y() const {
  // @@protoc_insertion_point(field_get:planner.PlannerPoint.y)
  return y_;
}
inline void PlannerPoint::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:planner.PlannerPoint.y)
}

// optional double hd = 3;
inline bool PlannerPoint::has_hd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlannerPoint::set_has_hd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlannerPoint::clear_has_hd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlannerPoint::clear_hd() {
  hd_ = 0;
  clear_has_hd();
}
inline double PlannerPoint::hd() const {
  // @@protoc_insertion_point(field_get:planner.PlannerPoint.hd)
  return hd_;
}
inline void PlannerPoint::set_hd(double value) {
  set_has_hd();
  hd_ = value;
  // @@protoc_insertion_point(field_set:planner.PlannerPoint.hd)
}

// -------------------------------------------------------------------

// AvoidObstacleParam

// optional double distance_a = 1;
inline bool AvoidObstacleParam::has_distance_a() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvoidObstacleParam::set_has_distance_a() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvoidObstacleParam::clear_has_distance_a() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvoidObstacleParam::clear_distance_a() {
  distance_a_ = 0;
  clear_has_distance_a();
}
inline double AvoidObstacleParam::distance_a() const {
  // @@protoc_insertion_point(field_get:planner.AvoidObstacleParam.distance_a)
  return distance_a_;
}
inline void AvoidObstacleParam::set_distance_a(double value) {
  set_has_distance_a();
  distance_a_ = value;
  // @@protoc_insertion_point(field_set:planner.AvoidObstacleParam.distance_a)
}

// optional double distance_b = 2;
inline bool AvoidObstacleParam::has_distance_b() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AvoidObstacleParam::set_has_distance_b() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AvoidObstacleParam::clear_has_distance_b() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AvoidObstacleParam::clear_distance_b() {
  distance_b_ = 0;
  clear_has_distance_b();
}
inline double AvoidObstacleParam::distance_b() const {
  // @@protoc_insertion_point(field_get:planner.AvoidObstacleParam.distance_b)
  return distance_b_;
}
inline void AvoidObstacleParam::set_distance_b(double value) {
  set_has_distance_b();
  distance_b_ = value;
  // @@protoc_insertion_point(field_set:planner.AvoidObstacleParam.distance_b)
}

// optional int32 time_a = 3;
inline bool AvoidObstacleParam::has_time_a() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AvoidObstacleParam::set_has_time_a() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AvoidObstacleParam::clear_has_time_a() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AvoidObstacleParam::clear_time_a() {
  time_a_ = 0;
  clear_has_time_a();
}
inline ::google::protobuf::int32 AvoidObstacleParam::time_a() const {
  // @@protoc_insertion_point(field_get:planner.AvoidObstacleParam.time_a)
  return time_a_;
}
inline void AvoidObstacleParam::set_time_a(::google::protobuf::int32 value) {
  set_has_time_a();
  time_a_ = value;
  // @@protoc_insertion_point(field_set:planner.AvoidObstacleParam.time_a)
}

// optional int32 time_b = 4;
inline bool AvoidObstacleParam::has_time_b() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AvoidObstacleParam::set_has_time_b() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AvoidObstacleParam::clear_has_time_b() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AvoidObstacleParam::clear_time_b() {
  time_b_ = 0;
  clear_has_time_b();
}
inline ::google::protobuf::int32 AvoidObstacleParam::time_b() const {
  // @@protoc_insertion_point(field_get:planner.AvoidObstacleParam.time_b)
  return time_b_;
}
inline void AvoidObstacleParam::set_time_b(::google::protobuf::int32 value) {
  set_has_time_b();
  time_b_ = value;
  // @@protoc_insertion_point(field_set:planner.AvoidObstacleParam.time_b)
}

// -------------------------------------------------------------------

// PlannerDecision

// optional double decision_time = 1;
inline bool PlannerDecision::has_decision_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlannerDecision::set_has_decision_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlannerDecision::clear_has_decision_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlannerDecision::clear_decision_time() {
  decision_time_ = 0;
  clear_has_decision_time();
}
inline double PlannerDecision::decision_time() const {
  // @@protoc_insertion_point(field_get:planner.PlannerDecision.decision_time)
  return decision_time_;
}
inline void PlannerDecision::set_decision_time(double value) {
  set_has_decision_time();
  decision_time_ = value;
  // @@protoc_insertion_point(field_set:planner.PlannerDecision.decision_time)
}

// optional .planner.SearchDecisionType current_search_type = 2;
inline bool PlannerDecision::has_current_search_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlannerDecision::set_has_current_search_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlannerDecision::clear_has_current_search_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlannerDecision::clear_current_search_type() {
  current_search_type_ = 0;
  clear_has_current_search_type();
}
inline ::planner::SearchDecisionType PlannerDecision::current_search_type() const {
  // @@protoc_insertion_point(field_get:planner.PlannerDecision.current_search_type)
  return static_cast< ::planner::SearchDecisionType >(current_search_type_);
}
inline void PlannerDecision::set_current_search_type(::planner::SearchDecisionType value) {
  assert(::planner::SearchDecisionType_IsValid(value));
  set_has_current_search_type();
  current_search_type_ = value;
  // @@protoc_insertion_point(field_set:planner.PlannerDecision.current_search_type)
}

// optional .planner.SearchDecisionType history_search_type = 3;
inline bool PlannerDecision::has_history_search_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlannerDecision::set_has_history_search_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlannerDecision::clear_has_history_search_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlannerDecision::clear_history_search_type() {
  history_search_type_ = 0;
  clear_has_history_search_type();
}
inline ::planner::SearchDecisionType PlannerDecision::history_search_type() const {
  // @@protoc_insertion_point(field_get:planner.PlannerDecision.history_search_type)
  return static_cast< ::planner::SearchDecisionType >(history_search_type_);
}
inline void PlannerDecision::set_history_search_type(::planner::SearchDecisionType value) {
  assert(::planner::SearchDecisionType_IsValid(value));
  set_has_history_search_type();
  history_search_type_ = value;
  // @@protoc_insertion_point(field_set:planner.PlannerDecision.history_search_type)
}

// optional double yield_time = 4;
inline bool PlannerDecision::has_yield_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlannerDecision::set_has_yield_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlannerDecision::clear_has_yield_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlannerDecision::clear_yield_time() {
  yield_time_ = 0;
  clear_has_yield_time();
}
inline double PlannerDecision::yield_time() const {
  // @@protoc_insertion_point(field_get:planner.PlannerDecision.yield_time)
  return yield_time_;
}
inline void PlannerDecision::set_yield_time(double value) {
  set_has_yield_time();
  yield_time_ = value;
  // @@protoc_insertion_point(field_set:planner.PlannerDecision.yield_time)
}

// optional .planner.YieldDecisionType current_yield_type = 5;
inline bool PlannerDecision::has_current_yield_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlannerDecision::set_has_current_yield_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlannerDecision::clear_has_current_yield_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlannerDecision::clear_current_yield_type() {
  current_yield_type_ = 0;
  clear_has_current_yield_type();
}
inline ::planner::YieldDecisionType PlannerDecision::current_yield_type() const {
  // @@protoc_insertion_point(field_get:planner.PlannerDecision.current_yield_type)
  return static_cast< ::planner::YieldDecisionType >(current_yield_type_);
}
inline void PlannerDecision::set_current_yield_type(::planner::YieldDecisionType value) {
  assert(::planner::YieldDecisionType_IsValid(value));
  set_has_current_yield_type();
  current_yield_type_ = value;
  // @@protoc_insertion_point(field_set:planner.PlannerDecision.current_yield_type)
}

// optional .planner.YieldDecisionType history_yield_type = 6;
inline bool PlannerDecision::has_history_yield_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlannerDecision::set_has_history_yield_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlannerDecision::clear_has_history_yield_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlannerDecision::clear_history_yield_type() {
  history_yield_type_ = 0;
  clear_has_history_yield_type();
}
inline ::planner::YieldDecisionType PlannerDecision::history_yield_type() const {
  // @@protoc_insertion_point(field_get:planner.PlannerDecision.history_yield_type)
  return static_cast< ::planner::YieldDecisionType >(history_yield_type_);
}
inline void PlannerDecision::set_history_yield_type(::planner::YieldDecisionType value) {
  assert(::planner::YieldDecisionType_IsValid(value));
  set_has_history_yield_type();
  history_yield_type_ = value;
  // @@protoc_insertion_point(field_set:planner.PlannerDecision.history_yield_type)
}

// optional double yield_stop_x = 7;
inline bool PlannerDecision::has_yield_stop_x() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlannerDecision::set_has_yield_stop_x() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlannerDecision::clear_has_yield_stop_x() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlannerDecision::clear_yield_stop_x() {
  yield_stop_x_ = 0;
  clear_has_yield_stop_x();
}
inline double PlannerDecision::yield_stop_x() const {
  // @@protoc_insertion_point(field_get:planner.PlannerDecision.yield_stop_x)
  return yield_stop_x_;
}
inline void PlannerDecision::set_yield_stop_x(double value) {
  set_has_yield_stop_x();
  yield_stop_x_ = value;
  // @@protoc_insertion_point(field_set:planner.PlannerDecision.yield_stop_x)
}

// optional double yield_stop_y = 8;
inline bool PlannerDecision::has_yield_stop_y() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlannerDecision::set_has_yield_stop_y() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlannerDecision::clear_has_yield_stop_y() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlannerDecision::clear_yield_stop_y() {
  yield_stop_y_ = 0;
  clear_has_yield_stop_y();
}
inline double PlannerDecision::yield_stop_y() const {
  // @@protoc_insertion_point(field_get:planner.PlannerDecision.yield_stop_y)
  return yield_stop_y_;
}
inline void PlannerDecision::set_yield_stop_y(double value) {
  set_has_yield_stop_y();
  yield_stop_y_ = value;
  // @@protoc_insertion_point(field_set:planner.PlannerDecision.yield_stop_y)
}

// optional .planner.PlannerPoint precision_point = 9;
inline bool PlannerDecision::has_precision_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlannerDecision::set_has_precision_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlannerDecision::clear_has_precision_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlannerDecision::clear_precision_point() {
  if (precision_point_ != NULL) precision_point_->Clear();
  clear_has_precision_point();
}
inline const ::planner::PlannerPoint& PlannerDecision::precision_point() const {
  const ::planner::PlannerPoint* p = precision_point_;
  // @@protoc_insertion_point(field_get:planner.PlannerDecision.precision_point)
  return p != NULL ? *p : *reinterpret_cast<const ::planner::PlannerPoint*>(
      &::planner::_PlannerPoint_default_instance_);
}
inline ::planner::PlannerPoint* PlannerDecision::release_precision_point() {
  // @@protoc_insertion_point(field_release:planner.PlannerDecision.precision_point)
  clear_has_precision_point();
  ::planner::PlannerPoint* temp = precision_point_;
  precision_point_ = NULL;
  return temp;
}
inline ::planner::PlannerPoint* PlannerDecision::mutable_precision_point() {
  set_has_precision_point();
  if (precision_point_ == NULL) {
    precision_point_ = new ::planner::PlannerPoint;
  }
  // @@protoc_insertion_point(field_mutable:planner.PlannerDecision.precision_point)
  return precision_point_;
}
inline void PlannerDecision::set_allocated_precision_point(::planner::PlannerPoint* precision_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete precision_point_;
  }
  if (precision_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      precision_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, precision_point, submessage_arena);
    }
    set_has_precision_point();
  } else {
    clear_has_precision_point();
  }
  precision_point_ = precision_point;
  // @@protoc_insertion_point(field_set_allocated:planner.PlannerDecision.precision_point)
}

// optional .planner.PrecisionStage precision_stage = 10;
inline bool PlannerDecision::has_precision_stage() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PlannerDecision::set_has_precision_stage() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PlannerDecision::clear_has_precision_stage() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PlannerDecision::clear_precision_stage() {
  precision_stage_ = 0;
  clear_has_precision_stage();
}
inline ::planner::PrecisionStage PlannerDecision::precision_stage() const {
  // @@protoc_insertion_point(field_get:planner.PlannerDecision.precision_stage)
  return static_cast< ::planner::PrecisionStage >(precision_stage_);
}
inline void PlannerDecision::set_precision_stage(::planner::PrecisionStage value) {
  assert(::planner::PrecisionStage_IsValid(value));
  set_has_precision_stage();
  precision_stage_ = value;
  // @@protoc_insertion_point(field_set:planner.PlannerDecision.precision_stage)
}

// optional .planner.PlannerPoint segment_endpoint = 11;
inline bool PlannerDecision::has_segment_endpoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlannerDecision::set_has_segment_endpoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlannerDecision::clear_has_segment_endpoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlannerDecision::clear_segment_endpoint() {
  if (segment_endpoint_ != NULL) segment_endpoint_->Clear();
  clear_has_segment_endpoint();
}
inline const ::planner::PlannerPoint& PlannerDecision::segment_endpoint() const {
  const ::planner::PlannerPoint* p = segment_endpoint_;
  // @@protoc_insertion_point(field_get:planner.PlannerDecision.segment_endpoint)
  return p != NULL ? *p : *reinterpret_cast<const ::planner::PlannerPoint*>(
      &::planner::_PlannerPoint_default_instance_);
}
inline ::planner::PlannerPoint* PlannerDecision::release_segment_endpoint() {
  // @@protoc_insertion_point(field_release:planner.PlannerDecision.segment_endpoint)
  clear_has_segment_endpoint();
  ::planner::PlannerPoint* temp = segment_endpoint_;
  segment_endpoint_ = NULL;
  return temp;
}
inline ::planner::PlannerPoint* PlannerDecision::mutable_segment_endpoint() {
  set_has_segment_endpoint();
  if (segment_endpoint_ == NULL) {
    segment_endpoint_ = new ::planner::PlannerPoint;
  }
  // @@protoc_insertion_point(field_mutable:planner.PlannerDecision.segment_endpoint)
  return segment_endpoint_;
}
inline void PlannerDecision::set_allocated_segment_endpoint(::planner::PlannerPoint* segment_endpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete segment_endpoint_;
  }
  if (segment_endpoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      segment_endpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, segment_endpoint, submessage_arena);
    }
    set_has_segment_endpoint();
  } else {
    clear_has_segment_endpoint();
  }
  segment_endpoint_ = segment_endpoint;
  // @@protoc_insertion_point(field_set_allocated:planner.PlannerDecision.segment_endpoint)
}

// optional .planner.AvoidObstacleParam avoid_obstacle_param = 12;
inline bool PlannerDecision::has_avoid_obstacle_param() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlannerDecision::set_has_avoid_obstacle_param() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlannerDecision::clear_has_avoid_obstacle_param() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlannerDecision::clear_avoid_obstacle_param() {
  if (avoid_obstacle_param_ != NULL) avoid_obstacle_param_->Clear();
  clear_has_avoid_obstacle_param();
}
inline const ::planner::AvoidObstacleParam& PlannerDecision::avoid_obstacle_param() const {
  const ::planner::AvoidObstacleParam* p = avoid_obstacle_param_;
  // @@protoc_insertion_point(field_get:planner.PlannerDecision.avoid_obstacle_param)
  return p != NULL ? *p : *reinterpret_cast<const ::planner::AvoidObstacleParam*>(
      &::planner::_AvoidObstacleParam_default_instance_);
}
inline ::planner::AvoidObstacleParam* PlannerDecision::release_avoid_obstacle_param() {
  // @@protoc_insertion_point(field_release:planner.PlannerDecision.avoid_obstacle_param)
  clear_has_avoid_obstacle_param();
  ::planner::AvoidObstacleParam* temp = avoid_obstacle_param_;
  avoid_obstacle_param_ = NULL;
  return temp;
}
inline ::planner::AvoidObstacleParam* PlannerDecision::mutable_avoid_obstacle_param() {
  set_has_avoid_obstacle_param();
  if (avoid_obstacle_param_ == NULL) {
    avoid_obstacle_param_ = new ::planner::AvoidObstacleParam;
  }
  // @@protoc_insertion_point(field_mutable:planner.PlannerDecision.avoid_obstacle_param)
  return avoid_obstacle_param_;
}
inline void PlannerDecision::set_allocated_avoid_obstacle_param(::planner::AvoidObstacleParam* avoid_obstacle_param) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete avoid_obstacle_param_;
  }
  if (avoid_obstacle_param) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      avoid_obstacle_param = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, avoid_obstacle_param, submessage_arena);
    }
    set_has_avoid_obstacle_param();
  } else {
    clear_has_avoid_obstacle_param();
  }
  avoid_obstacle_param_ = avoid_obstacle_param;
  // @@protoc_insertion_point(field_set_allocated:planner.PlannerDecision.avoid_obstacle_param)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planner

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::planner::SearchDecisionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::planner::SearchDecisionType>() {
  return ::planner::SearchDecisionType_descriptor();
}
template <> struct is_proto_enum< ::planner::YieldDecisionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::planner::YieldDecisionType>() {
  return ::planner::YieldDecisionType_descriptor();
}
template <> struct is_proto_enum< ::planner::PrecisionStage> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::planner::PrecisionStage>() {
  return ::planner::PrecisionStage_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_planner_2fplanner_5fdecision_2eproto__INCLUDED
