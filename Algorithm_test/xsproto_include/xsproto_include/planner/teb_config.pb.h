// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planner/teb_config.proto

#ifndef PROTOBUF_planner_2fteb_5fconfig_2eproto__INCLUDED
#define PROTOBUF_planner_2fteb_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_planner_2fteb_5fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsTrajectoryImpl();
void InitDefaultsTrajectory();
void InitDefaultsRobotImpl();
void InitDefaultsRobot();
void InitDefaultsGoalToleranceImpl();
void InitDefaultsGoalTolerance();
void InitDefaultsObstaclesImpl();
void InitDefaultsObstacles();
void InitDefaultsOptimizationImpl();
void InitDefaultsOptimization();
void InitDefaultsTebConfigImpl();
void InitDefaultsTebConfig();
inline void InitDefaults() {
  InitDefaultsTrajectory();
  InitDefaultsRobot();
  InitDefaultsGoalTolerance();
  InitDefaultsObstacles();
  InitDefaultsOptimization();
  InitDefaultsTebConfig();
}
}  // namespace protobuf_planner_2fteb_5fconfig_2eproto
namespace teb {
class GoalTolerance;
class GoalToleranceDefaultTypeInternal;
extern GoalToleranceDefaultTypeInternal _GoalTolerance_default_instance_;
class Obstacles;
class ObstaclesDefaultTypeInternal;
extern ObstaclesDefaultTypeInternal _Obstacles_default_instance_;
class Optimization;
class OptimizationDefaultTypeInternal;
extern OptimizationDefaultTypeInternal _Optimization_default_instance_;
class Robot;
class RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class TebConfig;
class TebConfigDefaultTypeInternal;
extern TebConfigDefaultTypeInternal _TebConfig_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
}  // namespace teb
namespace teb {

// ===================================================================

class Trajectory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:teb.Trajectory) */ {
 public:
  Trajectory();
  virtual ~Trajectory();

  Trajectory(const Trajectory& from);

  inline Trajectory& operator=(const Trajectory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trajectory(Trajectory&& from) noexcept
    : Trajectory() {
    *this = ::std::move(from);
  }

  inline Trajectory& operator=(Trajectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Trajectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trajectory* internal_default_instance() {
    return reinterpret_cast<const Trajectory*>(
               &_Trajectory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Trajectory* other);
  friend void swap(Trajectory& a, Trajectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trajectory* New() const PROTOBUF_FINAL { return New(NULL); }

  Trajectory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Trajectory& from);
  void MergeFrom(const Trajectory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Trajectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double autosize = 1;
  bool has_autosize() const;
  void clear_autosize();
  static const int kAutosizeFieldNumber = 1;
  double autosize() const;
  void set_autosize(double value);

  // optional double dt_ref = 2;
  bool has_dt_ref() const;
  void clear_dt_ref();
  static const int kDtRefFieldNumber = 2;
  double dt_ref() const;
  void set_dt_ref(double value);

  // optional double dt_hysteresis = 3;
  bool has_dt_hysteresis() const;
  void clear_dt_hysteresis();
  static const int kDtHysteresisFieldNumber = 3;
  double dt_hysteresis() const;
  void set_dt_hysteresis(double value);

  // optional int32 min_samples = 4;
  bool has_min_samples() const;
  void clear_min_samples();
  static const int kMinSamplesFieldNumber = 4;
  ::google::protobuf::int32 min_samples() const;
  void set_min_samples(::google::protobuf::int32 value);

  // optional int32 max_samples = 5;
  bool has_max_samples() const;
  void clear_max_samples();
  static const int kMaxSamplesFieldNumber = 5;
  ::google::protobuf::int32 max_samples() const;
  void set_max_samples(::google::protobuf::int32 value);

  // optional double global_plan_viapoint_sep = 8;
  bool has_global_plan_viapoint_sep() const;
  void clear_global_plan_viapoint_sep();
  static const int kGlobalPlanViapointSepFieldNumber = 8;
  double global_plan_viapoint_sep() const;
  void set_global_plan_viapoint_sep(double value);

  // optional bool global_plan_overwrite_orientation = 6;
  bool has_global_plan_overwrite_orientation() const;
  void clear_global_plan_overwrite_orientation();
  static const int kGlobalPlanOverwriteOrientationFieldNumber = 6;
  bool global_plan_overwrite_orientation() const;
  void set_global_plan_overwrite_orientation(bool value);

  // optional bool allow_init_with_backwards_motion = 7;
  bool has_allow_init_with_backwards_motion() const;
  void clear_allow_init_with_backwards_motion();
  static const int kAllowInitWithBackwardsMotionFieldNumber = 7;
  bool allow_init_with_backwards_motion() const;
  void set_allow_init_with_backwards_motion(bool value);

  // optional bool via_points_ordered = 9;
  bool has_via_points_ordered() const;
  void clear_via_points_ordered();
  static const int kViaPointsOrderedFieldNumber = 9;
  bool via_points_ordered() const;
  void set_via_points_ordered(bool value);

  // optional bool exact_arc_length = 12;
  bool has_exact_arc_length() const;
  void clear_exact_arc_length();
  static const int kExactArcLengthFieldNumber = 12;
  bool exact_arc_length() const;
  void set_exact_arc_length(bool value);

  // optional int32 feasibility_check_no_poses = 15;
  bool has_feasibility_check_no_poses() const;
  void clear_feasibility_check_no_poses();
  static const int kFeasibilityCheckNoPosesFieldNumber = 15;
  ::google::protobuf::int32 feasibility_check_no_poses() const;
  void set_feasibility_check_no_poses(::google::protobuf::int32 value);

  // optional double max_global_plan_lookahead_dist = 10;
  bool has_max_global_plan_lookahead_dist() const;
  void clear_max_global_plan_lookahead_dist();
  static const int kMaxGlobalPlanLookaheadDistFieldNumber = 10;
  double max_global_plan_lookahead_dist() const;
  void set_max_global_plan_lookahead_dist(double value);

  // optional double global_plan_prune_distance = 11;
  bool has_global_plan_prune_distance() const;
  void clear_global_plan_prune_distance();
  static const int kGlobalPlanPruneDistanceFieldNumber = 11;
  double global_plan_prune_distance() const;
  void set_global_plan_prune_distance(double value);

  // optional double force_reinit_new_goal_dist = 13;
  bool has_force_reinit_new_goal_dist() const;
  void clear_force_reinit_new_goal_dist();
  static const int kForceReinitNewGoalDistFieldNumber = 13;
  double force_reinit_new_goal_dist() const;
  void set_force_reinit_new_goal_dist(double value);

  // optional double force_reinit_new_goal_angular = 14;
  bool has_force_reinit_new_goal_angular() const;
  void clear_force_reinit_new_goal_angular();
  static const int kForceReinitNewGoalAngularFieldNumber = 14;
  double force_reinit_new_goal_angular() const;
  void set_force_reinit_new_goal_angular(double value);

  // optional double min_resolution_collision_check_angular = 17;
  bool has_min_resolution_collision_check_angular() const;
  void clear_min_resolution_collision_check_angular();
  static const int kMinResolutionCollisionCheckAngularFieldNumber = 17;
  double min_resolution_collision_check_angular() const;
  void set_min_resolution_collision_check_angular(double value);

  // optional bool publish_feedback = 16;
  bool has_publish_feedback() const;
  void clear_publish_feedback();
  static const int kPublishFeedbackFieldNumber = 16;
  bool publish_feedback() const;
  void set_publish_feedback(bool value);

  // optional int32 control_look_ahead_poses = 18;
  bool has_control_look_ahead_poses() const;
  void clear_control_look_ahead_poses();
  static const int kControlLookAheadPosesFieldNumber = 18;
  ::google::protobuf::int32 control_look_ahead_poses() const;
  void set_control_look_ahead_poses(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:teb.Trajectory)
 private:
  void set_has_autosize();
  void clear_has_autosize();
  void set_has_dt_ref();
  void clear_has_dt_ref();
  void set_has_dt_hysteresis();
  void clear_has_dt_hysteresis();
  void set_has_min_samples();
  void clear_has_min_samples();
  void set_has_max_samples();
  void clear_has_max_samples();
  void set_has_global_plan_overwrite_orientation();
  void clear_has_global_plan_overwrite_orientation();
  void set_has_allow_init_with_backwards_motion();
  void clear_has_allow_init_with_backwards_motion();
  void set_has_global_plan_viapoint_sep();
  void clear_has_global_plan_viapoint_sep();
  void set_has_via_points_ordered();
  void clear_has_via_points_ordered();
  void set_has_max_global_plan_lookahead_dist();
  void clear_has_max_global_plan_lookahead_dist();
  void set_has_global_plan_prune_distance();
  void clear_has_global_plan_prune_distance();
  void set_has_exact_arc_length();
  void clear_has_exact_arc_length();
  void set_has_force_reinit_new_goal_dist();
  void clear_has_force_reinit_new_goal_dist();
  void set_has_force_reinit_new_goal_angular();
  void clear_has_force_reinit_new_goal_angular();
  void set_has_feasibility_check_no_poses();
  void clear_has_feasibility_check_no_poses();
  void set_has_publish_feedback();
  void clear_has_publish_feedback();
  void set_has_min_resolution_collision_check_angular();
  void clear_has_min_resolution_collision_check_angular();
  void set_has_control_look_ahead_poses();
  void clear_has_control_look_ahead_poses();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double autosize_;
  double dt_ref_;
  double dt_hysteresis_;
  ::google::protobuf::int32 min_samples_;
  ::google::protobuf::int32 max_samples_;
  double global_plan_viapoint_sep_;
  bool global_plan_overwrite_orientation_;
  bool allow_init_with_backwards_motion_;
  bool via_points_ordered_;
  bool exact_arc_length_;
  ::google::protobuf::int32 feasibility_check_no_poses_;
  double max_global_plan_lookahead_dist_;
  double global_plan_prune_distance_;
  double force_reinit_new_goal_dist_;
  double force_reinit_new_goal_angular_;
  double min_resolution_collision_check_angular_;
  bool publish_feedback_;
  ::google::protobuf::int32 control_look_ahead_poses_;
  friend struct ::protobuf_planner_2fteb_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_planner_2fteb_5fconfig_2eproto::InitDefaultsTrajectoryImpl();
};
// -------------------------------------------------------------------

class Robot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:teb.Robot) */ {
 public:
  Robot();
  virtual ~Robot();

  Robot(const Robot& from);

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(Robot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Robot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Robot* other);
  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Robot* New() const PROTOBUF_FINAL { return New(NULL); }

  Robot* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Robot& from);
  void MergeFrom(const Robot& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Robot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double max_vel_x = 1;
  bool has_max_vel_x() const;
  void clear_max_vel_x();
  static const int kMaxVelXFieldNumber = 1;
  double max_vel_x() const;
  void set_max_vel_x(double value);

  // optional double max_vel_x_backwards = 2;
  bool has_max_vel_x_backwards() const;
  void clear_max_vel_x_backwards();
  static const int kMaxVelXBackwardsFieldNumber = 2;
  double max_vel_x_backwards() const;
  void set_max_vel_x_backwards(double value);

  // optional double max_vel_y = 3;
  bool has_max_vel_y() const;
  void clear_max_vel_y();
  static const int kMaxVelYFieldNumber = 3;
  double max_vel_y() const;
  void set_max_vel_y(double value);

  // optional double max_vel_theta = 4;
  bool has_max_vel_theta() const;
  void clear_max_vel_theta();
  static const int kMaxVelThetaFieldNumber = 4;
  double max_vel_theta() const;
  void set_max_vel_theta(double value);

  // optional double acc_lim_x = 5;
  bool has_acc_lim_x() const;
  void clear_acc_lim_x();
  static const int kAccLimXFieldNumber = 5;
  double acc_lim_x() const;
  void set_acc_lim_x(double value);

  // optional double acc_lim_y = 6;
  bool has_acc_lim_y() const;
  void clear_acc_lim_y();
  static const int kAccLimYFieldNumber = 6;
  double acc_lim_y() const;
  void set_acc_lim_y(double value);

  // optional double acc_lim_theta = 7;
  bool has_acc_lim_theta() const;
  void clear_acc_lim_theta();
  static const int kAccLimThetaFieldNumber = 7;
  double acc_lim_theta() const;
  void set_acc_lim_theta(double value);

  // optional double min_turning_radius = 8;
  bool has_min_turning_radius() const;
  void clear_min_turning_radius();
  static const int kMinTurningRadiusFieldNumber = 8;
  double min_turning_radius() const;
  void set_min_turning_radius(double value);

  // optional double wheelbase = 9;
  bool has_wheelbase() const;
  void clear_wheelbase();
  static const int kWheelbaseFieldNumber = 9;
  double wheelbase() const;
  void set_wheelbase(double value);

  // optional bool cmd_angle_instead_rotvel = 10;
  bool has_cmd_angle_instead_rotvel() const;
  void clear_cmd_angle_instead_rotvel();
  static const int kCmdAngleInsteadRotvelFieldNumber = 10;
  bool cmd_angle_instead_rotvel() const;
  void set_cmd_angle_instead_rotvel(bool value);

  // optional bool is_footprint_dynamic = 11;
  bool has_is_footprint_dynamic() const;
  void clear_is_footprint_dynamic();
  static const int kIsFootprintDynamicFieldNumber = 11;
  bool is_footprint_dynamic() const;
  void set_is_footprint_dynamic(bool value);

  // optional bool use_proportional_saturation = 12;
  bool has_use_proportional_saturation() const;
  void clear_use_proportional_saturation();
  static const int kUseProportionalSaturationFieldNumber = 12;
  bool use_proportional_saturation() const;
  void set_use_proportional_saturation(bool value);

  // optional int32 vehicle_mode = 14;
  bool has_vehicle_mode() const;
  void clear_vehicle_mode();
  static const int kVehicleModeFieldNumber = 14;
  ::google::protobuf::int32 vehicle_mode() const;
  void set_vehicle_mode(::google::protobuf::int32 value);

  // optional double transform_tolerance = 13;
  bool has_transform_tolerance() const;
  void clear_transform_tolerance();
  static const int kTransformToleranceFieldNumber = 13;
  double transform_tolerance() const;
  void set_transform_tolerance(double value);

  // @@protoc_insertion_point(class_scope:teb.Robot)
 private:
  void set_has_max_vel_x();
  void clear_has_max_vel_x();
  void set_has_max_vel_x_backwards();
  void clear_has_max_vel_x_backwards();
  void set_has_max_vel_y();
  void clear_has_max_vel_y();
  void set_has_max_vel_theta();
  void clear_has_max_vel_theta();
  void set_has_acc_lim_x();
  void clear_has_acc_lim_x();
  void set_has_acc_lim_y();
  void clear_has_acc_lim_y();
  void set_has_acc_lim_theta();
  void clear_has_acc_lim_theta();
  void set_has_min_turning_radius();
  void clear_has_min_turning_radius();
  void set_has_wheelbase();
  void clear_has_wheelbase();
  void set_has_cmd_angle_instead_rotvel();
  void clear_has_cmd_angle_instead_rotvel();
  void set_has_is_footprint_dynamic();
  void clear_has_is_footprint_dynamic();
  void set_has_use_proportional_saturation();
  void clear_has_use_proportional_saturation();
  void set_has_transform_tolerance();
  void clear_has_transform_tolerance();
  void set_has_vehicle_mode();
  void clear_has_vehicle_mode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double max_vel_x_;
  double max_vel_x_backwards_;
  double max_vel_y_;
  double max_vel_theta_;
  double acc_lim_x_;
  double acc_lim_y_;
  double acc_lim_theta_;
  double min_turning_radius_;
  double wheelbase_;
  bool cmd_angle_instead_rotvel_;
  bool is_footprint_dynamic_;
  bool use_proportional_saturation_;
  ::google::protobuf::int32 vehicle_mode_;
  double transform_tolerance_;
  friend struct ::protobuf_planner_2fteb_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_planner_2fteb_5fconfig_2eproto::InitDefaultsRobotImpl();
};
// -------------------------------------------------------------------

class GoalTolerance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:teb.GoalTolerance) */ {
 public:
  GoalTolerance();
  virtual ~GoalTolerance();

  GoalTolerance(const GoalTolerance& from);

  inline GoalTolerance& operator=(const GoalTolerance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GoalTolerance(GoalTolerance&& from) noexcept
    : GoalTolerance() {
    *this = ::std::move(from);
  }

  inline GoalTolerance& operator=(GoalTolerance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GoalTolerance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GoalTolerance* internal_default_instance() {
    return reinterpret_cast<const GoalTolerance*>(
               &_GoalTolerance_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(GoalTolerance* other);
  friend void swap(GoalTolerance& a, GoalTolerance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GoalTolerance* New() const PROTOBUF_FINAL { return New(NULL); }

  GoalTolerance* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GoalTolerance& from);
  void MergeFrom(const GoalTolerance& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GoalTolerance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double yaw_goal_tolerance = 1;
  bool has_yaw_goal_tolerance() const;
  void clear_yaw_goal_tolerance();
  static const int kYawGoalToleranceFieldNumber = 1;
  double yaw_goal_tolerance() const;
  void set_yaw_goal_tolerance(double value);

  // optional double xy_goal_tolerance = 2;
  bool has_xy_goal_tolerance() const;
  void clear_xy_goal_tolerance();
  static const int kXyGoalToleranceFieldNumber = 2;
  double xy_goal_tolerance() const;
  void set_xy_goal_tolerance(double value);

  // optional double trans_stopped_vel = 4;
  bool has_trans_stopped_vel() const;
  void clear_trans_stopped_vel();
  static const int kTransStoppedVelFieldNumber = 4;
  double trans_stopped_vel() const;
  void set_trans_stopped_vel(double value);

  // optional double theta_stopped_vel = 5;
  bool has_theta_stopped_vel() const;
  void clear_theta_stopped_vel();
  static const int kThetaStoppedVelFieldNumber = 5;
  double theta_stopped_vel() const;
  void set_theta_stopped_vel(double value);

  // optional bool free_goal_vel = 3;
  bool has_free_goal_vel() const;
  void clear_free_goal_vel();
  static const int kFreeGoalVelFieldNumber = 3;
  bool free_goal_vel() const;
  void set_free_goal_vel(bool value);

  // optional bool complete_global_plan = 6;
  bool has_complete_global_plan() const;
  void clear_complete_global_plan();
  static const int kCompleteGlobalPlanFieldNumber = 6;
  bool complete_global_plan() const;
  void set_complete_global_plan(bool value);

  // @@protoc_insertion_point(class_scope:teb.GoalTolerance)
 private:
  void set_has_yaw_goal_tolerance();
  void clear_has_yaw_goal_tolerance();
  void set_has_xy_goal_tolerance();
  void clear_has_xy_goal_tolerance();
  void set_has_free_goal_vel();
  void clear_has_free_goal_vel();
  void set_has_trans_stopped_vel();
  void clear_has_trans_stopped_vel();
  void set_has_theta_stopped_vel();
  void clear_has_theta_stopped_vel();
  void set_has_complete_global_plan();
  void clear_has_complete_global_plan();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double yaw_goal_tolerance_;
  double xy_goal_tolerance_;
  double trans_stopped_vel_;
  double theta_stopped_vel_;
  bool free_goal_vel_;
  bool complete_global_plan_;
  friend struct ::protobuf_planner_2fteb_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_planner_2fteb_5fconfig_2eproto::InitDefaultsGoalToleranceImpl();
};
// -------------------------------------------------------------------

class Obstacles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:teb.Obstacles) */ {
 public:
  Obstacles();
  virtual ~Obstacles();

  Obstacles(const Obstacles& from);

  inline Obstacles& operator=(const Obstacles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Obstacles(Obstacles&& from) noexcept
    : Obstacles() {
    *this = ::std::move(from);
  }

  inline Obstacles& operator=(Obstacles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Obstacles* internal_default_instance() {
    return reinterpret_cast<const Obstacles*>(
               &_Obstacles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Obstacles* other);
  friend void swap(Obstacles& a, Obstacles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Obstacles* New() const PROTOBUF_FINAL { return New(NULL); }

  Obstacles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Obstacles& from);
  void MergeFrom(const Obstacles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Obstacles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double min_obstacle_dist = 1;
  bool has_min_obstacle_dist() const;
  void clear_min_obstacle_dist();
  static const int kMinObstacleDistFieldNumber = 1;
  double min_obstacle_dist() const;
  void set_min_obstacle_dist(double value);

  // optional double inflation_dist = 2;
  bool has_inflation_dist() const;
  void clear_inflation_dist();
  static const int kInflationDistFieldNumber = 2;
  double inflation_dist() const;
  void set_inflation_dist(double value);

  // optional double dynamic_obstacle_inflation_dist = 3;
  bool has_dynamic_obstacle_inflation_dist() const;
  void clear_dynamic_obstacle_inflation_dist();
  static const int kDynamicObstacleInflationDistFieldNumber = 3;
  double dynamic_obstacle_inflation_dist() const;
  void set_dynamic_obstacle_inflation_dist(double value);

  // optional double costmap_obstacles_behind_robot_dist = 6;
  bool has_costmap_obstacles_behind_robot_dist() const;
  void clear_costmap_obstacles_behind_robot_dist();
  static const int kCostmapObstaclesBehindRobotDistFieldNumber = 6;
  double costmap_obstacles_behind_robot_dist() const;
  void set_costmap_obstacles_behind_robot_dist(double value);

  // optional int32 obstacle_poses_affected = 7;
  bool has_obstacle_poses_affected() const;
  void clear_obstacle_poses_affected();
  static const int kObstaclePosesAffectedFieldNumber = 7;
  ::google::protobuf::int32 obstacle_poses_affected() const;
  void set_obstacle_poses_affected(::google::protobuf::int32 value);

  // optional bool include_dynamic_obstacles = 4;
  bool has_include_dynamic_obstacles() const;
  void clear_include_dynamic_obstacles();
  static const int kIncludeDynamicObstaclesFieldNumber = 4;
  bool include_dynamic_obstacles() const;
  void set_include_dynamic_obstacles(bool value);

  // optional bool include_costmap_obstacles = 5;
  bool has_include_costmap_obstacles() const;
  void clear_include_costmap_obstacles();
  static const int kIncludeCostmapObstaclesFieldNumber = 5;
  bool include_costmap_obstacles() const;
  void set_include_costmap_obstacles(bool value);

  // optional bool legacy_obstacle_association = 8;
  bool has_legacy_obstacle_association() const;
  void clear_legacy_obstacle_association();
  static const int kLegacyObstacleAssociationFieldNumber = 8;
  bool legacy_obstacle_association() const;
  void set_legacy_obstacle_association(bool value);

  // optional bool costmap_converter_spin_thread = 11;
  bool has_costmap_converter_spin_thread() const;
  void clear_costmap_converter_spin_thread();
  static const int kCostmapConverterSpinThreadFieldNumber = 11;
  bool costmap_converter_spin_thread() const;
  void set_costmap_converter_spin_thread(bool value);

  // optional double obstacle_association_force_inclusion_factor = 9;
  bool has_obstacle_association_force_inclusion_factor() const;
  void clear_obstacle_association_force_inclusion_factor();
  static const int kObstacleAssociationForceInclusionFactorFieldNumber = 9;
  double obstacle_association_force_inclusion_factor() const;
  void set_obstacle_association_force_inclusion_factor(double value);

  // optional double obstacle_association_cutoff_factor = 10;
  bool has_obstacle_association_cutoff_factor() const;
  void clear_obstacle_association_cutoff_factor();
  static const int kObstacleAssociationCutoffFactorFieldNumber = 10;
  double obstacle_association_cutoff_factor() const;
  void set_obstacle_association_cutoff_factor(double value);

  // optional double obstacle_proximity_ratio_max_vel = 13;
  bool has_obstacle_proximity_ratio_max_vel() const;
  void clear_obstacle_proximity_ratio_max_vel();
  static const int kObstacleProximityRatioMaxVelFieldNumber = 13;
  double obstacle_proximity_ratio_max_vel() const;
  void set_obstacle_proximity_ratio_max_vel(double value);

  // optional double obstacle_proximity_lower_bound = 14;
  bool has_obstacle_proximity_lower_bound() const;
  void clear_obstacle_proximity_lower_bound();
  static const int kObstacleProximityLowerBoundFieldNumber = 14;
  double obstacle_proximity_lower_bound() const;
  void set_obstacle_proximity_lower_bound(double value);

  // optional double obstacle_proximity_upper_bound = 15;
  bool has_obstacle_proximity_upper_bound() const;
  void clear_obstacle_proximity_upper_bound();
  static const int kObstacleProximityUpperBoundFieldNumber = 15;
  double obstacle_proximity_upper_bound() const;
  void set_obstacle_proximity_upper_bound(double value);

  // optional int32 costmap_converter_rate = 12;
  bool has_costmap_converter_rate() const;
  void clear_costmap_converter_rate();
  static const int kCostmapConverterRateFieldNumber = 12;
  ::google::protobuf::int32 costmap_converter_rate() const;
  void set_costmap_converter_rate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:teb.Obstacles)
 private:
  void set_has_min_obstacle_dist();
  void clear_has_min_obstacle_dist();
  void set_has_inflation_dist();
  void clear_has_inflation_dist();
  void set_has_dynamic_obstacle_inflation_dist();
  void clear_has_dynamic_obstacle_inflation_dist();
  void set_has_include_dynamic_obstacles();
  void clear_has_include_dynamic_obstacles();
  void set_has_include_costmap_obstacles();
  void clear_has_include_costmap_obstacles();
  void set_has_costmap_obstacles_behind_robot_dist();
  void clear_has_costmap_obstacles_behind_robot_dist();
  void set_has_obstacle_poses_affected();
  void clear_has_obstacle_poses_affected();
  void set_has_legacy_obstacle_association();
  void clear_has_legacy_obstacle_association();
  void set_has_obstacle_association_force_inclusion_factor();
  void clear_has_obstacle_association_force_inclusion_factor();
  void set_has_obstacle_association_cutoff_factor();
  void clear_has_obstacle_association_cutoff_factor();
  void set_has_costmap_converter_spin_thread();
  void clear_has_costmap_converter_spin_thread();
  void set_has_costmap_converter_rate();
  void clear_has_costmap_converter_rate();
  void set_has_obstacle_proximity_ratio_max_vel();
  void clear_has_obstacle_proximity_ratio_max_vel();
  void set_has_obstacle_proximity_lower_bound();
  void clear_has_obstacle_proximity_lower_bound();
  void set_has_obstacle_proximity_upper_bound();
  void clear_has_obstacle_proximity_upper_bound();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double min_obstacle_dist_;
  double inflation_dist_;
  double dynamic_obstacle_inflation_dist_;
  double costmap_obstacles_behind_robot_dist_;
  ::google::protobuf::int32 obstacle_poses_affected_;
  bool include_dynamic_obstacles_;
  bool include_costmap_obstacles_;
  bool legacy_obstacle_association_;
  bool costmap_converter_spin_thread_;
  double obstacle_association_force_inclusion_factor_;
  double obstacle_association_cutoff_factor_;
  double obstacle_proximity_ratio_max_vel_;
  double obstacle_proximity_lower_bound_;
  double obstacle_proximity_upper_bound_;
  ::google::protobuf::int32 costmap_converter_rate_;
  friend struct ::protobuf_planner_2fteb_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_planner_2fteb_5fconfig_2eproto::InitDefaultsObstaclesImpl();
};
// -------------------------------------------------------------------

class Optimization : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:teb.Optimization) */ {
 public:
  Optimization();
  virtual ~Optimization();

  Optimization(const Optimization& from);

  inline Optimization& operator=(const Optimization& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Optimization(Optimization&& from) noexcept
    : Optimization() {
    *this = ::std::move(from);
  }

  inline Optimization& operator=(Optimization&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Optimization& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Optimization* internal_default_instance() {
    return reinterpret_cast<const Optimization*>(
               &_Optimization_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Optimization* other);
  friend void swap(Optimization& a, Optimization& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Optimization* New() const PROTOBUF_FINAL { return New(NULL); }

  Optimization* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Optimization& from);
  void MergeFrom(const Optimization& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Optimization* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 no_inner_iterations = 1;
  bool has_no_inner_iterations() const;
  void clear_no_inner_iterations();
  static const int kNoInnerIterationsFieldNumber = 1;
  ::google::protobuf::int32 no_inner_iterations() const;
  void set_no_inner_iterations(::google::protobuf::int32 value);

  // optional int32 no_outer_iterations = 2;
  bool has_no_outer_iterations() const;
  void clear_no_outer_iterations();
  static const int kNoOuterIterationsFieldNumber = 2;
  ::google::protobuf::int32 no_outer_iterations() const;
  void set_no_outer_iterations(::google::protobuf::int32 value);

  // optional double penalty_epsilon = 5;
  bool has_penalty_epsilon() const;
  void clear_penalty_epsilon();
  static const int kPenaltyEpsilonFieldNumber = 5;
  double penalty_epsilon() const;
  void set_penalty_epsilon(double value);

  // optional double weight_max_vel_x = 6;
  bool has_weight_max_vel_x() const;
  void clear_weight_max_vel_x();
  static const int kWeightMaxVelXFieldNumber = 6;
  double weight_max_vel_x() const;
  void set_weight_max_vel_x(double value);

  // optional double weight_max_vel_y = 7;
  bool has_weight_max_vel_y() const;
  void clear_weight_max_vel_y();
  static const int kWeightMaxVelYFieldNumber = 7;
  double weight_max_vel_y() const;
  void set_weight_max_vel_y(double value);

  // optional double weight_max_vel_theta = 8;
  bool has_weight_max_vel_theta() const;
  void clear_weight_max_vel_theta();
  static const int kWeightMaxVelThetaFieldNumber = 8;
  double weight_max_vel_theta() const;
  void set_weight_max_vel_theta(double value);

  // optional double weight_acc_lim_x = 9;
  bool has_weight_acc_lim_x() const;
  void clear_weight_acc_lim_x();
  static const int kWeightAccLimXFieldNumber = 9;
  double weight_acc_lim_x() const;
  void set_weight_acc_lim_x(double value);

  // optional double weight_acc_lim_y = 10;
  bool has_weight_acc_lim_y() const;
  void clear_weight_acc_lim_y();
  static const int kWeightAccLimYFieldNumber = 10;
  double weight_acc_lim_y() const;
  void set_weight_acc_lim_y(double value);

  // optional double weight_acc_lim_theta = 11;
  bool has_weight_acc_lim_theta() const;
  void clear_weight_acc_lim_theta();
  static const int kWeightAccLimThetaFieldNumber = 11;
  double weight_acc_lim_theta() const;
  void set_weight_acc_lim_theta(double value);

  // optional double weight_kinematics_nh = 12;
  bool has_weight_kinematics_nh() const;
  void clear_weight_kinematics_nh();
  static const int kWeightKinematicsNhFieldNumber = 12;
  double weight_kinematics_nh() const;
  void set_weight_kinematics_nh(double value);

  // optional double weight_kinematics_forward_drive = 13;
  bool has_weight_kinematics_forward_drive() const;
  void clear_weight_kinematics_forward_drive();
  static const int kWeightKinematicsForwardDriveFieldNumber = 13;
  double weight_kinematics_forward_drive() const;
  void set_weight_kinematics_forward_drive(double value);

  // optional double weight_kinematics_turning_radius = 14;
  bool has_weight_kinematics_turning_radius() const;
  void clear_weight_kinematics_turning_radius();
  static const int kWeightKinematicsTurningRadiusFieldNumber = 14;
  double weight_kinematics_turning_radius() const;
  void set_weight_kinematics_turning_radius(double value);

  // optional double weight_optimaltime = 15;
  bool has_weight_optimaltime() const;
  void clear_weight_optimaltime();
  static const int kWeightOptimaltimeFieldNumber = 15;
  double weight_optimaltime() const;
  void set_weight_optimaltime(double value);

  // optional double weight_shortest_path = 16;
  bool has_weight_shortest_path() const;
  void clear_weight_shortest_path();
  static const int kWeightShortestPathFieldNumber = 16;
  double weight_shortest_path() const;
  void set_weight_shortest_path(double value);

  // optional double weight_obstacle = 17;
  bool has_weight_obstacle() const;
  void clear_weight_obstacle();
  static const int kWeightObstacleFieldNumber = 17;
  double weight_obstacle() const;
  void set_weight_obstacle(double value);

  // optional double weight_inflation = 18;
  bool has_weight_inflation() const;
  void clear_weight_inflation();
  static const int kWeightInflationFieldNumber = 18;
  double weight_inflation() const;
  void set_weight_inflation(double value);

  // optional double weight_dynamic_obstacle = 19;
  bool has_weight_dynamic_obstacle() const;
  void clear_weight_dynamic_obstacle();
  static const int kWeightDynamicObstacleFieldNumber = 19;
  double weight_dynamic_obstacle() const;
  void set_weight_dynamic_obstacle(double value);

  // optional double weight_dynamic_obstacle_inflation = 20;
  bool has_weight_dynamic_obstacle_inflation() const;
  void clear_weight_dynamic_obstacle_inflation();
  static const int kWeightDynamicObstacleInflationFieldNumber = 20;
  double weight_dynamic_obstacle_inflation() const;
  void set_weight_dynamic_obstacle_inflation(double value);

  // optional double weight_velocity_obstacle_ratio = 21;
  bool has_weight_velocity_obstacle_ratio() const;
  void clear_weight_velocity_obstacle_ratio();
  static const int kWeightVelocityObstacleRatioFieldNumber = 21;
  double weight_velocity_obstacle_ratio() const;
  void set_weight_velocity_obstacle_ratio(double value);

  // optional double weight_viapoint = 22;
  bool has_weight_viapoint() const;
  void clear_weight_viapoint();
  static const int kWeightViapointFieldNumber = 22;
  double weight_viapoint() const;
  void set_weight_viapoint(double value);

  // optional double weight_prefer_rotdir = 23;
  bool has_weight_prefer_rotdir() const;
  void clear_weight_prefer_rotdir();
  static const int kWeightPreferRotdirFieldNumber = 23;
  double weight_prefer_rotdir() const;
  void set_weight_prefer_rotdir(double value);

  // optional double weight_adapt_factor = 24;
  bool has_weight_adapt_factor() const;
  void clear_weight_adapt_factor();
  static const int kWeightAdaptFactorFieldNumber = 24;
  double weight_adapt_factor() const;
  void set_weight_adapt_factor(double value);

  // optional double obstacle_cost_exponent = 25;
  bool has_obstacle_cost_exponent() const;
  void clear_obstacle_cost_exponent();
  static const int kObstacleCostExponentFieldNumber = 25;
  double obstacle_cost_exponent() const;
  void set_obstacle_cost_exponent(double value);

  // optional bool optimization_activate = 3;
  bool has_optimization_activate() const;
  void clear_optimization_activate();
  static const int kOptimizationActivateFieldNumber = 3;
  bool optimization_activate() const;
  void set_optimization_activate(bool value);

  // optional bool optimization_verbose = 4;
  bool has_optimization_verbose() const;
  void clear_optimization_verbose();
  static const int kOptimizationVerboseFieldNumber = 4;
  bool optimization_verbose() const;
  void set_optimization_verbose(bool value);

  // @@protoc_insertion_point(class_scope:teb.Optimization)
 private:
  void set_has_no_inner_iterations();
  void clear_has_no_inner_iterations();
  void set_has_no_outer_iterations();
  void clear_has_no_outer_iterations();
  void set_has_optimization_activate();
  void clear_has_optimization_activate();
  void set_has_optimization_verbose();
  void clear_has_optimization_verbose();
  void set_has_penalty_epsilon();
  void clear_has_penalty_epsilon();
  void set_has_weight_max_vel_x();
  void clear_has_weight_max_vel_x();
  void set_has_weight_max_vel_y();
  void clear_has_weight_max_vel_y();
  void set_has_weight_max_vel_theta();
  void clear_has_weight_max_vel_theta();
  void set_has_weight_acc_lim_x();
  void clear_has_weight_acc_lim_x();
  void set_has_weight_acc_lim_y();
  void clear_has_weight_acc_lim_y();
  void set_has_weight_acc_lim_theta();
  void clear_has_weight_acc_lim_theta();
  void set_has_weight_kinematics_nh();
  void clear_has_weight_kinematics_nh();
  void set_has_weight_kinematics_forward_drive();
  void clear_has_weight_kinematics_forward_drive();
  void set_has_weight_kinematics_turning_radius();
  void clear_has_weight_kinematics_turning_radius();
  void set_has_weight_optimaltime();
  void clear_has_weight_optimaltime();
  void set_has_weight_shortest_path();
  void clear_has_weight_shortest_path();
  void set_has_weight_obstacle();
  void clear_has_weight_obstacle();
  void set_has_weight_inflation();
  void clear_has_weight_inflation();
  void set_has_weight_dynamic_obstacle();
  void clear_has_weight_dynamic_obstacle();
  void set_has_weight_dynamic_obstacle_inflation();
  void clear_has_weight_dynamic_obstacle_inflation();
  void set_has_weight_velocity_obstacle_ratio();
  void clear_has_weight_velocity_obstacle_ratio();
  void set_has_weight_viapoint();
  void clear_has_weight_viapoint();
  void set_has_weight_prefer_rotdir();
  void clear_has_weight_prefer_rotdir();
  void set_has_weight_adapt_factor();
  void clear_has_weight_adapt_factor();
  void set_has_obstacle_cost_exponent();
  void clear_has_obstacle_cost_exponent();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 no_inner_iterations_;
  ::google::protobuf::int32 no_outer_iterations_;
  double penalty_epsilon_;
  double weight_max_vel_x_;
  double weight_max_vel_y_;
  double weight_max_vel_theta_;
  double weight_acc_lim_x_;
  double weight_acc_lim_y_;
  double weight_acc_lim_theta_;
  double weight_kinematics_nh_;
  double weight_kinematics_forward_drive_;
  double weight_kinematics_turning_radius_;
  double weight_optimaltime_;
  double weight_shortest_path_;
  double weight_obstacle_;
  double weight_inflation_;
  double weight_dynamic_obstacle_;
  double weight_dynamic_obstacle_inflation_;
  double weight_velocity_obstacle_ratio_;
  double weight_viapoint_;
  double weight_prefer_rotdir_;
  double weight_adapt_factor_;
  double obstacle_cost_exponent_;
  bool optimization_activate_;
  bool optimization_verbose_;
  friend struct ::protobuf_planner_2fteb_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_planner_2fteb_5fconfig_2eproto::InitDefaultsOptimizationImpl();
};
// -------------------------------------------------------------------

class TebConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:teb.TebConfig) */ {
 public:
  TebConfig();
  virtual ~TebConfig();

  TebConfig(const TebConfig& from);

  inline TebConfig& operator=(const TebConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TebConfig(TebConfig&& from) noexcept
    : TebConfig() {
    *this = ::std::move(from);
  }

  inline TebConfig& operator=(TebConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TebConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TebConfig* internal_default_instance() {
    return reinterpret_cast<const TebConfig*>(
               &_TebConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TebConfig* other);
  friend void swap(TebConfig& a, TebConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TebConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  TebConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TebConfig& from);
  void MergeFrom(const TebConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TebConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .teb.Trajectory trajectory = 1;
  bool has_trajectory() const;
  void clear_trajectory();
  static const int kTrajectoryFieldNumber = 1;
  const ::teb::Trajectory& trajectory() const;
  ::teb::Trajectory* release_trajectory();
  ::teb::Trajectory* mutable_trajectory();
  void set_allocated_trajectory(::teb::Trajectory* trajectory);

  // optional .teb.Robot robot = 2;
  bool has_robot() const;
  void clear_robot();
  static const int kRobotFieldNumber = 2;
  const ::teb::Robot& robot() const;
  ::teb::Robot* release_robot();
  ::teb::Robot* mutable_robot();
  void set_allocated_robot(::teb::Robot* robot);

  // optional .teb.GoalTolerance goal_tolerance = 3;
  bool has_goal_tolerance() const;
  void clear_goal_tolerance();
  static const int kGoalToleranceFieldNumber = 3;
  const ::teb::GoalTolerance& goal_tolerance() const;
  ::teb::GoalTolerance* release_goal_tolerance();
  ::teb::GoalTolerance* mutable_goal_tolerance();
  void set_allocated_goal_tolerance(::teb::GoalTolerance* goal_tolerance);

  // optional .teb.Obstacles obstacles = 4;
  bool has_obstacles() const;
  void clear_obstacles();
  static const int kObstaclesFieldNumber = 4;
  const ::teb::Obstacles& obstacles() const;
  ::teb::Obstacles* release_obstacles();
  ::teb::Obstacles* mutable_obstacles();
  void set_allocated_obstacles(::teb::Obstacles* obstacles);

  // optional .teb.Optimization optim = 5;
  bool has_optim() const;
  void clear_optim();
  static const int kOptimFieldNumber = 5;
  const ::teb::Optimization& optim() const;
  ::teb::Optimization* release_optim();
  ::teb::Optimization* mutable_optim();
  void set_allocated_optim(::teb::Optimization* optim);

  // @@protoc_insertion_point(class_scope:teb.TebConfig)
 private:
  void set_has_trajectory();
  void clear_has_trajectory();
  void set_has_robot();
  void clear_has_robot();
  void set_has_goal_tolerance();
  void clear_has_goal_tolerance();
  void set_has_obstacles();
  void clear_has_obstacles();
  void set_has_optim();
  void clear_has_optim();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::teb::Trajectory* trajectory_;
  ::teb::Robot* robot_;
  ::teb::GoalTolerance* goal_tolerance_;
  ::teb::Obstacles* obstacles_;
  ::teb::Optimization* optim_;
  friend struct ::protobuf_planner_2fteb_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_planner_2fteb_5fconfig_2eproto::InitDefaultsTebConfigImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Trajectory

// optional double autosize = 1;
inline bool Trajectory::has_autosize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trajectory::set_has_autosize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trajectory::clear_has_autosize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trajectory::clear_autosize() {
  autosize_ = 0;
  clear_has_autosize();
}
inline double Trajectory::autosize() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.autosize)
  return autosize_;
}
inline void Trajectory::set_autosize(double value) {
  set_has_autosize();
  autosize_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.autosize)
}

// optional double dt_ref = 2;
inline bool Trajectory::has_dt_ref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trajectory::set_has_dt_ref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trajectory::clear_has_dt_ref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trajectory::clear_dt_ref() {
  dt_ref_ = 0;
  clear_has_dt_ref();
}
inline double Trajectory::dt_ref() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.dt_ref)
  return dt_ref_;
}
inline void Trajectory::set_dt_ref(double value) {
  set_has_dt_ref();
  dt_ref_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.dt_ref)
}

// optional double dt_hysteresis = 3;
inline bool Trajectory::has_dt_hysteresis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Trajectory::set_has_dt_hysteresis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Trajectory::clear_has_dt_hysteresis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Trajectory::clear_dt_hysteresis() {
  dt_hysteresis_ = 0;
  clear_has_dt_hysteresis();
}
inline double Trajectory::dt_hysteresis() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.dt_hysteresis)
  return dt_hysteresis_;
}
inline void Trajectory::set_dt_hysteresis(double value) {
  set_has_dt_hysteresis();
  dt_hysteresis_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.dt_hysteresis)
}

// optional int32 min_samples = 4;
inline bool Trajectory::has_min_samples() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Trajectory::set_has_min_samples() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Trajectory::clear_has_min_samples() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Trajectory::clear_min_samples() {
  min_samples_ = 0;
  clear_has_min_samples();
}
inline ::google::protobuf::int32 Trajectory::min_samples() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.min_samples)
  return min_samples_;
}
inline void Trajectory::set_min_samples(::google::protobuf::int32 value) {
  set_has_min_samples();
  min_samples_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.min_samples)
}

// optional int32 max_samples = 5;
inline bool Trajectory::has_max_samples() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Trajectory::set_has_max_samples() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Trajectory::clear_has_max_samples() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Trajectory::clear_max_samples() {
  max_samples_ = 0;
  clear_has_max_samples();
}
inline ::google::protobuf::int32 Trajectory::max_samples() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.max_samples)
  return max_samples_;
}
inline void Trajectory::set_max_samples(::google::protobuf::int32 value) {
  set_has_max_samples();
  max_samples_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.max_samples)
}

// optional bool global_plan_overwrite_orientation = 6;
inline bool Trajectory::has_global_plan_overwrite_orientation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Trajectory::set_has_global_plan_overwrite_orientation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Trajectory::clear_has_global_plan_overwrite_orientation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Trajectory::clear_global_plan_overwrite_orientation() {
  global_plan_overwrite_orientation_ = false;
  clear_has_global_plan_overwrite_orientation();
}
inline bool Trajectory::global_plan_overwrite_orientation() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.global_plan_overwrite_orientation)
  return global_plan_overwrite_orientation_;
}
inline void Trajectory::set_global_plan_overwrite_orientation(bool value) {
  set_has_global_plan_overwrite_orientation();
  global_plan_overwrite_orientation_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.global_plan_overwrite_orientation)
}

// optional bool allow_init_with_backwards_motion = 7;
inline bool Trajectory::has_allow_init_with_backwards_motion() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Trajectory::set_has_allow_init_with_backwards_motion() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Trajectory::clear_has_allow_init_with_backwards_motion() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Trajectory::clear_allow_init_with_backwards_motion() {
  allow_init_with_backwards_motion_ = false;
  clear_has_allow_init_with_backwards_motion();
}
inline bool Trajectory::allow_init_with_backwards_motion() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.allow_init_with_backwards_motion)
  return allow_init_with_backwards_motion_;
}
inline void Trajectory::set_allow_init_with_backwards_motion(bool value) {
  set_has_allow_init_with_backwards_motion();
  allow_init_with_backwards_motion_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.allow_init_with_backwards_motion)
}

// optional double global_plan_viapoint_sep = 8;
inline bool Trajectory::has_global_plan_viapoint_sep() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Trajectory::set_has_global_plan_viapoint_sep() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Trajectory::clear_has_global_plan_viapoint_sep() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Trajectory::clear_global_plan_viapoint_sep() {
  global_plan_viapoint_sep_ = 0;
  clear_has_global_plan_viapoint_sep();
}
inline double Trajectory::global_plan_viapoint_sep() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.global_plan_viapoint_sep)
  return global_plan_viapoint_sep_;
}
inline void Trajectory::set_global_plan_viapoint_sep(double value) {
  set_has_global_plan_viapoint_sep();
  global_plan_viapoint_sep_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.global_plan_viapoint_sep)
}

// optional bool via_points_ordered = 9;
inline bool Trajectory::has_via_points_ordered() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Trajectory::set_has_via_points_ordered() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Trajectory::clear_has_via_points_ordered() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Trajectory::clear_via_points_ordered() {
  via_points_ordered_ = false;
  clear_has_via_points_ordered();
}
inline bool Trajectory::via_points_ordered() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.via_points_ordered)
  return via_points_ordered_;
}
inline void Trajectory::set_via_points_ordered(bool value) {
  set_has_via_points_ordered();
  via_points_ordered_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.via_points_ordered)
}

// optional double max_global_plan_lookahead_dist = 10;
inline bool Trajectory::has_max_global_plan_lookahead_dist() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Trajectory::set_has_max_global_plan_lookahead_dist() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Trajectory::clear_has_max_global_plan_lookahead_dist() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Trajectory::clear_max_global_plan_lookahead_dist() {
  max_global_plan_lookahead_dist_ = 0;
  clear_has_max_global_plan_lookahead_dist();
}
inline double Trajectory::max_global_plan_lookahead_dist() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.max_global_plan_lookahead_dist)
  return max_global_plan_lookahead_dist_;
}
inline void Trajectory::set_max_global_plan_lookahead_dist(double value) {
  set_has_max_global_plan_lookahead_dist();
  max_global_plan_lookahead_dist_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.max_global_plan_lookahead_dist)
}

// optional double global_plan_prune_distance = 11;
inline bool Trajectory::has_global_plan_prune_distance() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Trajectory::set_has_global_plan_prune_distance() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Trajectory::clear_has_global_plan_prune_distance() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Trajectory::clear_global_plan_prune_distance() {
  global_plan_prune_distance_ = 0;
  clear_has_global_plan_prune_distance();
}
inline double Trajectory::global_plan_prune_distance() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.global_plan_prune_distance)
  return global_plan_prune_distance_;
}
inline void Trajectory::set_global_plan_prune_distance(double value) {
  set_has_global_plan_prune_distance();
  global_plan_prune_distance_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.global_plan_prune_distance)
}

// optional bool exact_arc_length = 12;
inline bool Trajectory::has_exact_arc_length() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Trajectory::set_has_exact_arc_length() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Trajectory::clear_has_exact_arc_length() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Trajectory::clear_exact_arc_length() {
  exact_arc_length_ = false;
  clear_has_exact_arc_length();
}
inline bool Trajectory::exact_arc_length() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.exact_arc_length)
  return exact_arc_length_;
}
inline void Trajectory::set_exact_arc_length(bool value) {
  set_has_exact_arc_length();
  exact_arc_length_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.exact_arc_length)
}

// optional double force_reinit_new_goal_dist = 13;
inline bool Trajectory::has_force_reinit_new_goal_dist() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Trajectory::set_has_force_reinit_new_goal_dist() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Trajectory::clear_has_force_reinit_new_goal_dist() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Trajectory::clear_force_reinit_new_goal_dist() {
  force_reinit_new_goal_dist_ = 0;
  clear_has_force_reinit_new_goal_dist();
}
inline double Trajectory::force_reinit_new_goal_dist() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.force_reinit_new_goal_dist)
  return force_reinit_new_goal_dist_;
}
inline void Trajectory::set_force_reinit_new_goal_dist(double value) {
  set_has_force_reinit_new_goal_dist();
  force_reinit_new_goal_dist_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.force_reinit_new_goal_dist)
}

// optional double force_reinit_new_goal_angular = 14;
inline bool Trajectory::has_force_reinit_new_goal_angular() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Trajectory::set_has_force_reinit_new_goal_angular() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Trajectory::clear_has_force_reinit_new_goal_angular() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Trajectory::clear_force_reinit_new_goal_angular() {
  force_reinit_new_goal_angular_ = 0;
  clear_has_force_reinit_new_goal_angular();
}
inline double Trajectory::force_reinit_new_goal_angular() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.force_reinit_new_goal_angular)
  return force_reinit_new_goal_angular_;
}
inline void Trajectory::set_force_reinit_new_goal_angular(double value) {
  set_has_force_reinit_new_goal_angular();
  force_reinit_new_goal_angular_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.force_reinit_new_goal_angular)
}

// optional int32 feasibility_check_no_poses = 15;
inline bool Trajectory::has_feasibility_check_no_poses() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Trajectory::set_has_feasibility_check_no_poses() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Trajectory::clear_has_feasibility_check_no_poses() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Trajectory::clear_feasibility_check_no_poses() {
  feasibility_check_no_poses_ = 0;
  clear_has_feasibility_check_no_poses();
}
inline ::google::protobuf::int32 Trajectory::feasibility_check_no_poses() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.feasibility_check_no_poses)
  return feasibility_check_no_poses_;
}
inline void Trajectory::set_feasibility_check_no_poses(::google::protobuf::int32 value) {
  set_has_feasibility_check_no_poses();
  feasibility_check_no_poses_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.feasibility_check_no_poses)
}

// optional bool publish_feedback = 16;
inline bool Trajectory::has_publish_feedback() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Trajectory::set_has_publish_feedback() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Trajectory::clear_has_publish_feedback() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Trajectory::clear_publish_feedback() {
  publish_feedback_ = false;
  clear_has_publish_feedback();
}
inline bool Trajectory::publish_feedback() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.publish_feedback)
  return publish_feedback_;
}
inline void Trajectory::set_publish_feedback(bool value) {
  set_has_publish_feedback();
  publish_feedback_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.publish_feedback)
}

// optional double min_resolution_collision_check_angular = 17;
inline bool Trajectory::has_min_resolution_collision_check_angular() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Trajectory::set_has_min_resolution_collision_check_angular() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Trajectory::clear_has_min_resolution_collision_check_angular() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Trajectory::clear_min_resolution_collision_check_angular() {
  min_resolution_collision_check_angular_ = 0;
  clear_has_min_resolution_collision_check_angular();
}
inline double Trajectory::min_resolution_collision_check_angular() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.min_resolution_collision_check_angular)
  return min_resolution_collision_check_angular_;
}
inline void Trajectory::set_min_resolution_collision_check_angular(double value) {
  set_has_min_resolution_collision_check_angular();
  min_resolution_collision_check_angular_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.min_resolution_collision_check_angular)
}

// optional int32 control_look_ahead_poses = 18;
inline bool Trajectory::has_control_look_ahead_poses() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Trajectory::set_has_control_look_ahead_poses() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Trajectory::clear_has_control_look_ahead_poses() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Trajectory::clear_control_look_ahead_poses() {
  control_look_ahead_poses_ = 0;
  clear_has_control_look_ahead_poses();
}
inline ::google::protobuf::int32 Trajectory::control_look_ahead_poses() const {
  // @@protoc_insertion_point(field_get:teb.Trajectory.control_look_ahead_poses)
  return control_look_ahead_poses_;
}
inline void Trajectory::set_control_look_ahead_poses(::google::protobuf::int32 value) {
  set_has_control_look_ahead_poses();
  control_look_ahead_poses_ = value;
  // @@protoc_insertion_point(field_set:teb.Trajectory.control_look_ahead_poses)
}

// -------------------------------------------------------------------

// Robot

// optional double max_vel_x = 1;
inline bool Robot::has_max_vel_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Robot::set_has_max_vel_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Robot::clear_has_max_vel_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Robot::clear_max_vel_x() {
  max_vel_x_ = 0;
  clear_has_max_vel_x();
}
inline double Robot::max_vel_x() const {
  // @@protoc_insertion_point(field_get:teb.Robot.max_vel_x)
  return max_vel_x_;
}
inline void Robot::set_max_vel_x(double value) {
  set_has_max_vel_x();
  max_vel_x_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.max_vel_x)
}

// optional double max_vel_x_backwards = 2;
inline bool Robot::has_max_vel_x_backwards() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Robot::set_has_max_vel_x_backwards() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Robot::clear_has_max_vel_x_backwards() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Robot::clear_max_vel_x_backwards() {
  max_vel_x_backwards_ = 0;
  clear_has_max_vel_x_backwards();
}
inline double Robot::max_vel_x_backwards() const {
  // @@protoc_insertion_point(field_get:teb.Robot.max_vel_x_backwards)
  return max_vel_x_backwards_;
}
inline void Robot::set_max_vel_x_backwards(double value) {
  set_has_max_vel_x_backwards();
  max_vel_x_backwards_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.max_vel_x_backwards)
}

// optional double max_vel_y = 3;
inline bool Robot::has_max_vel_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Robot::set_has_max_vel_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Robot::clear_has_max_vel_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Robot::clear_max_vel_y() {
  max_vel_y_ = 0;
  clear_has_max_vel_y();
}
inline double Robot::max_vel_y() const {
  // @@protoc_insertion_point(field_get:teb.Robot.max_vel_y)
  return max_vel_y_;
}
inline void Robot::set_max_vel_y(double value) {
  set_has_max_vel_y();
  max_vel_y_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.max_vel_y)
}

// optional double max_vel_theta = 4;
inline bool Robot::has_max_vel_theta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Robot::set_has_max_vel_theta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Robot::clear_has_max_vel_theta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Robot::clear_max_vel_theta() {
  max_vel_theta_ = 0;
  clear_has_max_vel_theta();
}
inline double Robot::max_vel_theta() const {
  // @@protoc_insertion_point(field_get:teb.Robot.max_vel_theta)
  return max_vel_theta_;
}
inline void Robot::set_max_vel_theta(double value) {
  set_has_max_vel_theta();
  max_vel_theta_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.max_vel_theta)
}

// optional double acc_lim_x = 5;
inline bool Robot::has_acc_lim_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Robot::set_has_acc_lim_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Robot::clear_has_acc_lim_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Robot::clear_acc_lim_x() {
  acc_lim_x_ = 0;
  clear_has_acc_lim_x();
}
inline double Robot::acc_lim_x() const {
  // @@protoc_insertion_point(field_get:teb.Robot.acc_lim_x)
  return acc_lim_x_;
}
inline void Robot::set_acc_lim_x(double value) {
  set_has_acc_lim_x();
  acc_lim_x_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.acc_lim_x)
}

// optional double acc_lim_y = 6;
inline bool Robot::has_acc_lim_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Robot::set_has_acc_lim_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Robot::clear_has_acc_lim_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Robot::clear_acc_lim_y() {
  acc_lim_y_ = 0;
  clear_has_acc_lim_y();
}
inline double Robot::acc_lim_y() const {
  // @@protoc_insertion_point(field_get:teb.Robot.acc_lim_y)
  return acc_lim_y_;
}
inline void Robot::set_acc_lim_y(double value) {
  set_has_acc_lim_y();
  acc_lim_y_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.acc_lim_y)
}

// optional double acc_lim_theta = 7;
inline bool Robot::has_acc_lim_theta() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Robot::set_has_acc_lim_theta() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Robot::clear_has_acc_lim_theta() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Robot::clear_acc_lim_theta() {
  acc_lim_theta_ = 0;
  clear_has_acc_lim_theta();
}
inline double Robot::acc_lim_theta() const {
  // @@protoc_insertion_point(field_get:teb.Robot.acc_lim_theta)
  return acc_lim_theta_;
}
inline void Robot::set_acc_lim_theta(double value) {
  set_has_acc_lim_theta();
  acc_lim_theta_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.acc_lim_theta)
}

// optional double min_turning_radius = 8;
inline bool Robot::has_min_turning_radius() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Robot::set_has_min_turning_radius() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Robot::clear_has_min_turning_radius() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Robot::clear_min_turning_radius() {
  min_turning_radius_ = 0;
  clear_has_min_turning_radius();
}
inline double Robot::min_turning_radius() const {
  // @@protoc_insertion_point(field_get:teb.Robot.min_turning_radius)
  return min_turning_radius_;
}
inline void Robot::set_min_turning_radius(double value) {
  set_has_min_turning_radius();
  min_turning_radius_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.min_turning_radius)
}

// optional double wheelbase = 9;
inline bool Robot::has_wheelbase() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Robot::set_has_wheelbase() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Robot::clear_has_wheelbase() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Robot::clear_wheelbase() {
  wheelbase_ = 0;
  clear_has_wheelbase();
}
inline double Robot::wheelbase() const {
  // @@protoc_insertion_point(field_get:teb.Robot.wheelbase)
  return wheelbase_;
}
inline void Robot::set_wheelbase(double value) {
  set_has_wheelbase();
  wheelbase_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.wheelbase)
}

// optional bool cmd_angle_instead_rotvel = 10;
inline bool Robot::has_cmd_angle_instead_rotvel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Robot::set_has_cmd_angle_instead_rotvel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Robot::clear_has_cmd_angle_instead_rotvel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Robot::clear_cmd_angle_instead_rotvel() {
  cmd_angle_instead_rotvel_ = false;
  clear_has_cmd_angle_instead_rotvel();
}
inline bool Robot::cmd_angle_instead_rotvel() const {
  // @@protoc_insertion_point(field_get:teb.Robot.cmd_angle_instead_rotvel)
  return cmd_angle_instead_rotvel_;
}
inline void Robot::set_cmd_angle_instead_rotvel(bool value) {
  set_has_cmd_angle_instead_rotvel();
  cmd_angle_instead_rotvel_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.cmd_angle_instead_rotvel)
}

// optional bool is_footprint_dynamic = 11;
inline bool Robot::has_is_footprint_dynamic() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Robot::set_has_is_footprint_dynamic() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Robot::clear_has_is_footprint_dynamic() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Robot::clear_is_footprint_dynamic() {
  is_footprint_dynamic_ = false;
  clear_has_is_footprint_dynamic();
}
inline bool Robot::is_footprint_dynamic() const {
  // @@protoc_insertion_point(field_get:teb.Robot.is_footprint_dynamic)
  return is_footprint_dynamic_;
}
inline void Robot::set_is_footprint_dynamic(bool value) {
  set_has_is_footprint_dynamic();
  is_footprint_dynamic_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.is_footprint_dynamic)
}

// optional bool use_proportional_saturation = 12;
inline bool Robot::has_use_proportional_saturation() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Robot::set_has_use_proportional_saturation() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Robot::clear_has_use_proportional_saturation() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Robot::clear_use_proportional_saturation() {
  use_proportional_saturation_ = false;
  clear_has_use_proportional_saturation();
}
inline bool Robot::use_proportional_saturation() const {
  // @@protoc_insertion_point(field_get:teb.Robot.use_proportional_saturation)
  return use_proportional_saturation_;
}
inline void Robot::set_use_proportional_saturation(bool value) {
  set_has_use_proportional_saturation();
  use_proportional_saturation_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.use_proportional_saturation)
}

// optional double transform_tolerance = 13;
inline bool Robot::has_transform_tolerance() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Robot::set_has_transform_tolerance() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Robot::clear_has_transform_tolerance() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Robot::clear_transform_tolerance() {
  transform_tolerance_ = 0;
  clear_has_transform_tolerance();
}
inline double Robot::transform_tolerance() const {
  // @@protoc_insertion_point(field_get:teb.Robot.transform_tolerance)
  return transform_tolerance_;
}
inline void Robot::set_transform_tolerance(double value) {
  set_has_transform_tolerance();
  transform_tolerance_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.transform_tolerance)
}

// optional int32 vehicle_mode = 14;
inline bool Robot::has_vehicle_mode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Robot::set_has_vehicle_mode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Robot::clear_has_vehicle_mode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Robot::clear_vehicle_mode() {
  vehicle_mode_ = 0;
  clear_has_vehicle_mode();
}
inline ::google::protobuf::int32 Robot::vehicle_mode() const {
  // @@protoc_insertion_point(field_get:teb.Robot.vehicle_mode)
  return vehicle_mode_;
}
inline void Robot::set_vehicle_mode(::google::protobuf::int32 value) {
  set_has_vehicle_mode();
  vehicle_mode_ = value;
  // @@protoc_insertion_point(field_set:teb.Robot.vehicle_mode)
}

// -------------------------------------------------------------------

// GoalTolerance

// optional double yaw_goal_tolerance = 1;
inline bool GoalTolerance::has_yaw_goal_tolerance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GoalTolerance::set_has_yaw_goal_tolerance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GoalTolerance::clear_has_yaw_goal_tolerance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GoalTolerance::clear_yaw_goal_tolerance() {
  yaw_goal_tolerance_ = 0;
  clear_has_yaw_goal_tolerance();
}
inline double GoalTolerance::yaw_goal_tolerance() const {
  // @@protoc_insertion_point(field_get:teb.GoalTolerance.yaw_goal_tolerance)
  return yaw_goal_tolerance_;
}
inline void GoalTolerance::set_yaw_goal_tolerance(double value) {
  set_has_yaw_goal_tolerance();
  yaw_goal_tolerance_ = value;
  // @@protoc_insertion_point(field_set:teb.GoalTolerance.yaw_goal_tolerance)
}

// optional double xy_goal_tolerance = 2;
inline bool GoalTolerance::has_xy_goal_tolerance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GoalTolerance::set_has_xy_goal_tolerance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GoalTolerance::clear_has_xy_goal_tolerance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GoalTolerance::clear_xy_goal_tolerance() {
  xy_goal_tolerance_ = 0;
  clear_has_xy_goal_tolerance();
}
inline double GoalTolerance::xy_goal_tolerance() const {
  // @@protoc_insertion_point(field_get:teb.GoalTolerance.xy_goal_tolerance)
  return xy_goal_tolerance_;
}
inline void GoalTolerance::set_xy_goal_tolerance(double value) {
  set_has_xy_goal_tolerance();
  xy_goal_tolerance_ = value;
  // @@protoc_insertion_point(field_set:teb.GoalTolerance.xy_goal_tolerance)
}

// optional bool free_goal_vel = 3;
inline bool GoalTolerance::has_free_goal_vel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GoalTolerance::set_has_free_goal_vel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GoalTolerance::clear_has_free_goal_vel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GoalTolerance::clear_free_goal_vel() {
  free_goal_vel_ = false;
  clear_has_free_goal_vel();
}
inline bool GoalTolerance::free_goal_vel() const {
  // @@protoc_insertion_point(field_get:teb.GoalTolerance.free_goal_vel)
  return free_goal_vel_;
}
inline void GoalTolerance::set_free_goal_vel(bool value) {
  set_has_free_goal_vel();
  free_goal_vel_ = value;
  // @@protoc_insertion_point(field_set:teb.GoalTolerance.free_goal_vel)
}

// optional double trans_stopped_vel = 4;
inline bool GoalTolerance::has_trans_stopped_vel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GoalTolerance::set_has_trans_stopped_vel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GoalTolerance::clear_has_trans_stopped_vel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GoalTolerance::clear_trans_stopped_vel() {
  trans_stopped_vel_ = 0;
  clear_has_trans_stopped_vel();
}
inline double GoalTolerance::trans_stopped_vel() const {
  // @@protoc_insertion_point(field_get:teb.GoalTolerance.trans_stopped_vel)
  return trans_stopped_vel_;
}
inline void GoalTolerance::set_trans_stopped_vel(double value) {
  set_has_trans_stopped_vel();
  trans_stopped_vel_ = value;
  // @@protoc_insertion_point(field_set:teb.GoalTolerance.trans_stopped_vel)
}

// optional double theta_stopped_vel = 5;
inline bool GoalTolerance::has_theta_stopped_vel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GoalTolerance::set_has_theta_stopped_vel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GoalTolerance::clear_has_theta_stopped_vel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GoalTolerance::clear_theta_stopped_vel() {
  theta_stopped_vel_ = 0;
  clear_has_theta_stopped_vel();
}
inline double GoalTolerance::theta_stopped_vel() const {
  // @@protoc_insertion_point(field_get:teb.GoalTolerance.theta_stopped_vel)
  return theta_stopped_vel_;
}
inline void GoalTolerance::set_theta_stopped_vel(double value) {
  set_has_theta_stopped_vel();
  theta_stopped_vel_ = value;
  // @@protoc_insertion_point(field_set:teb.GoalTolerance.theta_stopped_vel)
}

// optional bool complete_global_plan = 6;
inline bool GoalTolerance::has_complete_global_plan() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GoalTolerance::set_has_complete_global_plan() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GoalTolerance::clear_has_complete_global_plan() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GoalTolerance::clear_complete_global_plan() {
  complete_global_plan_ = false;
  clear_has_complete_global_plan();
}
inline bool GoalTolerance::complete_global_plan() const {
  // @@protoc_insertion_point(field_get:teb.GoalTolerance.complete_global_plan)
  return complete_global_plan_;
}
inline void GoalTolerance::set_complete_global_plan(bool value) {
  set_has_complete_global_plan();
  complete_global_plan_ = value;
  // @@protoc_insertion_point(field_set:teb.GoalTolerance.complete_global_plan)
}

// -------------------------------------------------------------------

// Obstacles

// optional double min_obstacle_dist = 1;
inline bool Obstacles::has_min_obstacle_dist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Obstacles::set_has_min_obstacle_dist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Obstacles::clear_has_min_obstacle_dist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Obstacles::clear_min_obstacle_dist() {
  min_obstacle_dist_ = 0;
  clear_has_min_obstacle_dist();
}
inline double Obstacles::min_obstacle_dist() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.min_obstacle_dist)
  return min_obstacle_dist_;
}
inline void Obstacles::set_min_obstacle_dist(double value) {
  set_has_min_obstacle_dist();
  min_obstacle_dist_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.min_obstacle_dist)
}

// optional double inflation_dist = 2;
inline bool Obstacles::has_inflation_dist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Obstacles::set_has_inflation_dist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Obstacles::clear_has_inflation_dist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Obstacles::clear_inflation_dist() {
  inflation_dist_ = 0;
  clear_has_inflation_dist();
}
inline double Obstacles::inflation_dist() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.inflation_dist)
  return inflation_dist_;
}
inline void Obstacles::set_inflation_dist(double value) {
  set_has_inflation_dist();
  inflation_dist_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.inflation_dist)
}

// optional double dynamic_obstacle_inflation_dist = 3;
inline bool Obstacles::has_dynamic_obstacle_inflation_dist() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Obstacles::set_has_dynamic_obstacle_inflation_dist() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Obstacles::clear_has_dynamic_obstacle_inflation_dist() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Obstacles::clear_dynamic_obstacle_inflation_dist() {
  dynamic_obstacle_inflation_dist_ = 0;
  clear_has_dynamic_obstacle_inflation_dist();
}
inline double Obstacles::dynamic_obstacle_inflation_dist() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.dynamic_obstacle_inflation_dist)
  return dynamic_obstacle_inflation_dist_;
}
inline void Obstacles::set_dynamic_obstacle_inflation_dist(double value) {
  set_has_dynamic_obstacle_inflation_dist();
  dynamic_obstacle_inflation_dist_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.dynamic_obstacle_inflation_dist)
}

// optional bool include_dynamic_obstacles = 4;
inline bool Obstacles::has_include_dynamic_obstacles() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Obstacles::set_has_include_dynamic_obstacles() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Obstacles::clear_has_include_dynamic_obstacles() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Obstacles::clear_include_dynamic_obstacles() {
  include_dynamic_obstacles_ = false;
  clear_has_include_dynamic_obstacles();
}
inline bool Obstacles::include_dynamic_obstacles() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.include_dynamic_obstacles)
  return include_dynamic_obstacles_;
}
inline void Obstacles::set_include_dynamic_obstacles(bool value) {
  set_has_include_dynamic_obstacles();
  include_dynamic_obstacles_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.include_dynamic_obstacles)
}

// optional bool include_costmap_obstacles = 5;
inline bool Obstacles::has_include_costmap_obstacles() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Obstacles::set_has_include_costmap_obstacles() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Obstacles::clear_has_include_costmap_obstacles() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Obstacles::clear_include_costmap_obstacles() {
  include_costmap_obstacles_ = false;
  clear_has_include_costmap_obstacles();
}
inline bool Obstacles::include_costmap_obstacles() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.include_costmap_obstacles)
  return include_costmap_obstacles_;
}
inline void Obstacles::set_include_costmap_obstacles(bool value) {
  set_has_include_costmap_obstacles();
  include_costmap_obstacles_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.include_costmap_obstacles)
}

// optional double costmap_obstacles_behind_robot_dist = 6;
inline bool Obstacles::has_costmap_obstacles_behind_robot_dist() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Obstacles::set_has_costmap_obstacles_behind_robot_dist() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Obstacles::clear_has_costmap_obstacles_behind_robot_dist() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Obstacles::clear_costmap_obstacles_behind_robot_dist() {
  costmap_obstacles_behind_robot_dist_ = 0;
  clear_has_costmap_obstacles_behind_robot_dist();
}
inline double Obstacles::costmap_obstacles_behind_robot_dist() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.costmap_obstacles_behind_robot_dist)
  return costmap_obstacles_behind_robot_dist_;
}
inline void Obstacles::set_costmap_obstacles_behind_robot_dist(double value) {
  set_has_costmap_obstacles_behind_robot_dist();
  costmap_obstacles_behind_robot_dist_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.costmap_obstacles_behind_robot_dist)
}

// optional int32 obstacle_poses_affected = 7;
inline bool Obstacles::has_obstacle_poses_affected() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Obstacles::set_has_obstacle_poses_affected() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Obstacles::clear_has_obstacle_poses_affected() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Obstacles::clear_obstacle_poses_affected() {
  obstacle_poses_affected_ = 0;
  clear_has_obstacle_poses_affected();
}
inline ::google::protobuf::int32 Obstacles::obstacle_poses_affected() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.obstacle_poses_affected)
  return obstacle_poses_affected_;
}
inline void Obstacles::set_obstacle_poses_affected(::google::protobuf::int32 value) {
  set_has_obstacle_poses_affected();
  obstacle_poses_affected_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.obstacle_poses_affected)
}

// optional bool legacy_obstacle_association = 8;
inline bool Obstacles::has_legacy_obstacle_association() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Obstacles::set_has_legacy_obstacle_association() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Obstacles::clear_has_legacy_obstacle_association() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Obstacles::clear_legacy_obstacle_association() {
  legacy_obstacle_association_ = false;
  clear_has_legacy_obstacle_association();
}
inline bool Obstacles::legacy_obstacle_association() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.legacy_obstacle_association)
  return legacy_obstacle_association_;
}
inline void Obstacles::set_legacy_obstacle_association(bool value) {
  set_has_legacy_obstacle_association();
  legacy_obstacle_association_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.legacy_obstacle_association)
}

// optional double obstacle_association_force_inclusion_factor = 9;
inline bool Obstacles::has_obstacle_association_force_inclusion_factor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Obstacles::set_has_obstacle_association_force_inclusion_factor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Obstacles::clear_has_obstacle_association_force_inclusion_factor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Obstacles::clear_obstacle_association_force_inclusion_factor() {
  obstacle_association_force_inclusion_factor_ = 0;
  clear_has_obstacle_association_force_inclusion_factor();
}
inline double Obstacles::obstacle_association_force_inclusion_factor() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.obstacle_association_force_inclusion_factor)
  return obstacle_association_force_inclusion_factor_;
}
inline void Obstacles::set_obstacle_association_force_inclusion_factor(double value) {
  set_has_obstacle_association_force_inclusion_factor();
  obstacle_association_force_inclusion_factor_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.obstacle_association_force_inclusion_factor)
}

// optional double obstacle_association_cutoff_factor = 10;
inline bool Obstacles::has_obstacle_association_cutoff_factor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Obstacles::set_has_obstacle_association_cutoff_factor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Obstacles::clear_has_obstacle_association_cutoff_factor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Obstacles::clear_obstacle_association_cutoff_factor() {
  obstacle_association_cutoff_factor_ = 0;
  clear_has_obstacle_association_cutoff_factor();
}
inline double Obstacles::obstacle_association_cutoff_factor() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.obstacle_association_cutoff_factor)
  return obstacle_association_cutoff_factor_;
}
inline void Obstacles::set_obstacle_association_cutoff_factor(double value) {
  set_has_obstacle_association_cutoff_factor();
  obstacle_association_cutoff_factor_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.obstacle_association_cutoff_factor)
}

// optional bool costmap_converter_spin_thread = 11;
inline bool Obstacles::has_costmap_converter_spin_thread() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Obstacles::set_has_costmap_converter_spin_thread() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Obstacles::clear_has_costmap_converter_spin_thread() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Obstacles::clear_costmap_converter_spin_thread() {
  costmap_converter_spin_thread_ = false;
  clear_has_costmap_converter_spin_thread();
}
inline bool Obstacles::costmap_converter_spin_thread() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.costmap_converter_spin_thread)
  return costmap_converter_spin_thread_;
}
inline void Obstacles::set_costmap_converter_spin_thread(bool value) {
  set_has_costmap_converter_spin_thread();
  costmap_converter_spin_thread_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.costmap_converter_spin_thread)
}

// optional int32 costmap_converter_rate = 12;
inline bool Obstacles::has_costmap_converter_rate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Obstacles::set_has_costmap_converter_rate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Obstacles::clear_has_costmap_converter_rate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Obstacles::clear_costmap_converter_rate() {
  costmap_converter_rate_ = 0;
  clear_has_costmap_converter_rate();
}
inline ::google::protobuf::int32 Obstacles::costmap_converter_rate() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.costmap_converter_rate)
  return costmap_converter_rate_;
}
inline void Obstacles::set_costmap_converter_rate(::google::protobuf::int32 value) {
  set_has_costmap_converter_rate();
  costmap_converter_rate_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.costmap_converter_rate)
}

// optional double obstacle_proximity_ratio_max_vel = 13;
inline bool Obstacles::has_obstacle_proximity_ratio_max_vel() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Obstacles::set_has_obstacle_proximity_ratio_max_vel() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Obstacles::clear_has_obstacle_proximity_ratio_max_vel() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Obstacles::clear_obstacle_proximity_ratio_max_vel() {
  obstacle_proximity_ratio_max_vel_ = 0;
  clear_has_obstacle_proximity_ratio_max_vel();
}
inline double Obstacles::obstacle_proximity_ratio_max_vel() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.obstacle_proximity_ratio_max_vel)
  return obstacle_proximity_ratio_max_vel_;
}
inline void Obstacles::set_obstacle_proximity_ratio_max_vel(double value) {
  set_has_obstacle_proximity_ratio_max_vel();
  obstacle_proximity_ratio_max_vel_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.obstacle_proximity_ratio_max_vel)
}

// optional double obstacle_proximity_lower_bound = 14;
inline bool Obstacles::has_obstacle_proximity_lower_bound() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Obstacles::set_has_obstacle_proximity_lower_bound() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Obstacles::clear_has_obstacle_proximity_lower_bound() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Obstacles::clear_obstacle_proximity_lower_bound() {
  obstacle_proximity_lower_bound_ = 0;
  clear_has_obstacle_proximity_lower_bound();
}
inline double Obstacles::obstacle_proximity_lower_bound() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.obstacle_proximity_lower_bound)
  return obstacle_proximity_lower_bound_;
}
inline void Obstacles::set_obstacle_proximity_lower_bound(double value) {
  set_has_obstacle_proximity_lower_bound();
  obstacle_proximity_lower_bound_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.obstacle_proximity_lower_bound)
}

// optional double obstacle_proximity_upper_bound = 15;
inline bool Obstacles::has_obstacle_proximity_upper_bound() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Obstacles::set_has_obstacle_proximity_upper_bound() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Obstacles::clear_has_obstacle_proximity_upper_bound() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Obstacles::clear_obstacle_proximity_upper_bound() {
  obstacle_proximity_upper_bound_ = 0;
  clear_has_obstacle_proximity_upper_bound();
}
inline double Obstacles::obstacle_proximity_upper_bound() const {
  // @@protoc_insertion_point(field_get:teb.Obstacles.obstacle_proximity_upper_bound)
  return obstacle_proximity_upper_bound_;
}
inline void Obstacles::set_obstacle_proximity_upper_bound(double value) {
  set_has_obstacle_proximity_upper_bound();
  obstacle_proximity_upper_bound_ = value;
  // @@protoc_insertion_point(field_set:teb.Obstacles.obstacle_proximity_upper_bound)
}

// -------------------------------------------------------------------

// Optimization

// optional int32 no_inner_iterations = 1;
inline bool Optimization::has_no_inner_iterations() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Optimization::set_has_no_inner_iterations() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Optimization::clear_has_no_inner_iterations() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Optimization::clear_no_inner_iterations() {
  no_inner_iterations_ = 0;
  clear_has_no_inner_iterations();
}
inline ::google::protobuf::int32 Optimization::no_inner_iterations() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.no_inner_iterations)
  return no_inner_iterations_;
}
inline void Optimization::set_no_inner_iterations(::google::protobuf::int32 value) {
  set_has_no_inner_iterations();
  no_inner_iterations_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.no_inner_iterations)
}

// optional int32 no_outer_iterations = 2;
inline bool Optimization::has_no_outer_iterations() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Optimization::set_has_no_outer_iterations() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Optimization::clear_has_no_outer_iterations() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Optimization::clear_no_outer_iterations() {
  no_outer_iterations_ = 0;
  clear_has_no_outer_iterations();
}
inline ::google::protobuf::int32 Optimization::no_outer_iterations() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.no_outer_iterations)
  return no_outer_iterations_;
}
inline void Optimization::set_no_outer_iterations(::google::protobuf::int32 value) {
  set_has_no_outer_iterations();
  no_outer_iterations_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.no_outer_iterations)
}

// optional bool optimization_activate = 3;
inline bool Optimization::has_optimization_activate() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Optimization::set_has_optimization_activate() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Optimization::clear_has_optimization_activate() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Optimization::clear_optimization_activate() {
  optimization_activate_ = false;
  clear_has_optimization_activate();
}
inline bool Optimization::optimization_activate() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.optimization_activate)
  return optimization_activate_;
}
inline void Optimization::set_optimization_activate(bool value) {
  set_has_optimization_activate();
  optimization_activate_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.optimization_activate)
}

// optional bool optimization_verbose = 4;
inline bool Optimization::has_optimization_verbose() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Optimization::set_has_optimization_verbose() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Optimization::clear_has_optimization_verbose() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Optimization::clear_optimization_verbose() {
  optimization_verbose_ = false;
  clear_has_optimization_verbose();
}
inline bool Optimization::optimization_verbose() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.optimization_verbose)
  return optimization_verbose_;
}
inline void Optimization::set_optimization_verbose(bool value) {
  set_has_optimization_verbose();
  optimization_verbose_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.optimization_verbose)
}

// optional double penalty_epsilon = 5;
inline bool Optimization::has_penalty_epsilon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Optimization::set_has_penalty_epsilon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Optimization::clear_has_penalty_epsilon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Optimization::clear_penalty_epsilon() {
  penalty_epsilon_ = 0;
  clear_has_penalty_epsilon();
}
inline double Optimization::penalty_epsilon() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.penalty_epsilon)
  return penalty_epsilon_;
}
inline void Optimization::set_penalty_epsilon(double value) {
  set_has_penalty_epsilon();
  penalty_epsilon_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.penalty_epsilon)
}

// optional double weight_max_vel_x = 6;
inline bool Optimization::has_weight_max_vel_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Optimization::set_has_weight_max_vel_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Optimization::clear_has_weight_max_vel_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Optimization::clear_weight_max_vel_x() {
  weight_max_vel_x_ = 0;
  clear_has_weight_max_vel_x();
}
inline double Optimization::weight_max_vel_x() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_max_vel_x)
  return weight_max_vel_x_;
}
inline void Optimization::set_weight_max_vel_x(double value) {
  set_has_weight_max_vel_x();
  weight_max_vel_x_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_max_vel_x)
}

// optional double weight_max_vel_y = 7;
inline bool Optimization::has_weight_max_vel_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Optimization::set_has_weight_max_vel_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Optimization::clear_has_weight_max_vel_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Optimization::clear_weight_max_vel_y() {
  weight_max_vel_y_ = 0;
  clear_has_weight_max_vel_y();
}
inline double Optimization::weight_max_vel_y() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_max_vel_y)
  return weight_max_vel_y_;
}
inline void Optimization::set_weight_max_vel_y(double value) {
  set_has_weight_max_vel_y();
  weight_max_vel_y_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_max_vel_y)
}

// optional double weight_max_vel_theta = 8;
inline bool Optimization::has_weight_max_vel_theta() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Optimization::set_has_weight_max_vel_theta() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Optimization::clear_has_weight_max_vel_theta() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Optimization::clear_weight_max_vel_theta() {
  weight_max_vel_theta_ = 0;
  clear_has_weight_max_vel_theta();
}
inline double Optimization::weight_max_vel_theta() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_max_vel_theta)
  return weight_max_vel_theta_;
}
inline void Optimization::set_weight_max_vel_theta(double value) {
  set_has_weight_max_vel_theta();
  weight_max_vel_theta_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_max_vel_theta)
}

// optional double weight_acc_lim_x = 9;
inline bool Optimization::has_weight_acc_lim_x() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_x() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Optimization::clear_has_weight_acc_lim_x() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Optimization::clear_weight_acc_lim_x() {
  weight_acc_lim_x_ = 0;
  clear_has_weight_acc_lim_x();
}
inline double Optimization::weight_acc_lim_x() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_acc_lim_x)
  return weight_acc_lim_x_;
}
inline void Optimization::set_weight_acc_lim_x(double value) {
  set_has_weight_acc_lim_x();
  weight_acc_lim_x_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_acc_lim_x)
}

// optional double weight_acc_lim_y = 10;
inline bool Optimization::has_weight_acc_lim_y() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_y() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Optimization::clear_has_weight_acc_lim_y() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Optimization::clear_weight_acc_lim_y() {
  weight_acc_lim_y_ = 0;
  clear_has_weight_acc_lim_y();
}
inline double Optimization::weight_acc_lim_y() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_acc_lim_y)
  return weight_acc_lim_y_;
}
inline void Optimization::set_weight_acc_lim_y(double value) {
  set_has_weight_acc_lim_y();
  weight_acc_lim_y_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_acc_lim_y)
}

// optional double weight_acc_lim_theta = 11;
inline bool Optimization::has_weight_acc_lim_theta() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Optimization::set_has_weight_acc_lim_theta() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Optimization::clear_has_weight_acc_lim_theta() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Optimization::clear_weight_acc_lim_theta() {
  weight_acc_lim_theta_ = 0;
  clear_has_weight_acc_lim_theta();
}
inline double Optimization::weight_acc_lim_theta() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_acc_lim_theta)
  return weight_acc_lim_theta_;
}
inline void Optimization::set_weight_acc_lim_theta(double value) {
  set_has_weight_acc_lim_theta();
  weight_acc_lim_theta_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_acc_lim_theta)
}

// optional double weight_kinematics_nh = 12;
inline bool Optimization::has_weight_kinematics_nh() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Optimization::set_has_weight_kinematics_nh() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Optimization::clear_has_weight_kinematics_nh() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Optimization::clear_weight_kinematics_nh() {
  weight_kinematics_nh_ = 0;
  clear_has_weight_kinematics_nh();
}
inline double Optimization::weight_kinematics_nh() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_kinematics_nh)
  return weight_kinematics_nh_;
}
inline void Optimization::set_weight_kinematics_nh(double value) {
  set_has_weight_kinematics_nh();
  weight_kinematics_nh_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_kinematics_nh)
}

// optional double weight_kinematics_forward_drive = 13;
inline bool Optimization::has_weight_kinematics_forward_drive() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Optimization::set_has_weight_kinematics_forward_drive() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Optimization::clear_has_weight_kinematics_forward_drive() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Optimization::clear_weight_kinematics_forward_drive() {
  weight_kinematics_forward_drive_ = 0;
  clear_has_weight_kinematics_forward_drive();
}
inline double Optimization::weight_kinematics_forward_drive() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_kinematics_forward_drive)
  return weight_kinematics_forward_drive_;
}
inline void Optimization::set_weight_kinematics_forward_drive(double value) {
  set_has_weight_kinematics_forward_drive();
  weight_kinematics_forward_drive_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_kinematics_forward_drive)
}

// optional double weight_kinematics_turning_radius = 14;
inline bool Optimization::has_weight_kinematics_turning_radius() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Optimization::set_has_weight_kinematics_turning_radius() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Optimization::clear_has_weight_kinematics_turning_radius() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Optimization::clear_weight_kinematics_turning_radius() {
  weight_kinematics_turning_radius_ = 0;
  clear_has_weight_kinematics_turning_radius();
}
inline double Optimization::weight_kinematics_turning_radius() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_kinematics_turning_radius)
  return weight_kinematics_turning_radius_;
}
inline void Optimization::set_weight_kinematics_turning_radius(double value) {
  set_has_weight_kinematics_turning_radius();
  weight_kinematics_turning_radius_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_kinematics_turning_radius)
}

// optional double weight_optimaltime = 15;
inline bool Optimization::has_weight_optimaltime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Optimization::set_has_weight_optimaltime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Optimization::clear_has_weight_optimaltime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Optimization::clear_weight_optimaltime() {
  weight_optimaltime_ = 0;
  clear_has_weight_optimaltime();
}
inline double Optimization::weight_optimaltime() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_optimaltime)
  return weight_optimaltime_;
}
inline void Optimization::set_weight_optimaltime(double value) {
  set_has_weight_optimaltime();
  weight_optimaltime_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_optimaltime)
}

// optional double weight_shortest_path = 16;
inline bool Optimization::has_weight_shortest_path() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Optimization::set_has_weight_shortest_path() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Optimization::clear_has_weight_shortest_path() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Optimization::clear_weight_shortest_path() {
  weight_shortest_path_ = 0;
  clear_has_weight_shortest_path();
}
inline double Optimization::weight_shortest_path() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_shortest_path)
  return weight_shortest_path_;
}
inline void Optimization::set_weight_shortest_path(double value) {
  set_has_weight_shortest_path();
  weight_shortest_path_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_shortest_path)
}

// optional double weight_obstacle = 17;
inline bool Optimization::has_weight_obstacle() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Optimization::set_has_weight_obstacle() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Optimization::clear_has_weight_obstacle() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Optimization::clear_weight_obstacle() {
  weight_obstacle_ = 0;
  clear_has_weight_obstacle();
}
inline double Optimization::weight_obstacle() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_obstacle)
  return weight_obstacle_;
}
inline void Optimization::set_weight_obstacle(double value) {
  set_has_weight_obstacle();
  weight_obstacle_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_obstacle)
}

// optional double weight_inflation = 18;
inline bool Optimization::has_weight_inflation() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Optimization::set_has_weight_inflation() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Optimization::clear_has_weight_inflation() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Optimization::clear_weight_inflation() {
  weight_inflation_ = 0;
  clear_has_weight_inflation();
}
inline double Optimization::weight_inflation() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_inflation)
  return weight_inflation_;
}
inline void Optimization::set_weight_inflation(double value) {
  set_has_weight_inflation();
  weight_inflation_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_inflation)
}

// optional double weight_dynamic_obstacle = 19;
inline bool Optimization::has_weight_dynamic_obstacle() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Optimization::set_has_weight_dynamic_obstacle() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Optimization::clear_has_weight_dynamic_obstacle() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Optimization::clear_weight_dynamic_obstacle() {
  weight_dynamic_obstacle_ = 0;
  clear_has_weight_dynamic_obstacle();
}
inline double Optimization::weight_dynamic_obstacle() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_dynamic_obstacle)
  return weight_dynamic_obstacle_;
}
inline void Optimization::set_weight_dynamic_obstacle(double value) {
  set_has_weight_dynamic_obstacle();
  weight_dynamic_obstacle_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_dynamic_obstacle)
}

// optional double weight_dynamic_obstacle_inflation = 20;
inline bool Optimization::has_weight_dynamic_obstacle_inflation() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Optimization::set_has_weight_dynamic_obstacle_inflation() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Optimization::clear_has_weight_dynamic_obstacle_inflation() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Optimization::clear_weight_dynamic_obstacle_inflation() {
  weight_dynamic_obstacle_inflation_ = 0;
  clear_has_weight_dynamic_obstacle_inflation();
}
inline double Optimization::weight_dynamic_obstacle_inflation() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_dynamic_obstacle_inflation)
  return weight_dynamic_obstacle_inflation_;
}
inline void Optimization::set_weight_dynamic_obstacle_inflation(double value) {
  set_has_weight_dynamic_obstacle_inflation();
  weight_dynamic_obstacle_inflation_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_dynamic_obstacle_inflation)
}

// optional double weight_velocity_obstacle_ratio = 21;
inline bool Optimization::has_weight_velocity_obstacle_ratio() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Optimization::set_has_weight_velocity_obstacle_ratio() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Optimization::clear_has_weight_velocity_obstacle_ratio() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Optimization::clear_weight_velocity_obstacle_ratio() {
  weight_velocity_obstacle_ratio_ = 0;
  clear_has_weight_velocity_obstacle_ratio();
}
inline double Optimization::weight_velocity_obstacle_ratio() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_velocity_obstacle_ratio)
  return weight_velocity_obstacle_ratio_;
}
inline void Optimization::set_weight_velocity_obstacle_ratio(double value) {
  set_has_weight_velocity_obstacle_ratio();
  weight_velocity_obstacle_ratio_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_velocity_obstacle_ratio)
}

// optional double weight_viapoint = 22;
inline bool Optimization::has_weight_viapoint() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Optimization::set_has_weight_viapoint() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Optimization::clear_has_weight_viapoint() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Optimization::clear_weight_viapoint() {
  weight_viapoint_ = 0;
  clear_has_weight_viapoint();
}
inline double Optimization::weight_viapoint() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_viapoint)
  return weight_viapoint_;
}
inline void Optimization::set_weight_viapoint(double value) {
  set_has_weight_viapoint();
  weight_viapoint_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_viapoint)
}

// optional double weight_prefer_rotdir = 23;
inline bool Optimization::has_weight_prefer_rotdir() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Optimization::set_has_weight_prefer_rotdir() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Optimization::clear_has_weight_prefer_rotdir() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Optimization::clear_weight_prefer_rotdir() {
  weight_prefer_rotdir_ = 0;
  clear_has_weight_prefer_rotdir();
}
inline double Optimization::weight_prefer_rotdir() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_prefer_rotdir)
  return weight_prefer_rotdir_;
}
inline void Optimization::set_weight_prefer_rotdir(double value) {
  set_has_weight_prefer_rotdir();
  weight_prefer_rotdir_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_prefer_rotdir)
}

// optional double weight_adapt_factor = 24;
inline bool Optimization::has_weight_adapt_factor() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Optimization::set_has_weight_adapt_factor() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Optimization::clear_has_weight_adapt_factor() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Optimization::clear_weight_adapt_factor() {
  weight_adapt_factor_ = 0;
  clear_has_weight_adapt_factor();
}
inline double Optimization::weight_adapt_factor() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.weight_adapt_factor)
  return weight_adapt_factor_;
}
inline void Optimization::set_weight_adapt_factor(double value) {
  set_has_weight_adapt_factor();
  weight_adapt_factor_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.weight_adapt_factor)
}

// optional double obstacle_cost_exponent = 25;
inline bool Optimization::has_obstacle_cost_exponent() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Optimization::set_has_obstacle_cost_exponent() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Optimization::clear_has_obstacle_cost_exponent() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Optimization::clear_obstacle_cost_exponent() {
  obstacle_cost_exponent_ = 0;
  clear_has_obstacle_cost_exponent();
}
inline double Optimization::obstacle_cost_exponent() const {
  // @@protoc_insertion_point(field_get:teb.Optimization.obstacle_cost_exponent)
  return obstacle_cost_exponent_;
}
inline void Optimization::set_obstacle_cost_exponent(double value) {
  set_has_obstacle_cost_exponent();
  obstacle_cost_exponent_ = value;
  // @@protoc_insertion_point(field_set:teb.Optimization.obstacle_cost_exponent)
}

// -------------------------------------------------------------------

// TebConfig

// optional .teb.Trajectory trajectory = 1;
inline bool TebConfig::has_trajectory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TebConfig::set_has_trajectory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TebConfig::clear_has_trajectory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TebConfig::clear_trajectory() {
  if (trajectory_ != NULL) trajectory_->Clear();
  clear_has_trajectory();
}
inline const ::teb::Trajectory& TebConfig::trajectory() const {
  const ::teb::Trajectory* p = trajectory_;
  // @@protoc_insertion_point(field_get:teb.TebConfig.trajectory)
  return p != NULL ? *p : *reinterpret_cast<const ::teb::Trajectory*>(
      &::teb::_Trajectory_default_instance_);
}
inline ::teb::Trajectory* TebConfig::release_trajectory() {
  // @@protoc_insertion_point(field_release:teb.TebConfig.trajectory)
  clear_has_trajectory();
  ::teb::Trajectory* temp = trajectory_;
  trajectory_ = NULL;
  return temp;
}
inline ::teb::Trajectory* TebConfig::mutable_trajectory() {
  set_has_trajectory();
  if (trajectory_ == NULL) {
    trajectory_ = new ::teb::Trajectory;
  }
  // @@protoc_insertion_point(field_mutable:teb.TebConfig.trajectory)
  return trajectory_;
}
inline void TebConfig::set_allocated_trajectory(::teb::Trajectory* trajectory) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trajectory_;
  }
  if (trajectory) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trajectory = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trajectory, submessage_arena);
    }
    set_has_trajectory();
  } else {
    clear_has_trajectory();
  }
  trajectory_ = trajectory;
  // @@protoc_insertion_point(field_set_allocated:teb.TebConfig.trajectory)
}

// optional .teb.Robot robot = 2;
inline bool TebConfig::has_robot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TebConfig::set_has_robot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TebConfig::clear_has_robot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TebConfig::clear_robot() {
  if (robot_ != NULL) robot_->Clear();
  clear_has_robot();
}
inline const ::teb::Robot& TebConfig::robot() const {
  const ::teb::Robot* p = robot_;
  // @@protoc_insertion_point(field_get:teb.TebConfig.robot)
  return p != NULL ? *p : *reinterpret_cast<const ::teb::Robot*>(
      &::teb::_Robot_default_instance_);
}
inline ::teb::Robot* TebConfig::release_robot() {
  // @@protoc_insertion_point(field_release:teb.TebConfig.robot)
  clear_has_robot();
  ::teb::Robot* temp = robot_;
  robot_ = NULL;
  return temp;
}
inline ::teb::Robot* TebConfig::mutable_robot() {
  set_has_robot();
  if (robot_ == NULL) {
    robot_ = new ::teb::Robot;
  }
  // @@protoc_insertion_point(field_mutable:teb.TebConfig.robot)
  return robot_;
}
inline void TebConfig::set_allocated_robot(::teb::Robot* robot) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete robot_;
  }
  if (robot) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      robot = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robot, submessage_arena);
    }
    set_has_robot();
  } else {
    clear_has_robot();
  }
  robot_ = robot;
  // @@protoc_insertion_point(field_set_allocated:teb.TebConfig.robot)
}

// optional .teb.GoalTolerance goal_tolerance = 3;
inline bool TebConfig::has_goal_tolerance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TebConfig::set_has_goal_tolerance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TebConfig::clear_has_goal_tolerance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TebConfig::clear_goal_tolerance() {
  if (goal_tolerance_ != NULL) goal_tolerance_->Clear();
  clear_has_goal_tolerance();
}
inline const ::teb::GoalTolerance& TebConfig::goal_tolerance() const {
  const ::teb::GoalTolerance* p = goal_tolerance_;
  // @@protoc_insertion_point(field_get:teb.TebConfig.goal_tolerance)
  return p != NULL ? *p : *reinterpret_cast<const ::teb::GoalTolerance*>(
      &::teb::_GoalTolerance_default_instance_);
}
inline ::teb::GoalTolerance* TebConfig::release_goal_tolerance() {
  // @@protoc_insertion_point(field_release:teb.TebConfig.goal_tolerance)
  clear_has_goal_tolerance();
  ::teb::GoalTolerance* temp = goal_tolerance_;
  goal_tolerance_ = NULL;
  return temp;
}
inline ::teb::GoalTolerance* TebConfig::mutable_goal_tolerance() {
  set_has_goal_tolerance();
  if (goal_tolerance_ == NULL) {
    goal_tolerance_ = new ::teb::GoalTolerance;
  }
  // @@protoc_insertion_point(field_mutable:teb.TebConfig.goal_tolerance)
  return goal_tolerance_;
}
inline void TebConfig::set_allocated_goal_tolerance(::teb::GoalTolerance* goal_tolerance) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete goal_tolerance_;
  }
  if (goal_tolerance) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      goal_tolerance = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, goal_tolerance, submessage_arena);
    }
    set_has_goal_tolerance();
  } else {
    clear_has_goal_tolerance();
  }
  goal_tolerance_ = goal_tolerance;
  // @@protoc_insertion_point(field_set_allocated:teb.TebConfig.goal_tolerance)
}

// optional .teb.Obstacles obstacles = 4;
inline bool TebConfig::has_obstacles() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TebConfig::set_has_obstacles() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TebConfig::clear_has_obstacles() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TebConfig::clear_obstacles() {
  if (obstacles_ != NULL) obstacles_->Clear();
  clear_has_obstacles();
}
inline const ::teb::Obstacles& TebConfig::obstacles() const {
  const ::teb::Obstacles* p = obstacles_;
  // @@protoc_insertion_point(field_get:teb.TebConfig.obstacles)
  return p != NULL ? *p : *reinterpret_cast<const ::teb::Obstacles*>(
      &::teb::_Obstacles_default_instance_);
}
inline ::teb::Obstacles* TebConfig::release_obstacles() {
  // @@protoc_insertion_point(field_release:teb.TebConfig.obstacles)
  clear_has_obstacles();
  ::teb::Obstacles* temp = obstacles_;
  obstacles_ = NULL;
  return temp;
}
inline ::teb::Obstacles* TebConfig::mutable_obstacles() {
  set_has_obstacles();
  if (obstacles_ == NULL) {
    obstacles_ = new ::teb::Obstacles;
  }
  // @@protoc_insertion_point(field_mutable:teb.TebConfig.obstacles)
  return obstacles_;
}
inline void TebConfig::set_allocated_obstacles(::teb::Obstacles* obstacles) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete obstacles_;
  }
  if (obstacles) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      obstacles = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, obstacles, submessage_arena);
    }
    set_has_obstacles();
  } else {
    clear_has_obstacles();
  }
  obstacles_ = obstacles;
  // @@protoc_insertion_point(field_set_allocated:teb.TebConfig.obstacles)
}

// optional .teb.Optimization optim = 5;
inline bool TebConfig::has_optim() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TebConfig::set_has_optim() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TebConfig::clear_has_optim() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TebConfig::clear_optim() {
  if (optim_ != NULL) optim_->Clear();
  clear_has_optim();
}
inline const ::teb::Optimization& TebConfig::optim() const {
  const ::teb::Optimization* p = optim_;
  // @@protoc_insertion_point(field_get:teb.TebConfig.optim)
  return p != NULL ? *p : *reinterpret_cast<const ::teb::Optimization*>(
      &::teb::_Optimization_default_instance_);
}
inline ::teb::Optimization* TebConfig::release_optim() {
  // @@protoc_insertion_point(field_release:teb.TebConfig.optim)
  clear_has_optim();
  ::teb::Optimization* temp = optim_;
  optim_ = NULL;
  return temp;
}
inline ::teb::Optimization* TebConfig::mutable_optim() {
  set_has_optim();
  if (optim_ == NULL) {
    optim_ = new ::teb::Optimization;
  }
  // @@protoc_insertion_point(field_mutable:teb.TebConfig.optim)
  return optim_;
}
inline void TebConfig::set_allocated_optim(::teb::Optimization* optim) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete optim_;
  }
  if (optim) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      optim = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, optim, submessage_arena);
    }
    set_has_optim();
  } else {
    clear_has_optim();
  }
  optim_ = optim;
  // @@protoc_insertion_point(field_set_allocated:teb.TebConfig.optim)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace teb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_planner_2fteb_5fconfig_2eproto__INCLUDED
