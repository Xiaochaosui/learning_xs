// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: business/route_record_request.proto

#ifndef PROTOBUF_business_2froute_5frecord_5frequest_2eproto__INCLUDED
#define PROTOBUF_business_2froute_5frecord_5frequest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "base/header.pb.h"
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)

namespace protobuf_business_2froute_5frecord_5frequest_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRouteRecordRequestImpl();
void InitDefaultsRouteRecordRequest();
void InitDefaultsRecordControlImpl();
void InitDefaultsRecordControl();
void InitDefaultsRouteRecordAttributeImpl();
void InitDefaultsRouteRecordAttribute();
void InitDefaultsAttributeImpl();
void InitDefaultsAttribute();
inline void InitDefaults() {
  InitDefaultsRouteRecordRequest();
  InitDefaultsRecordControl();
  InitDefaultsRouteRecordAttribute();
  InitDefaultsAttribute();
}
}  // namespace protobuf_business_2froute_5frecord_5frequest_2eproto
namespace xsproto {
namespace communication {
class Attribute;
class AttributeDefaultTypeInternal;
extern AttributeDefaultTypeInternal _Attribute_default_instance_;
class RecordControl;
class RecordControlDefaultTypeInternal;
extern RecordControlDefaultTypeInternal _RecordControl_default_instance_;
class RouteRecordAttribute;
class RouteRecordAttributeDefaultTypeInternal;
extern RouteRecordAttributeDefaultTypeInternal _RouteRecordAttribute_default_instance_;
class RouteRecordRequest;
class RouteRecordRequestDefaultTypeInternal;
extern RouteRecordRequestDefaultTypeInternal _RouteRecordRequest_default_instance_;
}  // namespace communication
}  // namespace xsproto
namespace xsproto {
namespace communication {

enum RecordControl_ControlType {
  RecordControl_ControlType_START_RECORD = 0,
  RecordControl_ControlType_STOP_RECORD = 1,
  RecordControl_ControlType_SAVE_RECORD = 2,
  RecordControl_ControlType_PAUSE_RECORD = 3,
  RecordControl_ControlType_RESUME_RECORD = 4,
  RecordControl_ControlType_RecordControl_ControlType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RecordControl_ControlType_RecordControl_ControlType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RecordControl_ControlType_IsValid(int value);
const RecordControl_ControlType RecordControl_ControlType_ControlType_MIN = RecordControl_ControlType_START_RECORD;
const RecordControl_ControlType RecordControl_ControlType_ControlType_MAX = RecordControl_ControlType_RESUME_RECORD;
const int RecordControl_ControlType_ControlType_ARRAYSIZE = RecordControl_ControlType_ControlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecordControl_ControlType_descriptor();
inline const ::std::string& RecordControl_ControlType_Name(RecordControl_ControlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecordControl_ControlType_descriptor(), value);
}
inline bool RecordControl_ControlType_Parse(
    const ::std::string& name, RecordControl_ControlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecordControl_ControlType>(
    RecordControl_ControlType_descriptor(), name, value);
}
enum RouteRecordAttribute_ActionType {
  RouteRecordAttribute_ActionType_START = 0,
  RouteRecordAttribute_ActionType_STOP = 1,
  RouteRecordAttribute_ActionType_RouteRecordAttribute_ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RouteRecordAttribute_ActionType_RouteRecordAttribute_ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RouteRecordAttribute_ActionType_IsValid(int value);
const RouteRecordAttribute_ActionType RouteRecordAttribute_ActionType_ActionType_MIN = RouteRecordAttribute_ActionType_START;
const RouteRecordAttribute_ActionType RouteRecordAttribute_ActionType_ActionType_MAX = RouteRecordAttribute_ActionType_STOP;
const int RouteRecordAttribute_ActionType_ActionType_ARRAYSIZE = RouteRecordAttribute_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RouteRecordAttribute_ActionType_descriptor();
inline const ::std::string& RouteRecordAttribute_ActionType_Name(RouteRecordAttribute_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RouteRecordAttribute_ActionType_descriptor(), value);
}
inline bool RouteRecordAttribute_ActionType_Parse(
    const ::std::string& name, RouteRecordAttribute_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RouteRecordAttribute_ActionType>(
    RouteRecordAttribute_ActionType_descriptor(), name, value);
}
// ===================================================================

class RouteRecordRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.communication.RouteRecordRequest) */ {
 public:
  RouteRecordRequest();
  virtual ~RouteRecordRequest();

  RouteRecordRequest(const RouteRecordRequest& from);

  inline RouteRecordRequest& operator=(const RouteRecordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteRecordRequest(RouteRecordRequest&& from) noexcept
    : RouteRecordRequest() {
    *this = ::std::move(from);
  }

  inline RouteRecordRequest& operator=(RouteRecordRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteRecordRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteRecordRequest* internal_default_instance() {
    return reinterpret_cast<const RouteRecordRequest*>(
               &_RouteRecordRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RouteRecordRequest* other);
  friend void swap(RouteRecordRequest& a, RouteRecordRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteRecordRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteRecordRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteRecordRequest& from);
  void MergeFrom(const RouteRecordRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteRecordRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xsproto.base.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xsproto::base::Header& header() const;
  ::xsproto::base::Header* release_header();
  ::xsproto::base::Header* mutable_header();
  void set_allocated_header(::xsproto::base::Header* header);

  // .google.protobuf.Any msg_content = 5;
  bool has_msg_content() const;
  void clear_msg_content();
  static const int kMsgContentFieldNumber = 5;
  const ::google::protobuf::Any& msg_content() const;
  ::google::protobuf::Any* release_msg_content();
  ::google::protobuf::Any* mutable_msg_content();
  void set_allocated_msg_content(::google::protobuf::Any* msg_content);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int32 seq_num = 3;
  void clear_seq_num();
  static const int kSeqNumFieldNumber = 3;
  ::google::protobuf::int32 seq_num() const;
  void set_seq_num(::google::protobuf::int32 value);

  // int32 msg_code = 4;
  void clear_msg_code();
  static const int kMsgCodeFieldNumber = 4;
  ::google::protobuf::int32 msg_code() const;
  void set_msg_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.communication.RouteRecordRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xsproto::base::Header* header_;
  ::google::protobuf::Any* msg_content_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 seq_num_;
  ::google::protobuf::int32 msg_code_;
  mutable int _cached_size_;
  friend struct ::protobuf_business_2froute_5frecord_5frequest_2eproto::TableStruct;
  friend void ::protobuf_business_2froute_5frecord_5frequest_2eproto::InitDefaultsRouteRecordRequestImpl();
};
// -------------------------------------------------------------------

class RecordControl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.communication.RecordControl) */ {
 public:
  RecordControl();
  virtual ~RecordControl();

  RecordControl(const RecordControl& from);

  inline RecordControl& operator=(const RecordControl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecordControl(RecordControl&& from) noexcept
    : RecordControl() {
    *this = ::std::move(from);
  }

  inline RecordControl& operator=(RecordControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordControl* internal_default_instance() {
    return reinterpret_cast<const RecordControl*>(
               &_RecordControl_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RecordControl* other);
  friend void swap(RecordControl& a, RecordControl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecordControl* New() const PROTOBUF_FINAL { return New(NULL); }

  RecordControl* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RecordControl& from);
  void MergeFrom(const RecordControl& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RecordControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RecordControl_ControlType ControlType;
  static const ControlType START_RECORD =
    RecordControl_ControlType_START_RECORD;
  static const ControlType STOP_RECORD =
    RecordControl_ControlType_STOP_RECORD;
  static const ControlType SAVE_RECORD =
    RecordControl_ControlType_SAVE_RECORD;
  static const ControlType PAUSE_RECORD =
    RecordControl_ControlType_PAUSE_RECORD;
  static const ControlType RESUME_RECORD =
    RecordControl_ControlType_RESUME_RECORD;
  static inline bool ControlType_IsValid(int value) {
    return RecordControl_ControlType_IsValid(value);
  }
  static const ControlType ControlType_MIN =
    RecordControl_ControlType_ControlType_MIN;
  static const ControlType ControlType_MAX =
    RecordControl_ControlType_ControlType_MAX;
  static const int ControlType_ARRAYSIZE =
    RecordControl_ControlType_ControlType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ControlType_descriptor() {
    return RecordControl_ControlType_descriptor();
  }
  static inline const ::std::string& ControlType_Name(ControlType value) {
    return RecordControl_ControlType_Name(value);
  }
  static inline bool ControlType_Parse(const ::std::string& name,
      ControlType* value) {
    return RecordControl_ControlType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string save_path = 3;
  void clear_save_path();
  static const int kSavePathFieldNumber = 3;
  const ::std::string& save_path() const;
  void set_save_path(const ::std::string& value);
  #if LANG_CXX11
  void set_save_path(::std::string&& value);
  #endif
  void set_save_path(const char* value);
  void set_save_path(const char* value, size_t size);
  ::std::string* mutable_save_path();
  ::std::string* release_save_path();
  void set_allocated_save_path(::std::string* save_path);

  // string path_name = 4;
  void clear_path_name();
  static const int kPathNameFieldNumber = 4;
  const ::std::string& path_name() const;
  void set_path_name(const ::std::string& value);
  #if LANG_CXX11
  void set_path_name(::std::string&& value);
  #endif
  void set_path_name(const char* value);
  void set_path_name(const char* value, size_t size);
  ::std::string* mutable_path_name();
  ::std::string* release_path_name();
  void set_allocated_path_name(::std::string* path_name);

  // int64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // .xsproto.communication.RecordControl.ControlType control_type = 2;
  void clear_control_type();
  static const int kControlTypeFieldNumber = 2;
  ::xsproto::communication::RecordControl_ControlType control_type() const;
  void set_control_type(::xsproto::communication::RecordControl_ControlType value);

  // @@protoc_insertion_point(class_scope:xsproto.communication.RecordControl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr save_path_;
  ::google::protobuf::internal::ArenaStringPtr path_name_;
  ::google::protobuf::int64 time_;
  int control_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_business_2froute_5frecord_5frequest_2eproto::TableStruct;
  friend void ::protobuf_business_2froute_5frecord_5frequest_2eproto::InitDefaultsRecordControlImpl();
};
// -------------------------------------------------------------------

class RouteRecordAttribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.communication.RouteRecordAttribute) */ {
 public:
  RouteRecordAttribute();
  virtual ~RouteRecordAttribute();

  RouteRecordAttribute(const RouteRecordAttribute& from);

  inline RouteRecordAttribute& operator=(const RouteRecordAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteRecordAttribute(RouteRecordAttribute&& from) noexcept
    : RouteRecordAttribute() {
    *this = ::std::move(from);
  }

  inline RouteRecordAttribute& operator=(RouteRecordAttribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteRecordAttribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteRecordAttribute* internal_default_instance() {
    return reinterpret_cast<const RouteRecordAttribute*>(
               &_RouteRecordAttribute_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RouteRecordAttribute* other);
  friend void swap(RouteRecordAttribute& a, RouteRecordAttribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteRecordAttribute* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteRecordAttribute* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteRecordAttribute& from);
  void MergeFrom(const RouteRecordAttribute& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteRecordAttribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RouteRecordAttribute_ActionType ActionType;
  static const ActionType START =
    RouteRecordAttribute_ActionType_START;
  static const ActionType STOP =
    RouteRecordAttribute_ActionType_STOP;
  static inline bool ActionType_IsValid(int value) {
    return RouteRecordAttribute_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    RouteRecordAttribute_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    RouteRecordAttribute_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    RouteRecordAttribute_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return RouteRecordAttribute_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return RouteRecordAttribute_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return RouteRecordAttribute_ActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .xsproto.communication.Attribute attributes = 2;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  const ::xsproto::communication::Attribute& attributes(int index) const;
  ::xsproto::communication::Attribute* mutable_attributes(int index);
  ::xsproto::communication::Attribute* add_attributes();
  ::google::protobuf::RepeatedPtrField< ::xsproto::communication::Attribute >*
      mutable_attributes();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::communication::Attribute >&
      attributes() const;

  // .xsproto.communication.RouteRecordAttribute.ActionType action_type = 1;
  void clear_action_type();
  static const int kActionTypeFieldNumber = 1;
  ::xsproto::communication::RouteRecordAttribute_ActionType action_type() const;
  void set_action_type(::xsproto::communication::RouteRecordAttribute_ActionType value);

  // @@protoc_insertion_point(class_scope:xsproto.communication.RouteRecordAttribute)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::communication::Attribute > attributes_;
  int action_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_business_2froute_5frecord_5frequest_2eproto::TableStruct;
  friend void ::protobuf_business_2froute_5frecord_5frequest_2eproto::InitDefaultsRouteRecordAttributeImpl();
};
// -------------------------------------------------------------------

class Attribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.communication.Attribute) */ {
 public:
  Attribute();
  virtual ~Attribute();

  Attribute(const Attribute& from);

  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Attribute(Attribute&& from) noexcept
    : Attribute() {
    *this = ::std::move(from);
  }

  inline Attribute& operator=(Attribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Attribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Attribute* internal_default_instance() {
    return reinterpret_cast<const Attribute*>(
               &_Attribute_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Attribute* other);
  friend void swap(Attribute& a, Attribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Attribute* New() const PROTOBUF_FINAL { return New(NULL); }

  Attribute* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Attribute& from);
  void MergeFrom(const Attribute& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Attribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:xsproto.communication.Attribute)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct ::protobuf_business_2froute_5frecord_5frequest_2eproto::TableStruct;
  friend void ::protobuf_business_2froute_5frecord_5frequest_2eproto::InitDefaultsAttributeImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RouteRecordRequest

// .xsproto.base.Header header = 1;
inline bool RouteRecordRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::xsproto::base::Header& RouteRecordRequest::header() const {
  const ::xsproto::base::Header* p = header_;
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordRequest.header)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::base::Header*>(
      &::xsproto::base::_Header_default_instance_);
}
inline ::xsproto::base::Header* RouteRecordRequest::release_header() {
  // @@protoc_insertion_point(field_release:xsproto.communication.RouteRecordRequest.header)
  
  ::xsproto::base::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::xsproto::base::Header* RouteRecordRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::xsproto::base::Header;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.communication.RouteRecordRequest.header)
  return header_;
}
inline void RouteRecordRequest::set_allocated_header(::xsproto::base::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xsproto.communication.RouteRecordRequest.header)
}

// int64 timestamp = 2;
inline void RouteRecordRequest::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RouteRecordRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordRequest.timestamp)
  return timestamp_;
}
inline void RouteRecordRequest::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RouteRecordRequest.timestamp)
}

// int32 seq_num = 3;
inline void RouteRecordRequest::clear_seq_num() {
  seq_num_ = 0;
}
inline ::google::protobuf::int32 RouteRecordRequest::seq_num() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordRequest.seq_num)
  return seq_num_;
}
inline void RouteRecordRequest::set_seq_num(::google::protobuf::int32 value) {
  
  seq_num_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RouteRecordRequest.seq_num)
}

// int32 msg_code = 4;
inline void RouteRecordRequest::clear_msg_code() {
  msg_code_ = 0;
}
inline ::google::protobuf::int32 RouteRecordRequest::msg_code() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordRequest.msg_code)
  return msg_code_;
}
inline void RouteRecordRequest::set_msg_code(::google::protobuf::int32 value) {
  
  msg_code_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RouteRecordRequest.msg_code)
}

// .google.protobuf.Any msg_content = 5;
inline bool RouteRecordRequest::has_msg_content() const {
  return this != internal_default_instance() && msg_content_ != NULL;
}
inline const ::google::protobuf::Any& RouteRecordRequest::msg_content() const {
  const ::google::protobuf::Any* p = msg_content_;
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordRequest.msg_content)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* RouteRecordRequest::release_msg_content() {
  // @@protoc_insertion_point(field_release:xsproto.communication.RouteRecordRequest.msg_content)
  
  ::google::protobuf::Any* temp = msg_content_;
  msg_content_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* RouteRecordRequest::mutable_msg_content() {
  
  if (msg_content_ == NULL) {
    msg_content_ = new ::google::protobuf::Any;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.communication.RouteRecordRequest.msg_content)
  return msg_content_;
}
inline void RouteRecordRequest::set_allocated_msg_content(::google::protobuf::Any* msg_content) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(msg_content_);
  }
  if (msg_content) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg_content = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg_content, submessage_arena);
    }
    
  } else {
    
  }
  msg_content_ = msg_content;
  // @@protoc_insertion_point(field_set_allocated:xsproto.communication.RouteRecordRequest.msg_content)
}

// -------------------------------------------------------------------

// RecordControl

// int64 time = 1;
inline void RecordControl::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RecordControl::time() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordControl.time)
  return time_;
}
inline void RecordControl::set_time(::google::protobuf::int64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordControl.time)
}

// .xsproto.communication.RecordControl.ControlType control_type = 2;
inline void RecordControl::clear_control_type() {
  control_type_ = 0;
}
inline ::xsproto::communication::RecordControl_ControlType RecordControl::control_type() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordControl.control_type)
  return static_cast< ::xsproto::communication::RecordControl_ControlType >(control_type_);
}
inline void RecordControl::set_control_type(::xsproto::communication::RecordControl_ControlType value) {
  
  control_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordControl.control_type)
}

// string save_path = 3;
inline void RecordControl::clear_save_path() {
  save_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecordControl::save_path() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordControl.save_path)
  return save_path_.GetNoArena();
}
inline void RecordControl::set_save_path(const ::std::string& value) {
  
  save_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordControl.save_path)
}
#if LANG_CXX11
inline void RecordControl::set_save_path(::std::string&& value) {
  
  save_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.communication.RecordControl.save_path)
}
#endif
inline void RecordControl::set_save_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  save_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.communication.RecordControl.save_path)
}
inline void RecordControl::set_save_path(const char* value, size_t size) {
  
  save_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.communication.RecordControl.save_path)
}
inline ::std::string* RecordControl::mutable_save_path() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.communication.RecordControl.save_path)
  return save_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecordControl::release_save_path() {
  // @@protoc_insertion_point(field_release:xsproto.communication.RecordControl.save_path)
  
  return save_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecordControl::set_allocated_save_path(::std::string* save_path) {
  if (save_path != NULL) {
    
  } else {
    
  }
  save_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), save_path);
  // @@protoc_insertion_point(field_set_allocated:xsproto.communication.RecordControl.save_path)
}

// string path_name = 4;
inline void RecordControl::clear_path_name() {
  path_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecordControl::path_name() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordControl.path_name)
  return path_name_.GetNoArena();
}
inline void RecordControl::set_path_name(const ::std::string& value) {
  
  path_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordControl.path_name)
}
#if LANG_CXX11
inline void RecordControl::set_path_name(::std::string&& value) {
  
  path_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.communication.RecordControl.path_name)
}
#endif
inline void RecordControl::set_path_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.communication.RecordControl.path_name)
}
inline void RecordControl::set_path_name(const char* value, size_t size) {
  
  path_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.communication.RecordControl.path_name)
}
inline ::std::string* RecordControl::mutable_path_name() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.communication.RecordControl.path_name)
  return path_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecordControl::release_path_name() {
  // @@protoc_insertion_point(field_release:xsproto.communication.RecordControl.path_name)
  
  return path_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecordControl::set_allocated_path_name(::std::string* path_name) {
  if (path_name != NULL) {
    
  } else {
    
  }
  path_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path_name);
  // @@protoc_insertion_point(field_set_allocated:xsproto.communication.RecordControl.path_name)
}

// -------------------------------------------------------------------

// RouteRecordAttribute

// .xsproto.communication.RouteRecordAttribute.ActionType action_type = 1;
inline void RouteRecordAttribute::clear_action_type() {
  action_type_ = 0;
}
inline ::xsproto::communication::RouteRecordAttribute_ActionType RouteRecordAttribute::action_type() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordAttribute.action_type)
  return static_cast< ::xsproto::communication::RouteRecordAttribute_ActionType >(action_type_);
}
inline void RouteRecordAttribute::set_action_type(::xsproto::communication::RouteRecordAttribute_ActionType value) {
  
  action_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RouteRecordAttribute.action_type)
}

// repeated .xsproto.communication.Attribute attributes = 2;
inline int RouteRecordAttribute::attributes_size() const {
  return attributes_.size();
}
inline void RouteRecordAttribute::clear_attributes() {
  attributes_.Clear();
}
inline const ::xsproto::communication::Attribute& RouteRecordAttribute::attributes(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordAttribute.attributes)
  return attributes_.Get(index);
}
inline ::xsproto::communication::Attribute* RouteRecordAttribute::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.communication.RouteRecordAttribute.attributes)
  return attributes_.Mutable(index);
}
inline ::xsproto::communication::Attribute* RouteRecordAttribute::add_attributes() {
  // @@protoc_insertion_point(field_add:xsproto.communication.RouteRecordAttribute.attributes)
  return attributes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::communication::Attribute >*
RouteRecordAttribute::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.communication.RouteRecordAttribute.attributes)
  return &attributes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::communication::Attribute >&
RouteRecordAttribute::attributes() const {
  // @@protoc_insertion_point(field_list:xsproto.communication.RouteRecordAttribute.attributes)
  return attributes_;
}

// -------------------------------------------------------------------

// Attribute

// string key = 1;
inline void Attribute::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Attribute::key() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.Attribute.key)
  return key_.GetNoArena();
}
inline void Attribute::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.communication.Attribute.key)
}
#if LANG_CXX11
inline void Attribute::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.communication.Attribute.key)
}
#endif
inline void Attribute::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.communication.Attribute.key)
}
inline void Attribute::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.communication.Attribute.key)
}
inline ::std::string* Attribute::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.communication.Attribute.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Attribute::release_key() {
  // @@protoc_insertion_point(field_release:xsproto.communication.Attribute.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Attribute::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:xsproto.communication.Attribute.key)
}

// string value = 2;
inline void Attribute::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Attribute::value() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.Attribute.value)
  return value_.GetNoArena();
}
inline void Attribute::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.communication.Attribute.value)
}
#if LANG_CXX11
inline void Attribute::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.communication.Attribute.value)
}
#endif
inline void Attribute::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.communication.Attribute.value)
}
inline void Attribute::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.communication.Attribute.value)
}
inline ::std::string* Attribute::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.communication.Attribute.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Attribute::release_value() {
  // @@protoc_insertion_point(field_release:xsproto.communication.Attribute.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Attribute::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:xsproto.communication.Attribute.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace communication
}  // namespace xsproto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::xsproto::communication::RecordControl_ControlType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::communication::RecordControl_ControlType>() {
  return ::xsproto::communication::RecordControl_ControlType_descriptor();
}
template <> struct is_proto_enum< ::xsproto::communication::RouteRecordAttribute_ActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::communication::RouteRecordAttribute_ActionType>() {
  return ::xsproto::communication::RouteRecordAttribute_ActionType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_business_2froute_5frecord_5frequest_2eproto__INCLUDED
