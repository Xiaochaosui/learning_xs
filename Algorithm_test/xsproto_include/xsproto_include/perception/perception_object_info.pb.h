// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perception/perception_object_info.proto

#ifndef PROTOBUF_perception_2fperception_5fobject_5finfo_2eproto__INCLUDED
#define PROTOBUF_perception_2fperception_5fobject_5finfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "base/header.pb.h"
#include "perception/perception_common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_perception_2fperception_5fobject_5finfo_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsBBox2DImpl();
void InitDefaultsBBox2D();
void InitDefaultsSensorMeasurementImpl();
void InitDefaultsSensorMeasurement();
void InitDefaultsCarLightStatusImpl();
void InitDefaultsCarLightStatus();
void InitDefaultsPerceptionObjectImpl();
void InitDefaultsPerceptionObject();
void InitDefaultsStaticObstacleImpl();
void InitDefaultsStaticObstacle();
void InitDefaultsPerceptionObjectInfoImpl();
void InitDefaultsPerceptionObjectInfo();
inline void InitDefaults() {
  InitDefaultsBBox2D();
  InitDefaultsSensorMeasurement();
  InitDefaultsCarLightStatus();
  InitDefaultsPerceptionObject();
  InitDefaultsStaticObstacle();
  InitDefaultsPerceptionObjectInfo();
}
}  // namespace protobuf_perception_2fperception_5fobject_5finfo_2eproto
namespace xsproto {
namespace perception {
class BBox2D;
class BBox2DDefaultTypeInternal;
extern BBox2DDefaultTypeInternal _BBox2D_default_instance_;
class CarLightStatus;
class CarLightStatusDefaultTypeInternal;
extern CarLightStatusDefaultTypeInternal _CarLightStatus_default_instance_;
class PerceptionObject;
class PerceptionObjectDefaultTypeInternal;
extern PerceptionObjectDefaultTypeInternal _PerceptionObject_default_instance_;
class PerceptionObjectInfo;
class PerceptionObjectInfoDefaultTypeInternal;
extern PerceptionObjectInfoDefaultTypeInternal _PerceptionObjectInfo_default_instance_;
class SensorMeasurement;
class SensorMeasurementDefaultTypeInternal;
extern SensorMeasurementDefaultTypeInternal _SensorMeasurement_default_instance_;
class StaticObstacle;
class StaticObstacleDefaultTypeInternal;
extern StaticObstacleDefaultTypeInternal _StaticObstacle_default_instance_;
}  // namespace perception
}  // namespace xsproto
namespace xsproto {
namespace perception {

enum ObjType {
  OBJ_TYPE_UNKNOWN = 0,
  OBJ_TYPE_VEHICLE = 1,
  OBJ_TYPE_PERSON = 2,
  OBJ_TYPE_STATIC = 3,
  ObjType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ObjType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ObjType_IsValid(int value);
const ObjType ObjType_MIN = OBJ_TYPE_UNKNOWN;
const ObjType ObjType_MAX = OBJ_TYPE_STATIC;
const int ObjType_ARRAYSIZE = ObjType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjType_descriptor();
inline const ::std::string& ObjType_Name(ObjType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjType_descriptor(), value);
}
inline bool ObjType_Parse(
    const ::std::string& name, ObjType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjType>(
    ObjType_descriptor(), name, value);
}
enum ObjSubType {
  OBJ_ST_UNKNOWN = 0,
  OBJ_ST_MINI_VEHICLE = 1,
  OBJ_ST_MID_VEHICLE = 2,
  OBJ_ST_BIG_VEHICLE = 3,
  OBJ_ST_CAR = 4,
  OBJ_ST_BUS = 5,
  OBJ_ST_SCHOOL_BUS = 6,
  OBJ_ST_PATROL_CAR = 7,
  OBJ_ST_VAN = 8,
  OBJ_ST_TRUCK = 9,
  OBJ_ST_PICKUP = 10,
  OBJ_ST_VEHICLE_TRANSPORTER = 11,
  OBJ_ST_ENGINEERING_CAR = 12,
  OBJ_ST_POLICE_CAR = 13,
  OBJ_ST_AMBULANCE = 14,
  OBJ_ST_FIRE_ENGINE = 15,
  OBJ_ST_TANKERS = 16,
  OBJ_ST_SANITATION_TRUCK = 17,
  OBJ_ST_FORK_LIFT = 18,
  OBJ_ST_UNMANNED_VEHICLE = 19,
  OBJ_ST_TRICYCLE = 20,
  OBJ_ST_TRACTOR = 21,
  OBJ_ST_MOTORLIST = 101,
  OBJ_ST_CYCLIST = 102,
  OBJ_ST_PEDESTRIAN = 103,
  OBJ_ST_ADULT = 104,
  OBJ_ST_CHILD = 105,
  OBJ_ST_POLICEMAN = 106,
  OBJ_ST_POSITIVE_OBSTACLE = 201,
  OBJ_ST_NEGATIVE_OBSTACLE = 202,
  OBJ_ST_STRUCTURE = 203,
  OBJ_ST_FENCE = 204,
  OBJ_ST_POLE = 205,
  OBJ_ST_VEGETATION = 206,
  OBJ_ST_DRAIN_HOLE = 207,
  OBJ_ST_CLIFF = 208,
  OBJ_ST_ROADCURB = 209,
  OBJ_ST_TRAFFIC_CONE = 210,
  OBJ_ST_CONSTRUCTION_SIGN = 211,
  OBJ_ST_TRAFFIC_BARRIER = 212,
  OBJ_ST_TRIREFLECTOR = 213,
  ObjSubType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ObjSubType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ObjSubType_IsValid(int value);
const ObjSubType ObjSubType_MIN = OBJ_ST_UNKNOWN;
const ObjSubType ObjSubType_MAX = OBJ_ST_TRIREFLECTOR;
const int ObjSubType_ARRAYSIZE = ObjSubType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjSubType_descriptor();
inline const ::std::string& ObjSubType_Name(ObjSubType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjSubType_descriptor(), value);
}
inline bool ObjSubType_Parse(
    const ::std::string& name, ObjSubType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjSubType>(
    ObjSubType_descriptor(), name, value);
}
enum PersonPosture {
  POSTURE_UNKNOWN = 0,
  POSTURE_STAND = 1,
  POSTURE_SQUAT = 2,
  POSTURE_SIT = 3,
  POSTURE_BEND = 4,
  POSTURE_LIE = 5,
  POSTURE_BECKON = 6,
  POSTURE_FOCUS_ME = 7,
  POSTURE_POLICE_STOP = 8,
  POSTURE_POLICE_LEFT_TURN = 9,
  POSTURE_POLICE_RIGHT_TURN = 10,
  POSTURE_POLICE_GO_FORARD = 11,
  PersonPosture_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PersonPosture_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PersonPosture_IsValid(int value);
const PersonPosture PersonPosture_MIN = POSTURE_UNKNOWN;
const PersonPosture PersonPosture_MAX = POSTURE_POLICE_GO_FORARD;
const int PersonPosture_ARRAYSIZE = PersonPosture_MAX + 1;

const ::google::protobuf::EnumDescriptor* PersonPosture_descriptor();
inline const ::std::string& PersonPosture_Name(PersonPosture value) {
  return ::google::protobuf::internal::NameOfEnum(
    PersonPosture_descriptor(), value);
}
inline bool PersonPosture_Parse(
    const ::std::string& name, PersonPosture* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PersonPosture>(
    PersonPosture_descriptor(), name, value);
}
enum SourceType {
  SOURCE_TYPE_V2X = 0,
  SOURCE_TYPE_LIDAR_LATE_FUSION = 1,
  SOURCE_TYPE_RADAR_LATE_FUSION = 2,
  SOURCE_TYPE_CAMERA_LATE_FUSION = 3,
  SOURCE_TYPE_CLUSTER_LIDAR = 4,
  SOURCE_TYPE_CLUSTER_RADAR = 5,
  SOURCE_TYPE_DL_LIDAR = 6,
  SOURCE_TYPE_DL_CAMERA = 7,
  SOURCE_TYPE_DL_RADAR = 8,
  SOURCE_TYPE_DL_FUSION = 9,
  SourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SourceType_IsValid(int value);
const SourceType SourceType_MIN = SOURCE_TYPE_V2X;
const SourceType SourceType_MAX = SOURCE_TYPE_DL_FUSION;
const int SourceType_ARRAYSIZE = SourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SourceType_descriptor();
inline const ::std::string& SourceType_Name(SourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SourceType_descriptor(), value);
}
inline bool SourceType_Parse(
    const ::std::string& name, SourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SourceType>(
    SourceType_descriptor(), name, value);
}
enum TrackState {
  TRACK_STATE_NEW_ADD = 0,
  TRACK_STATE_TRACKING = 1,
  TRACK_STATE_LOST = 2,
  TRACK_STATE_ERROR = 3,
  TrackState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrackState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrackState_IsValid(int value);
const TrackState TrackState_MIN = TRACK_STATE_NEW_ADD;
const TrackState TrackState_MAX = TRACK_STATE_ERROR;
const int TrackState_ARRAYSIZE = TrackState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrackState_descriptor();
inline const ::std::string& TrackState_Name(TrackState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrackState_descriptor(), value);
}
inline bool TrackState_Parse(
    const ::std::string& name, TrackState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrackState>(
    TrackState_descriptor(), name, value);
}
// ===================================================================

class BBox2D : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.BBox2D) */ {
 public:
  BBox2D();
  virtual ~BBox2D();

  BBox2D(const BBox2D& from);

  inline BBox2D& operator=(const BBox2D& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BBox2D(BBox2D&& from) noexcept
    : BBox2D() {
    *this = ::std::move(from);
  }

  inline BBox2D& operator=(BBox2D&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BBox2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BBox2D* internal_default_instance() {
    return reinterpret_cast<const BBox2D*>(
               &_BBox2D_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(BBox2D* other);
  friend void swap(BBox2D& a, BBox2D& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BBox2D* New() const PROTOBUF_FINAL { return New(NULL); }

  BBox2D* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BBox2D& from);
  void MergeFrom(const BBox2D& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BBox2D* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xsproto.perception.CamearaIntrinsicParameters intri_params = 5;
  bool has_intri_params() const;
  void clear_intri_params();
  static const int kIntriParamsFieldNumber = 5;
  const ::xsproto::perception::CamearaIntrinsicParameters& intri_params() const;
  ::xsproto::perception::CamearaIntrinsicParameters* release_intri_params();
  ::xsproto::perception::CamearaIntrinsicParameters* mutable_intri_params();
  void set_allocated_intri_params(::xsproto::perception::CamearaIntrinsicParameters* intri_params);

  // .xsproto.perception.ExtrinsicParameters extri_params = 6;
  bool has_extri_params() const;
  void clear_extri_params();
  static const int kExtriParamsFieldNumber = 6;
  const ::xsproto::perception::ExtrinsicParameters& extri_params() const;
  ::xsproto::perception::ExtrinsicParameters* release_extri_params();
  ::xsproto::perception::ExtrinsicParameters* mutable_extri_params();
  void set_allocated_extri_params(::xsproto::perception::ExtrinsicParameters* extri_params);

  // float xmin = 1;
  void clear_xmin();
  static const int kXminFieldNumber = 1;
  float xmin() const;
  void set_xmin(float value);

  // float ymin = 2;
  void clear_ymin();
  static const int kYminFieldNumber = 2;
  float ymin() const;
  void set_ymin(float value);

  // float xmax = 3;
  void clear_xmax();
  static const int kXmaxFieldNumber = 3;
  float xmax() const;
  void set_xmax(float value);

  // float ymax = 4;
  void clear_ymax();
  static const int kYmaxFieldNumber = 4;
  float ymax() const;
  void set_ymax(float value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.BBox2D)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xsproto::perception::CamearaIntrinsicParameters* intri_params_;
  ::xsproto::perception::ExtrinsicParameters* extri_params_;
  float xmin_;
  float ymin_;
  float xmax_;
  float ymax_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fperception_5fobject_5finfo_2eproto::TableStruct;
  friend void ::protobuf_perception_2fperception_5fobject_5finfo_2eproto::InitDefaultsBBox2DImpl();
};
// -------------------------------------------------------------------

class SensorMeasurement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.SensorMeasurement) */ {
 public:
  SensorMeasurement();
  virtual ~SensorMeasurement();

  SensorMeasurement(const SensorMeasurement& from);

  inline SensorMeasurement& operator=(const SensorMeasurement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorMeasurement(SensorMeasurement&& from) noexcept
    : SensorMeasurement() {
    *this = ::std::move(from);
  }

  inline SensorMeasurement& operator=(SensorMeasurement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorMeasurement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorMeasurement* internal_default_instance() {
    return reinterpret_cast<const SensorMeasurement*>(
               &_SensorMeasurement_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SensorMeasurement* other);
  friend void swap(SensorMeasurement& a, SensorMeasurement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorMeasurement* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorMeasurement* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorMeasurement& from);
  void MergeFrom(const SensorMeasurement& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorMeasurement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xsproto.perception.Point2D center = 2;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 2;
  const ::xsproto::perception::Point2D& center() const;
  ::xsproto::perception::Point2D* release_center();
  ::xsproto::perception::Point2D* mutable_center();
  void set_allocated_center(::xsproto::perception::Point2D* center);

  // .xsproto.perception.Area2D corner = 8;
  bool has_corner() const;
  void clear_corner();
  static const int kCornerFieldNumber = 8;
  const ::xsproto::perception::Area2D& corner() const;
  ::xsproto::perception::Area2D* release_corner();
  ::xsproto::perception::Area2D* mutable_corner();
  void set_allocated_corner(::xsproto::perception::Area2D* corner);

  // .xsproto.perception.Area2D border = 9;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 9;
  const ::xsproto::perception::Area2D& border() const;
  ::xsproto::perception::Area2D* release_border();
  ::xsproto::perception::Area2D* mutable_border();
  void set_allocated_border(::xsproto::perception::Area2D* border);

  // double timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // float width = 3;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  float width() const;
  void set_width(float value);

  // float length = 4;
  void clear_length();
  static const int kLengthFieldNumber = 4;
  float length() const;
  void set_length(float value);

  // float r_angle = 5;
  void clear_r_angle();
  static const int kRAngleFieldNumber = 5;
  float r_angle() const;
  void set_r_angle(float value);

  // float height_max = 6;
  void clear_height_max();
  static const int kHeightMaxFieldNumber = 6;
  float height_max() const;
  void set_height_max(float value);

  // float height_min = 7;
  void clear_height_min();
  static const int kHeightMinFieldNumber = 7;
  float height_min() const;
  void set_height_min(float value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.SensorMeasurement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xsproto::perception::Point2D* center_;
  ::xsproto::perception::Area2D* corner_;
  ::xsproto::perception::Area2D* border_;
  double timestamp_;
  float width_;
  float length_;
  float r_angle_;
  float height_max_;
  float height_min_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fperception_5fobject_5finfo_2eproto::TableStruct;
  friend void ::protobuf_perception_2fperception_5fobject_5finfo_2eproto::InitDefaultsSensorMeasurementImpl();
};
// -------------------------------------------------------------------

class CarLightStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.CarLightStatus) */ {
 public:
  CarLightStatus();
  virtual ~CarLightStatus();

  CarLightStatus(const CarLightStatus& from);

  inline CarLightStatus& operator=(const CarLightStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CarLightStatus(CarLightStatus&& from) noexcept
    : CarLightStatus() {
    *this = ::std::move(from);
  }

  inline CarLightStatus& operator=(CarLightStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CarLightStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CarLightStatus* internal_default_instance() {
    return reinterpret_cast<const CarLightStatus*>(
               &_CarLightStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(CarLightStatus* other);
  friend void swap(CarLightStatus& a, CarLightStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CarLightStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  CarLightStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CarLightStatus& from);
  void MergeFrom(const CarLightStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CarLightStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool brake = 1;
  void clear_brake();
  static const int kBrakeFieldNumber = 1;
  bool brake() const;
  void set_brake(bool value);

  // bool left_turn = 2;
  void clear_left_turn();
  static const int kLeftTurnFieldNumber = 2;
  bool left_turn() const;
  void set_left_turn(bool value);

  // bool right_turn = 3;
  void clear_right_turn();
  static const int kRightTurnFieldNumber = 3;
  bool right_turn() const;
  void set_right_turn(bool value);

  // bool double_flashing = 4;
  void clear_double_flashing();
  static const int kDoubleFlashingFieldNumber = 4;
  bool double_flashing() const;
  void set_double_flashing(bool value);

  // bool backup = 5;
  void clear_backup();
  static const int kBackupFieldNumber = 5;
  bool backup() const;
  void set_backup(bool value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.CarLightStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool brake_;
  bool left_turn_;
  bool right_turn_;
  bool double_flashing_;
  bool backup_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fperception_5fobject_5finfo_2eproto::TableStruct;
  friend void ::protobuf_perception_2fperception_5fobject_5finfo_2eproto::InitDefaultsCarLightStatusImpl();
};
// -------------------------------------------------------------------

class PerceptionObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.PerceptionObject) */ {
 public:
  PerceptionObject();
  virtual ~PerceptionObject();

  PerceptionObject(const PerceptionObject& from);

  inline PerceptionObject& operator=(const PerceptionObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PerceptionObject(PerceptionObject&& from) noexcept
    : PerceptionObject() {
    *this = ::std::move(from);
  }

  inline PerceptionObject& operator=(PerceptionObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PerceptionObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PerceptionObject* internal_default_instance() {
    return reinterpret_cast<const PerceptionObject*>(
               &_PerceptionObject_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(PerceptionObject* other);
  friend void swap(PerceptionObject& a, PerceptionObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PerceptionObject* New() const PROTOBUF_FINAL { return New(NULL); }

  PerceptionObject* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PerceptionObject& from);
  void MergeFrom(const PerceptionObject& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PerceptionObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.perception.SensorMeasurement measurements = 22;
  int measurements_size() const;
  void clear_measurements();
  static const int kMeasurementsFieldNumber = 22;
  const ::xsproto::perception::SensorMeasurement& measurements(int index) const;
  ::xsproto::perception::SensorMeasurement* mutable_measurements(int index);
  ::xsproto::perception::SensorMeasurement* add_measurements();
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::SensorMeasurement >*
      mutable_measurements();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::SensorMeasurement >&
      measurements() const;

  // repeated .xsproto.perception.PersonPosture person_posture = 25;
  int person_posture_size() const;
  void clear_person_posture();
  static const int kPersonPostureFieldNumber = 25;
  ::xsproto::perception::PersonPosture person_posture(int index) const;
  void set_person_posture(int index, ::xsproto::perception::PersonPosture value);
  void add_person_posture(::xsproto::perception::PersonPosture value);
  const ::google::protobuf::RepeatedField<int>& person_posture() const;
  ::google::protobuf::RepeatedField<int>* mutable_person_posture();

  // .xsproto.perception.Point2D center = 9;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 9;
  const ::xsproto::perception::Point2D& center() const;
  ::xsproto::perception::Point2D* release_center();
  ::xsproto::perception::Point2D* mutable_center();
  void set_allocated_center(::xsproto::perception::Point2D* center);

  // .xsproto.perception.Area2D corner = 15;
  bool has_corner() const;
  void clear_corner();
  static const int kCornerFieldNumber = 15;
  const ::xsproto::perception::Area2D& corner() const;
  ::xsproto::perception::Area2D* release_corner();
  ::xsproto::perception::Area2D* mutable_corner();
  void set_allocated_corner(::xsproto::perception::Area2D* corner);

  // .xsproto.perception.Area2D border = 16;
  bool has_border() const;
  void clear_border();
  static const int kBorderFieldNumber = 16;
  const ::xsproto::perception::Area2D& border() const;
  ::xsproto::perception::Area2D* release_border();
  ::xsproto::perception::Area2D* mutable_border();
  void set_allocated_border(::xsproto::perception::Area2D* border);

  // .xsproto.perception.BBox2D camera_box2d = 23;
  bool has_camera_box2d() const;
  void clear_camera_box2d();
  static const int kCameraBox2DFieldNumber = 23;
  const ::xsproto::perception::BBox2D& camera_box2d() const;
  ::xsproto::perception::BBox2D* release_camera_box2d();
  ::xsproto::perception::BBox2D* mutable_camera_box2d();
  void set_allocated_camera_box2d(::xsproto::perception::BBox2D* camera_box2d);

  // .xsproto.perception.CarLightStatus car_light_status = 24;
  bool has_car_light_status() const;
  void clear_car_light_status();
  static const int kCarLightStatusFieldNumber = 24;
  const ::xsproto::perception::CarLightStatus& car_light_status() const;
  ::xsproto::perception::CarLightStatus* release_car_light_status();
  ::xsproto::perception::CarLightStatus* mutable_car_light_status();
  void set_allocated_car_light_status(::xsproto::perception::CarLightStatus* car_light_status);

  // .xsproto.perception.SourceType source_type = 1;
  void clear_source_type();
  static const int kSourceTypeFieldNumber = 1;
  ::xsproto::perception::SourceType source_type() const;
  void set_source_type(::xsproto::perception::SourceType value);

  // uint32 track_id = 2;
  void clear_track_id();
  static const int kTrackIdFieldNumber = 2;
  ::google::protobuf::uint32 track_id() const;
  void set_track_id(::google::protobuf::uint32 value);

  // double birth_time = 4;
  void clear_birth_time();
  static const int kBirthTimeFieldNumber = 4;
  double birth_time() const;
  void set_birth_time(double value);

  // .xsproto.perception.TrackState track_state = 3;
  void clear_track_state();
  static const int kTrackStateFieldNumber = 3;
  ::xsproto::perception::TrackState track_state() const;
  void set_track_state(::xsproto::perception::TrackState value);

  // float confidence = 6;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 6;
  float confidence() const;
  void set_confidence(float value);

  // double loss_time = 5;
  void clear_loss_time();
  static const int kLossTimeFieldNumber = 5;
  double loss_time() const;
  void set_loss_time(double value);

  // .xsproto.perception.ObjType obj_type = 7;
  void clear_obj_type();
  static const int kObjTypeFieldNumber = 7;
  ::xsproto::perception::ObjType obj_type() const;
  void set_obj_type(::xsproto::perception::ObjType value);

  // .xsproto.perception.ObjSubType obj_subtype = 8;
  void clear_obj_subtype();
  static const int kObjSubtypeFieldNumber = 8;
  ::xsproto::perception::ObjSubType obj_subtype() const;
  void set_obj_subtype(::xsproto::perception::ObjSubType value);

  // float width = 10;
  void clear_width();
  static const int kWidthFieldNumber = 10;
  float width() const;
  void set_width(float value);

  // float length = 11;
  void clear_length();
  static const int kLengthFieldNumber = 11;
  float length() const;
  void set_length(float value);

  // float r_angle = 12;
  void clear_r_angle();
  static const int kRAngleFieldNumber = 12;
  float r_angle() const;
  void set_r_angle(float value);

  // float height = 13;
  void clear_height();
  static const int kHeightFieldNumber = 13;
  float height() const;
  void set_height(float value);

  // float height_min = 14;
  void clear_height_min();
  static const int kHeightMinFieldNumber = 14;
  float height_min() const;
  void set_height_min(float value);

  // float linear_speed_angle = 17;
  void clear_linear_speed_angle();
  static const int kLinearSpeedAngleFieldNumber = 17;
  float linear_speed_angle() const;
  void set_linear_speed_angle(float value);

  // float linear_speed = 18;
  void clear_linear_speed();
  static const int kLinearSpeedFieldNumber = 18;
  float linear_speed() const;
  void set_linear_speed(float value);

  // float angular_speed = 19;
  void clear_angular_speed();
  static const int kAngularSpeedFieldNumber = 19;
  float angular_speed() const;
  void set_angular_speed(float value);

  // float linear_acc = 20;
  void clear_linear_acc();
  static const int kLinearAccFieldNumber = 20;
  float linear_acc() const;
  void set_linear_acc(float value);

  // float tracking_stability = 21;
  void clear_tracking_stability();
  static const int kTrackingStabilityFieldNumber = 21;
  float tracking_stability() const;
  void set_tracking_stability(float value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.PerceptionObject)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::SensorMeasurement > measurements_;
  ::google::protobuf::RepeatedField<int> person_posture_;
  mutable int _person_posture_cached_byte_size_;
  ::xsproto::perception::Point2D* center_;
  ::xsproto::perception::Area2D* corner_;
  ::xsproto::perception::Area2D* border_;
  ::xsproto::perception::BBox2D* camera_box2d_;
  ::xsproto::perception::CarLightStatus* car_light_status_;
  int source_type_;
  ::google::protobuf::uint32 track_id_;
  double birth_time_;
  int track_state_;
  float confidence_;
  double loss_time_;
  int obj_type_;
  int obj_subtype_;
  float width_;
  float length_;
  float r_angle_;
  float height_;
  float height_min_;
  float linear_speed_angle_;
  float linear_speed_;
  float angular_speed_;
  float linear_acc_;
  float tracking_stability_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fperception_5fobject_5finfo_2eproto::TableStruct;
  friend void ::protobuf_perception_2fperception_5fobject_5finfo_2eproto::InitDefaultsPerceptionObjectImpl();
};
// -------------------------------------------------------------------

class StaticObstacle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.StaticObstacle) */ {
 public:
  StaticObstacle();
  virtual ~StaticObstacle();

  StaticObstacle(const StaticObstacle& from);

  inline StaticObstacle& operator=(const StaticObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StaticObstacle(StaticObstacle&& from) noexcept
    : StaticObstacle() {
    *this = ::std::move(from);
  }

  inline StaticObstacle& operator=(StaticObstacle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StaticObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StaticObstacle* internal_default_instance() {
    return reinterpret_cast<const StaticObstacle*>(
               &_StaticObstacle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(StaticObstacle* other);
  friend void swap(StaticObstacle& a, StaticObstacle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StaticObstacle* New() const PROTOBUF_FINAL { return New(NULL); }

  StaticObstacle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StaticObstacle& from);
  void MergeFrom(const StaticObstacle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StaticObstacle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xsproto.perception.Area2D area = 2;
  bool has_area() const;
  void clear_area();
  static const int kAreaFieldNumber = 2;
  const ::xsproto::perception::Area2D& area() const;
  ::xsproto::perception::Area2D* release_area();
  ::xsproto::perception::Area2D* mutable_area();
  void set_allocated_area(::xsproto::perception::Area2D* area);

  // .xsproto.perception.ObjSubType obj_subtype = 1;
  void clear_obj_subtype();
  static const int kObjSubtypeFieldNumber = 1;
  ::xsproto::perception::ObjSubType obj_subtype() const;
  void set_obj_subtype(::xsproto::perception::ObjSubType value);

  // float max_height = 3;
  void clear_max_height();
  static const int kMaxHeightFieldNumber = 3;
  float max_height() const;
  void set_max_height(float value);

  // float min_height = 4;
  void clear_min_height();
  static const int kMinHeightFieldNumber = 4;
  float min_height() const;
  void set_min_height(float value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.StaticObstacle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xsproto::perception::Area2D* area_;
  int obj_subtype_;
  float max_height_;
  float min_height_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fperception_5fobject_5finfo_2eproto::TableStruct;
  friend void ::protobuf_perception_2fperception_5fobject_5finfo_2eproto::InitDefaultsStaticObstacleImpl();
};
// -------------------------------------------------------------------

class PerceptionObjectInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.PerceptionObjectInfo) */ {
 public:
  PerceptionObjectInfo();
  virtual ~PerceptionObjectInfo();

  PerceptionObjectInfo(const PerceptionObjectInfo& from);

  inline PerceptionObjectInfo& operator=(const PerceptionObjectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PerceptionObjectInfo(PerceptionObjectInfo&& from) noexcept
    : PerceptionObjectInfo() {
    *this = ::std::move(from);
  }

  inline PerceptionObjectInfo& operator=(PerceptionObjectInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PerceptionObjectInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PerceptionObjectInfo* internal_default_instance() {
    return reinterpret_cast<const PerceptionObjectInfo*>(
               &_PerceptionObjectInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(PerceptionObjectInfo* other);
  friend void swap(PerceptionObjectInfo& a, PerceptionObjectInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PerceptionObjectInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PerceptionObjectInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PerceptionObjectInfo& from);
  void MergeFrom(const PerceptionObjectInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PerceptionObjectInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.perception.PerceptionObject obs_objs = 2;
  int obs_objs_size() const;
  void clear_obs_objs();
  static const int kObsObjsFieldNumber = 2;
  const ::xsproto::perception::PerceptionObject& obs_objs(int index) const;
  ::xsproto::perception::PerceptionObject* mutable_obs_objs(int index);
  ::xsproto::perception::PerceptionObject* add_obs_objs();
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PerceptionObject >*
      mutable_obs_objs();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PerceptionObject >&
      obs_objs() const;

  // repeated .xsproto.perception.StaticObstacle obstacle_areas = 3;
  int obstacle_areas_size() const;
  void clear_obstacle_areas();
  static const int kObstacleAreasFieldNumber = 3;
  const ::xsproto::perception::StaticObstacle& obstacle_areas(int index) const;
  ::xsproto::perception::StaticObstacle* mutable_obstacle_areas(int index);
  ::xsproto::perception::StaticObstacle* add_obstacle_areas();
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::StaticObstacle >*
      mutable_obstacle_areas();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::StaticObstacle >&
      obstacle_areas() const;

  // repeated .xsproto.perception.Point2D obstacle_points = 4;
  int obstacle_points_size() const;
  void clear_obstacle_points();
  static const int kObstaclePointsFieldNumber = 4;
  const ::xsproto::perception::Point2D& obstacle_points(int index) const;
  ::xsproto::perception::Point2D* mutable_obstacle_points(int index);
  ::xsproto::perception::Point2D* add_obstacle_points();
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Point2D >*
      mutable_obstacle_points();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Point2D >&
      obstacle_points() const;

  // repeated .xsproto.perception.Point3D obstacle_voxel = 5;
  int obstacle_voxel_size() const;
  void clear_obstacle_voxel();
  static const int kObstacleVoxelFieldNumber = 5;
  const ::xsproto::perception::Point3D& obstacle_voxel(int index) const;
  ::xsproto::perception::Point3D* mutable_obstacle_voxel(int index);
  ::xsproto::perception::Point3D* add_obstacle_voxel();
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Point3D >*
      mutable_obstacle_voxel();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Point3D >&
      obstacle_voxel() const;

  // bytes obstcle_data = 6;
  void clear_obstcle_data();
  static const int kObstcleDataFieldNumber = 6;
  const ::std::string& obstcle_data() const;
  void set_obstcle_data(const ::std::string& value);
  #if LANG_CXX11
  void set_obstcle_data(::std::string&& value);
  #endif
  void set_obstcle_data(const char* value);
  void set_obstcle_data(const void* value, size_t size);
  ::std::string* mutable_obstcle_data();
  ::std::string* release_obstcle_data();
  void set_allocated_obstcle_data(::std::string* obstcle_data);

  // .xsproto.base.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xsproto::base::Header& header() const;
  ::xsproto::base::Header* release_header();
  ::xsproto::base::Header* mutable_header();
  void set_allocated_header(::xsproto::base::Header* header);

  // @@protoc_insertion_point(class_scope:xsproto.perception.PerceptionObjectInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PerceptionObject > obs_objs_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::StaticObstacle > obstacle_areas_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Point2D > obstacle_points_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Point3D > obstacle_voxel_;
  ::google::protobuf::internal::ArenaStringPtr obstcle_data_;
  ::xsproto::base::Header* header_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fperception_5fobject_5finfo_2eproto::TableStruct;
  friend void ::protobuf_perception_2fperception_5fobject_5finfo_2eproto::InitDefaultsPerceptionObjectInfoImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BBox2D

// float xmin = 1;
inline void BBox2D::clear_xmin() {
  xmin_ = 0;
}
inline float BBox2D::xmin() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.BBox2D.xmin)
  return xmin_;
}
inline void BBox2D::set_xmin(float value) {
  
  xmin_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.BBox2D.xmin)
}

// float ymin = 2;
inline void BBox2D::clear_ymin() {
  ymin_ = 0;
}
inline float BBox2D::ymin() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.BBox2D.ymin)
  return ymin_;
}
inline void BBox2D::set_ymin(float value) {
  
  ymin_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.BBox2D.ymin)
}

// float xmax = 3;
inline void BBox2D::clear_xmax() {
  xmax_ = 0;
}
inline float BBox2D::xmax() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.BBox2D.xmax)
  return xmax_;
}
inline void BBox2D::set_xmax(float value) {
  
  xmax_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.BBox2D.xmax)
}

// float ymax = 4;
inline void BBox2D::clear_ymax() {
  ymax_ = 0;
}
inline float BBox2D::ymax() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.BBox2D.ymax)
  return ymax_;
}
inline void BBox2D::set_ymax(float value) {
  
  ymax_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.BBox2D.ymax)
}

// .xsproto.perception.CamearaIntrinsicParameters intri_params = 5;
inline bool BBox2D::has_intri_params() const {
  return this != internal_default_instance() && intri_params_ != NULL;
}
inline const ::xsproto::perception::CamearaIntrinsicParameters& BBox2D::intri_params() const {
  const ::xsproto::perception::CamearaIntrinsicParameters* p = intri_params_;
  // @@protoc_insertion_point(field_get:xsproto.perception.BBox2D.intri_params)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::CamearaIntrinsicParameters*>(
      &::xsproto::perception::_CamearaIntrinsicParameters_default_instance_);
}
inline ::xsproto::perception::CamearaIntrinsicParameters* BBox2D::release_intri_params() {
  // @@protoc_insertion_point(field_release:xsproto.perception.BBox2D.intri_params)
  
  ::xsproto::perception::CamearaIntrinsicParameters* temp = intri_params_;
  intri_params_ = NULL;
  return temp;
}
inline ::xsproto::perception::CamearaIntrinsicParameters* BBox2D::mutable_intri_params() {
  
  if (intri_params_ == NULL) {
    intri_params_ = new ::xsproto::perception::CamearaIntrinsicParameters;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.BBox2D.intri_params)
  return intri_params_;
}
inline void BBox2D::set_allocated_intri_params(::xsproto::perception::CamearaIntrinsicParameters* intri_params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(intri_params_);
  }
  if (intri_params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      intri_params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, intri_params, submessage_arena);
    }
    
  } else {
    
  }
  intri_params_ = intri_params;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.BBox2D.intri_params)
}

// .xsproto.perception.ExtrinsicParameters extri_params = 6;
inline bool BBox2D::has_extri_params() const {
  return this != internal_default_instance() && extri_params_ != NULL;
}
inline const ::xsproto::perception::ExtrinsicParameters& BBox2D::extri_params() const {
  const ::xsproto::perception::ExtrinsicParameters* p = extri_params_;
  // @@protoc_insertion_point(field_get:xsproto.perception.BBox2D.extri_params)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::ExtrinsicParameters*>(
      &::xsproto::perception::_ExtrinsicParameters_default_instance_);
}
inline ::xsproto::perception::ExtrinsicParameters* BBox2D::release_extri_params() {
  // @@protoc_insertion_point(field_release:xsproto.perception.BBox2D.extri_params)
  
  ::xsproto::perception::ExtrinsicParameters* temp = extri_params_;
  extri_params_ = NULL;
  return temp;
}
inline ::xsproto::perception::ExtrinsicParameters* BBox2D::mutable_extri_params() {
  
  if (extri_params_ == NULL) {
    extri_params_ = new ::xsproto::perception::ExtrinsicParameters;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.BBox2D.extri_params)
  return extri_params_;
}
inline void BBox2D::set_allocated_extri_params(::xsproto::perception::ExtrinsicParameters* extri_params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(extri_params_);
  }
  if (extri_params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      extri_params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, extri_params, submessage_arena);
    }
    
  } else {
    
  }
  extri_params_ = extri_params;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.BBox2D.extri_params)
}

// -------------------------------------------------------------------

// SensorMeasurement

// double timestamp = 1;
inline void SensorMeasurement::clear_timestamp() {
  timestamp_ = 0;
}
inline double SensorMeasurement::timestamp() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.SensorMeasurement.timestamp)
  return timestamp_;
}
inline void SensorMeasurement::set_timestamp(double value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.SensorMeasurement.timestamp)
}

// .xsproto.perception.Point2D center = 2;
inline bool SensorMeasurement::has_center() const {
  return this != internal_default_instance() && center_ != NULL;
}
inline const ::xsproto::perception::Point2D& SensorMeasurement::center() const {
  const ::xsproto::perception::Point2D* p = center_;
  // @@protoc_insertion_point(field_get:xsproto.perception.SensorMeasurement.center)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::Point2D*>(
      &::xsproto::perception::_Point2D_default_instance_);
}
inline ::xsproto::perception::Point2D* SensorMeasurement::release_center() {
  // @@protoc_insertion_point(field_release:xsproto.perception.SensorMeasurement.center)
  
  ::xsproto::perception::Point2D* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::xsproto::perception::Point2D* SensorMeasurement::mutable_center() {
  
  if (center_ == NULL) {
    center_ = new ::xsproto::perception::Point2D;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.SensorMeasurement.center)
  return center_;
}
inline void SensorMeasurement::set_allocated_center(::xsproto::perception::Point2D* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(center_);
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.SensorMeasurement.center)
}

// float width = 3;
inline void SensorMeasurement::clear_width() {
  width_ = 0;
}
inline float SensorMeasurement::width() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.SensorMeasurement.width)
  return width_;
}
inline void SensorMeasurement::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.SensorMeasurement.width)
}

// float length = 4;
inline void SensorMeasurement::clear_length() {
  length_ = 0;
}
inline float SensorMeasurement::length() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.SensorMeasurement.length)
  return length_;
}
inline void SensorMeasurement::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.SensorMeasurement.length)
}

// float r_angle = 5;
inline void SensorMeasurement::clear_r_angle() {
  r_angle_ = 0;
}
inline float SensorMeasurement::r_angle() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.SensorMeasurement.r_angle)
  return r_angle_;
}
inline void SensorMeasurement::set_r_angle(float value) {
  
  r_angle_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.SensorMeasurement.r_angle)
}

// float height_max = 6;
inline void SensorMeasurement::clear_height_max() {
  height_max_ = 0;
}
inline float SensorMeasurement::height_max() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.SensorMeasurement.height_max)
  return height_max_;
}
inline void SensorMeasurement::set_height_max(float value) {
  
  height_max_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.SensorMeasurement.height_max)
}

// float height_min = 7;
inline void SensorMeasurement::clear_height_min() {
  height_min_ = 0;
}
inline float SensorMeasurement::height_min() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.SensorMeasurement.height_min)
  return height_min_;
}
inline void SensorMeasurement::set_height_min(float value) {
  
  height_min_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.SensorMeasurement.height_min)
}

// .xsproto.perception.Area2D corner = 8;
inline bool SensorMeasurement::has_corner() const {
  return this != internal_default_instance() && corner_ != NULL;
}
inline const ::xsproto::perception::Area2D& SensorMeasurement::corner() const {
  const ::xsproto::perception::Area2D* p = corner_;
  // @@protoc_insertion_point(field_get:xsproto.perception.SensorMeasurement.corner)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::Area2D*>(
      &::xsproto::perception::_Area2D_default_instance_);
}
inline ::xsproto::perception::Area2D* SensorMeasurement::release_corner() {
  // @@protoc_insertion_point(field_release:xsproto.perception.SensorMeasurement.corner)
  
  ::xsproto::perception::Area2D* temp = corner_;
  corner_ = NULL;
  return temp;
}
inline ::xsproto::perception::Area2D* SensorMeasurement::mutable_corner() {
  
  if (corner_ == NULL) {
    corner_ = new ::xsproto::perception::Area2D;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.SensorMeasurement.corner)
  return corner_;
}
inline void SensorMeasurement::set_allocated_corner(::xsproto::perception::Area2D* corner) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(corner_);
  }
  if (corner) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      corner = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, corner, submessage_arena);
    }
    
  } else {
    
  }
  corner_ = corner;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.SensorMeasurement.corner)
}

// .xsproto.perception.Area2D border = 9;
inline bool SensorMeasurement::has_border() const {
  return this != internal_default_instance() && border_ != NULL;
}
inline const ::xsproto::perception::Area2D& SensorMeasurement::border() const {
  const ::xsproto::perception::Area2D* p = border_;
  // @@protoc_insertion_point(field_get:xsproto.perception.SensorMeasurement.border)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::Area2D*>(
      &::xsproto::perception::_Area2D_default_instance_);
}
inline ::xsproto::perception::Area2D* SensorMeasurement::release_border() {
  // @@protoc_insertion_point(field_release:xsproto.perception.SensorMeasurement.border)
  
  ::xsproto::perception::Area2D* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::xsproto::perception::Area2D* SensorMeasurement::mutable_border() {
  
  if (border_ == NULL) {
    border_ = new ::xsproto::perception::Area2D;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.SensorMeasurement.border)
  return border_;
}
inline void SensorMeasurement::set_allocated_border(::xsproto::perception::Area2D* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    
  } else {
    
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.SensorMeasurement.border)
}

// -------------------------------------------------------------------

// CarLightStatus

// bool brake = 1;
inline void CarLightStatus::clear_brake() {
  brake_ = false;
}
inline bool CarLightStatus::brake() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.CarLightStatus.brake)
  return brake_;
}
inline void CarLightStatus::set_brake(bool value) {
  
  brake_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.CarLightStatus.brake)
}

// bool left_turn = 2;
inline void CarLightStatus::clear_left_turn() {
  left_turn_ = false;
}
inline bool CarLightStatus::left_turn() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.CarLightStatus.left_turn)
  return left_turn_;
}
inline void CarLightStatus::set_left_turn(bool value) {
  
  left_turn_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.CarLightStatus.left_turn)
}

// bool right_turn = 3;
inline void CarLightStatus::clear_right_turn() {
  right_turn_ = false;
}
inline bool CarLightStatus::right_turn() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.CarLightStatus.right_turn)
  return right_turn_;
}
inline void CarLightStatus::set_right_turn(bool value) {
  
  right_turn_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.CarLightStatus.right_turn)
}

// bool double_flashing = 4;
inline void CarLightStatus::clear_double_flashing() {
  double_flashing_ = false;
}
inline bool CarLightStatus::double_flashing() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.CarLightStatus.double_flashing)
  return double_flashing_;
}
inline void CarLightStatus::set_double_flashing(bool value) {
  
  double_flashing_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.CarLightStatus.double_flashing)
}

// bool backup = 5;
inline void CarLightStatus::clear_backup() {
  backup_ = false;
}
inline bool CarLightStatus::backup() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.CarLightStatus.backup)
  return backup_;
}
inline void CarLightStatus::set_backup(bool value) {
  
  backup_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.CarLightStatus.backup)
}

// -------------------------------------------------------------------

// PerceptionObject

// .xsproto.perception.SourceType source_type = 1;
inline void PerceptionObject::clear_source_type() {
  source_type_ = 0;
}
inline ::xsproto::perception::SourceType PerceptionObject::source_type() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.source_type)
  return static_cast< ::xsproto::perception::SourceType >(source_type_);
}
inline void PerceptionObject::set_source_type(::xsproto::perception::SourceType value) {
  
  source_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.source_type)
}

// uint32 track_id = 2;
inline void PerceptionObject::clear_track_id() {
  track_id_ = 0u;
}
inline ::google::protobuf::uint32 PerceptionObject::track_id() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.track_id)
  return track_id_;
}
inline void PerceptionObject::set_track_id(::google::protobuf::uint32 value) {
  
  track_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.track_id)
}

// .xsproto.perception.TrackState track_state = 3;
inline void PerceptionObject::clear_track_state() {
  track_state_ = 0;
}
inline ::xsproto::perception::TrackState PerceptionObject::track_state() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.track_state)
  return static_cast< ::xsproto::perception::TrackState >(track_state_);
}
inline void PerceptionObject::set_track_state(::xsproto::perception::TrackState value) {
  
  track_state_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.track_state)
}

// double birth_time = 4;
inline void PerceptionObject::clear_birth_time() {
  birth_time_ = 0;
}
inline double PerceptionObject::birth_time() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.birth_time)
  return birth_time_;
}
inline void PerceptionObject::set_birth_time(double value) {
  
  birth_time_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.birth_time)
}

// double loss_time = 5;
inline void PerceptionObject::clear_loss_time() {
  loss_time_ = 0;
}
inline double PerceptionObject::loss_time() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.loss_time)
  return loss_time_;
}
inline void PerceptionObject::set_loss_time(double value) {
  
  loss_time_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.loss_time)
}

// float confidence = 6;
inline void PerceptionObject::clear_confidence() {
  confidence_ = 0;
}
inline float PerceptionObject::confidence() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.confidence)
  return confidence_;
}
inline void PerceptionObject::set_confidence(float value) {
  
  confidence_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.confidence)
}

// .xsproto.perception.ObjType obj_type = 7;
inline void PerceptionObject::clear_obj_type() {
  obj_type_ = 0;
}
inline ::xsproto::perception::ObjType PerceptionObject::obj_type() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.obj_type)
  return static_cast< ::xsproto::perception::ObjType >(obj_type_);
}
inline void PerceptionObject::set_obj_type(::xsproto::perception::ObjType value) {
  
  obj_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.obj_type)
}

// .xsproto.perception.ObjSubType obj_subtype = 8;
inline void PerceptionObject::clear_obj_subtype() {
  obj_subtype_ = 0;
}
inline ::xsproto::perception::ObjSubType PerceptionObject::obj_subtype() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.obj_subtype)
  return static_cast< ::xsproto::perception::ObjSubType >(obj_subtype_);
}
inline void PerceptionObject::set_obj_subtype(::xsproto::perception::ObjSubType value) {
  
  obj_subtype_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.obj_subtype)
}

// .xsproto.perception.Point2D center = 9;
inline bool PerceptionObject::has_center() const {
  return this != internal_default_instance() && center_ != NULL;
}
inline const ::xsproto::perception::Point2D& PerceptionObject::center() const {
  const ::xsproto::perception::Point2D* p = center_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.center)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::Point2D*>(
      &::xsproto::perception::_Point2D_default_instance_);
}
inline ::xsproto::perception::Point2D* PerceptionObject::release_center() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PerceptionObject.center)
  
  ::xsproto::perception::Point2D* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::xsproto::perception::Point2D* PerceptionObject::mutable_center() {
  
  if (center_ == NULL) {
    center_ = new ::xsproto::perception::Point2D;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PerceptionObject.center)
  return center_;
}
inline void PerceptionObject::set_allocated_center(::xsproto::perception::Point2D* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(center_);
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PerceptionObject.center)
}

// float width = 10;
inline void PerceptionObject::clear_width() {
  width_ = 0;
}
inline float PerceptionObject::width() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.width)
  return width_;
}
inline void PerceptionObject::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.width)
}

// float length = 11;
inline void PerceptionObject::clear_length() {
  length_ = 0;
}
inline float PerceptionObject::length() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.length)
  return length_;
}
inline void PerceptionObject::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.length)
}

// float r_angle = 12;
inline void PerceptionObject::clear_r_angle() {
  r_angle_ = 0;
}
inline float PerceptionObject::r_angle() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.r_angle)
  return r_angle_;
}
inline void PerceptionObject::set_r_angle(float value) {
  
  r_angle_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.r_angle)
}

// float height = 13;
inline void PerceptionObject::clear_height() {
  height_ = 0;
}
inline float PerceptionObject::height() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.height)
  return height_;
}
inline void PerceptionObject::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.height)
}

// float height_min = 14;
inline void PerceptionObject::clear_height_min() {
  height_min_ = 0;
}
inline float PerceptionObject::height_min() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.height_min)
  return height_min_;
}
inline void PerceptionObject::set_height_min(float value) {
  
  height_min_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.height_min)
}

// .xsproto.perception.Area2D corner = 15;
inline bool PerceptionObject::has_corner() const {
  return this != internal_default_instance() && corner_ != NULL;
}
inline const ::xsproto::perception::Area2D& PerceptionObject::corner() const {
  const ::xsproto::perception::Area2D* p = corner_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.corner)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::Area2D*>(
      &::xsproto::perception::_Area2D_default_instance_);
}
inline ::xsproto::perception::Area2D* PerceptionObject::release_corner() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PerceptionObject.corner)
  
  ::xsproto::perception::Area2D* temp = corner_;
  corner_ = NULL;
  return temp;
}
inline ::xsproto::perception::Area2D* PerceptionObject::mutable_corner() {
  
  if (corner_ == NULL) {
    corner_ = new ::xsproto::perception::Area2D;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PerceptionObject.corner)
  return corner_;
}
inline void PerceptionObject::set_allocated_corner(::xsproto::perception::Area2D* corner) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(corner_);
  }
  if (corner) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      corner = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, corner, submessage_arena);
    }
    
  } else {
    
  }
  corner_ = corner;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PerceptionObject.corner)
}

// .xsproto.perception.Area2D border = 16;
inline bool PerceptionObject::has_border() const {
  return this != internal_default_instance() && border_ != NULL;
}
inline const ::xsproto::perception::Area2D& PerceptionObject::border() const {
  const ::xsproto::perception::Area2D* p = border_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.border)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::Area2D*>(
      &::xsproto::perception::_Area2D_default_instance_);
}
inline ::xsproto::perception::Area2D* PerceptionObject::release_border() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PerceptionObject.border)
  
  ::xsproto::perception::Area2D* temp = border_;
  border_ = NULL;
  return temp;
}
inline ::xsproto::perception::Area2D* PerceptionObject::mutable_border() {
  
  if (border_ == NULL) {
    border_ = new ::xsproto::perception::Area2D;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PerceptionObject.border)
  return border_;
}
inline void PerceptionObject::set_allocated_border(::xsproto::perception::Area2D* border) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(border_);
  }
  if (border) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      border = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, border, submessage_arena);
    }
    
  } else {
    
  }
  border_ = border;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PerceptionObject.border)
}

// float linear_speed_angle = 17;
inline void PerceptionObject::clear_linear_speed_angle() {
  linear_speed_angle_ = 0;
}
inline float PerceptionObject::linear_speed_angle() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.linear_speed_angle)
  return linear_speed_angle_;
}
inline void PerceptionObject::set_linear_speed_angle(float value) {
  
  linear_speed_angle_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.linear_speed_angle)
}

// float linear_speed = 18;
inline void PerceptionObject::clear_linear_speed() {
  linear_speed_ = 0;
}
inline float PerceptionObject::linear_speed() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.linear_speed)
  return linear_speed_;
}
inline void PerceptionObject::set_linear_speed(float value) {
  
  linear_speed_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.linear_speed)
}

// float angular_speed = 19;
inline void PerceptionObject::clear_angular_speed() {
  angular_speed_ = 0;
}
inline float PerceptionObject::angular_speed() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.angular_speed)
  return angular_speed_;
}
inline void PerceptionObject::set_angular_speed(float value) {
  
  angular_speed_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.angular_speed)
}

// float linear_acc = 20;
inline void PerceptionObject::clear_linear_acc() {
  linear_acc_ = 0;
}
inline float PerceptionObject::linear_acc() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.linear_acc)
  return linear_acc_;
}
inline void PerceptionObject::set_linear_acc(float value) {
  
  linear_acc_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.linear_acc)
}

// float tracking_stability = 21;
inline void PerceptionObject::clear_tracking_stability() {
  tracking_stability_ = 0;
}
inline float PerceptionObject::tracking_stability() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.tracking_stability)
  return tracking_stability_;
}
inline void PerceptionObject::set_tracking_stability(float value) {
  
  tracking_stability_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.tracking_stability)
}

// repeated .xsproto.perception.SensorMeasurement measurements = 22;
inline int PerceptionObject::measurements_size() const {
  return measurements_.size();
}
inline void PerceptionObject::clear_measurements() {
  measurements_.Clear();
}
inline const ::xsproto::perception::SensorMeasurement& PerceptionObject::measurements(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.measurements)
  return measurements_.Get(index);
}
inline ::xsproto::perception::SensorMeasurement* PerceptionObject::mutable_measurements(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PerceptionObject.measurements)
  return measurements_.Mutable(index);
}
inline ::xsproto::perception::SensorMeasurement* PerceptionObject::add_measurements() {
  // @@protoc_insertion_point(field_add:xsproto.perception.PerceptionObject.measurements)
  return measurements_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::perception::SensorMeasurement >*
PerceptionObject::mutable_measurements() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.PerceptionObject.measurements)
  return &measurements_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::SensorMeasurement >&
PerceptionObject::measurements() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.PerceptionObject.measurements)
  return measurements_;
}

// .xsproto.perception.BBox2D camera_box2d = 23;
inline bool PerceptionObject::has_camera_box2d() const {
  return this != internal_default_instance() && camera_box2d_ != NULL;
}
inline void PerceptionObject::clear_camera_box2d() {
  if (GetArenaNoVirtual() == NULL && camera_box2d_ != NULL) {
    delete camera_box2d_;
  }
  camera_box2d_ = NULL;
}
inline const ::xsproto::perception::BBox2D& PerceptionObject::camera_box2d() const {
  const ::xsproto::perception::BBox2D* p = camera_box2d_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.camera_box2d)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::BBox2D*>(
      &::xsproto::perception::_BBox2D_default_instance_);
}
inline ::xsproto::perception::BBox2D* PerceptionObject::release_camera_box2d() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PerceptionObject.camera_box2d)
  
  ::xsproto::perception::BBox2D* temp = camera_box2d_;
  camera_box2d_ = NULL;
  return temp;
}
inline ::xsproto::perception::BBox2D* PerceptionObject::mutable_camera_box2d() {
  
  if (camera_box2d_ == NULL) {
    camera_box2d_ = new ::xsproto::perception::BBox2D;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PerceptionObject.camera_box2d)
  return camera_box2d_;
}
inline void PerceptionObject::set_allocated_camera_box2d(::xsproto::perception::BBox2D* camera_box2d) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete camera_box2d_;
  }
  if (camera_box2d) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      camera_box2d = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, camera_box2d, submessage_arena);
    }
    
  } else {
    
  }
  camera_box2d_ = camera_box2d;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PerceptionObject.camera_box2d)
}

// .xsproto.perception.CarLightStatus car_light_status = 24;
inline bool PerceptionObject::has_car_light_status() const {
  return this != internal_default_instance() && car_light_status_ != NULL;
}
inline void PerceptionObject::clear_car_light_status() {
  if (GetArenaNoVirtual() == NULL && car_light_status_ != NULL) {
    delete car_light_status_;
  }
  car_light_status_ = NULL;
}
inline const ::xsproto::perception::CarLightStatus& PerceptionObject::car_light_status() const {
  const ::xsproto::perception::CarLightStatus* p = car_light_status_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.car_light_status)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::CarLightStatus*>(
      &::xsproto::perception::_CarLightStatus_default_instance_);
}
inline ::xsproto::perception::CarLightStatus* PerceptionObject::release_car_light_status() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PerceptionObject.car_light_status)
  
  ::xsproto::perception::CarLightStatus* temp = car_light_status_;
  car_light_status_ = NULL;
  return temp;
}
inline ::xsproto::perception::CarLightStatus* PerceptionObject::mutable_car_light_status() {
  
  if (car_light_status_ == NULL) {
    car_light_status_ = new ::xsproto::perception::CarLightStatus;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PerceptionObject.car_light_status)
  return car_light_status_;
}
inline void PerceptionObject::set_allocated_car_light_status(::xsproto::perception::CarLightStatus* car_light_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete car_light_status_;
  }
  if (car_light_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      car_light_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, car_light_status, submessage_arena);
    }
    
  } else {
    
  }
  car_light_status_ = car_light_status;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PerceptionObject.car_light_status)
}

// repeated .xsproto.perception.PersonPosture person_posture = 25;
inline int PerceptionObject::person_posture_size() const {
  return person_posture_.size();
}
inline void PerceptionObject::clear_person_posture() {
  person_posture_.Clear();
}
inline ::xsproto::perception::PersonPosture PerceptionObject::person_posture(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObject.person_posture)
  return static_cast< ::xsproto::perception::PersonPosture >(person_posture_.Get(index));
}
inline void PerceptionObject::set_person_posture(int index, ::xsproto::perception::PersonPosture value) {
  person_posture_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObject.person_posture)
}
inline void PerceptionObject::add_person_posture(::xsproto::perception::PersonPosture value) {
  person_posture_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.perception.PerceptionObject.person_posture)
}
inline const ::google::protobuf::RepeatedField<int>&
PerceptionObject::person_posture() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.PerceptionObject.person_posture)
  return person_posture_;
}
inline ::google::protobuf::RepeatedField<int>*
PerceptionObject::mutable_person_posture() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.PerceptionObject.person_posture)
  return &person_posture_;
}

// -------------------------------------------------------------------

// StaticObstacle

// .xsproto.perception.ObjSubType obj_subtype = 1;
inline void StaticObstacle::clear_obj_subtype() {
  obj_subtype_ = 0;
}
inline ::xsproto::perception::ObjSubType StaticObstacle::obj_subtype() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.StaticObstacle.obj_subtype)
  return static_cast< ::xsproto::perception::ObjSubType >(obj_subtype_);
}
inline void StaticObstacle::set_obj_subtype(::xsproto::perception::ObjSubType value) {
  
  obj_subtype_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.StaticObstacle.obj_subtype)
}

// .xsproto.perception.Area2D area = 2;
inline bool StaticObstacle::has_area() const {
  return this != internal_default_instance() && area_ != NULL;
}
inline const ::xsproto::perception::Area2D& StaticObstacle::area() const {
  const ::xsproto::perception::Area2D* p = area_;
  // @@protoc_insertion_point(field_get:xsproto.perception.StaticObstacle.area)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::Area2D*>(
      &::xsproto::perception::_Area2D_default_instance_);
}
inline ::xsproto::perception::Area2D* StaticObstacle::release_area() {
  // @@protoc_insertion_point(field_release:xsproto.perception.StaticObstacle.area)
  
  ::xsproto::perception::Area2D* temp = area_;
  area_ = NULL;
  return temp;
}
inline ::xsproto::perception::Area2D* StaticObstacle::mutable_area() {
  
  if (area_ == NULL) {
    area_ = new ::xsproto::perception::Area2D;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.StaticObstacle.area)
  return area_;
}
inline void StaticObstacle::set_allocated_area(::xsproto::perception::Area2D* area) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(area_);
  }
  if (area) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      area = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, area, submessage_arena);
    }
    
  } else {
    
  }
  area_ = area;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.StaticObstacle.area)
}

// float max_height = 3;
inline void StaticObstacle::clear_max_height() {
  max_height_ = 0;
}
inline float StaticObstacle::max_height() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.StaticObstacle.max_height)
  return max_height_;
}
inline void StaticObstacle::set_max_height(float value) {
  
  max_height_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.StaticObstacle.max_height)
}

// float min_height = 4;
inline void StaticObstacle::clear_min_height() {
  min_height_ = 0;
}
inline float StaticObstacle::min_height() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.StaticObstacle.min_height)
  return min_height_;
}
inline void StaticObstacle::set_min_height(float value) {
  
  min_height_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.StaticObstacle.min_height)
}

// -------------------------------------------------------------------

// PerceptionObjectInfo

// .xsproto.base.Header header = 1;
inline bool PerceptionObjectInfo::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::xsproto::base::Header& PerceptionObjectInfo::header() const {
  const ::xsproto::base::Header* p = header_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObjectInfo.header)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::base::Header*>(
      &::xsproto::base::_Header_default_instance_);
}
inline ::xsproto::base::Header* PerceptionObjectInfo::release_header() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PerceptionObjectInfo.header)
  
  ::xsproto::base::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::xsproto::base::Header* PerceptionObjectInfo::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::xsproto::base::Header;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PerceptionObjectInfo.header)
  return header_;
}
inline void PerceptionObjectInfo::set_allocated_header(::xsproto::base::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PerceptionObjectInfo.header)
}

// repeated .xsproto.perception.PerceptionObject obs_objs = 2;
inline int PerceptionObjectInfo::obs_objs_size() const {
  return obs_objs_.size();
}
inline void PerceptionObjectInfo::clear_obs_objs() {
  obs_objs_.Clear();
}
inline const ::xsproto::perception::PerceptionObject& PerceptionObjectInfo::obs_objs(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObjectInfo.obs_objs)
  return obs_objs_.Get(index);
}
inline ::xsproto::perception::PerceptionObject* PerceptionObjectInfo::mutable_obs_objs(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PerceptionObjectInfo.obs_objs)
  return obs_objs_.Mutable(index);
}
inline ::xsproto::perception::PerceptionObject* PerceptionObjectInfo::add_obs_objs() {
  // @@protoc_insertion_point(field_add:xsproto.perception.PerceptionObjectInfo.obs_objs)
  return obs_objs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PerceptionObject >*
PerceptionObjectInfo::mutable_obs_objs() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.PerceptionObjectInfo.obs_objs)
  return &obs_objs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PerceptionObject >&
PerceptionObjectInfo::obs_objs() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.PerceptionObjectInfo.obs_objs)
  return obs_objs_;
}

// repeated .xsproto.perception.StaticObstacle obstacle_areas = 3;
inline int PerceptionObjectInfo::obstacle_areas_size() const {
  return obstacle_areas_.size();
}
inline void PerceptionObjectInfo::clear_obstacle_areas() {
  obstacle_areas_.Clear();
}
inline const ::xsproto::perception::StaticObstacle& PerceptionObjectInfo::obstacle_areas(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObjectInfo.obstacle_areas)
  return obstacle_areas_.Get(index);
}
inline ::xsproto::perception::StaticObstacle* PerceptionObjectInfo::mutable_obstacle_areas(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PerceptionObjectInfo.obstacle_areas)
  return obstacle_areas_.Mutable(index);
}
inline ::xsproto::perception::StaticObstacle* PerceptionObjectInfo::add_obstacle_areas() {
  // @@protoc_insertion_point(field_add:xsproto.perception.PerceptionObjectInfo.obstacle_areas)
  return obstacle_areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::perception::StaticObstacle >*
PerceptionObjectInfo::mutable_obstacle_areas() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.PerceptionObjectInfo.obstacle_areas)
  return &obstacle_areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::StaticObstacle >&
PerceptionObjectInfo::obstacle_areas() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.PerceptionObjectInfo.obstacle_areas)
  return obstacle_areas_;
}

// repeated .xsproto.perception.Point2D obstacle_points = 4;
inline int PerceptionObjectInfo::obstacle_points_size() const {
  return obstacle_points_.size();
}
inline const ::xsproto::perception::Point2D& PerceptionObjectInfo::obstacle_points(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObjectInfo.obstacle_points)
  return obstacle_points_.Get(index);
}
inline ::xsproto::perception::Point2D* PerceptionObjectInfo::mutable_obstacle_points(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PerceptionObjectInfo.obstacle_points)
  return obstacle_points_.Mutable(index);
}
inline ::xsproto::perception::Point2D* PerceptionObjectInfo::add_obstacle_points() {
  // @@protoc_insertion_point(field_add:xsproto.perception.PerceptionObjectInfo.obstacle_points)
  return obstacle_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Point2D >*
PerceptionObjectInfo::mutable_obstacle_points() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.PerceptionObjectInfo.obstacle_points)
  return &obstacle_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Point2D >&
PerceptionObjectInfo::obstacle_points() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.PerceptionObjectInfo.obstacle_points)
  return obstacle_points_;
}

// repeated .xsproto.perception.Point3D obstacle_voxel = 5;
inline int PerceptionObjectInfo::obstacle_voxel_size() const {
  return obstacle_voxel_.size();
}
inline const ::xsproto::perception::Point3D& PerceptionObjectInfo::obstacle_voxel(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObjectInfo.obstacle_voxel)
  return obstacle_voxel_.Get(index);
}
inline ::xsproto::perception::Point3D* PerceptionObjectInfo::mutable_obstacle_voxel(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PerceptionObjectInfo.obstacle_voxel)
  return obstacle_voxel_.Mutable(index);
}
inline ::xsproto::perception::Point3D* PerceptionObjectInfo::add_obstacle_voxel() {
  // @@protoc_insertion_point(field_add:xsproto.perception.PerceptionObjectInfo.obstacle_voxel)
  return obstacle_voxel_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Point3D >*
PerceptionObjectInfo::mutable_obstacle_voxel() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.PerceptionObjectInfo.obstacle_voxel)
  return &obstacle_voxel_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Point3D >&
PerceptionObjectInfo::obstacle_voxel() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.PerceptionObjectInfo.obstacle_voxel)
  return obstacle_voxel_;
}

// bytes obstcle_data = 6;
inline void PerceptionObjectInfo::clear_obstcle_data() {
  obstcle_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PerceptionObjectInfo::obstcle_data() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PerceptionObjectInfo.obstcle_data)
  return obstcle_data_.GetNoArena();
}
inline void PerceptionObjectInfo::set_obstcle_data(const ::std::string& value) {
  
  obstcle_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.perception.PerceptionObjectInfo.obstcle_data)
}
#if LANG_CXX11
inline void PerceptionObjectInfo::set_obstcle_data(::std::string&& value) {
  
  obstcle_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.perception.PerceptionObjectInfo.obstcle_data)
}
#endif
inline void PerceptionObjectInfo::set_obstcle_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  obstcle_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.perception.PerceptionObjectInfo.obstcle_data)
}
inline void PerceptionObjectInfo::set_obstcle_data(const void* value, size_t size) {
  
  obstcle_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.perception.PerceptionObjectInfo.obstcle_data)
}
inline ::std::string* PerceptionObjectInfo::mutable_obstcle_data() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PerceptionObjectInfo.obstcle_data)
  return obstcle_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PerceptionObjectInfo::release_obstcle_data() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PerceptionObjectInfo.obstcle_data)
  
  return obstcle_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PerceptionObjectInfo::set_allocated_obstcle_data(::std::string* obstcle_data) {
  if (obstcle_data != NULL) {
    
  } else {
    
  }
  obstcle_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), obstcle_data);
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PerceptionObjectInfo.obstcle_data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception
}  // namespace xsproto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::xsproto::perception::ObjType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::perception::ObjType>() {
  return ::xsproto::perception::ObjType_descriptor();
}
template <> struct is_proto_enum< ::xsproto::perception::ObjSubType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::perception::ObjSubType>() {
  return ::xsproto::perception::ObjSubType_descriptor();
}
template <> struct is_proto_enum< ::xsproto::perception::PersonPosture> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::perception::PersonPosture>() {
  return ::xsproto::perception::PersonPosture_descriptor();
}
template <> struct is_proto_enum< ::xsproto::perception::SourceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::perception::SourceType>() {
  return ::xsproto::perception::SourceType_descriptor();
}
template <> struct is_proto_enum< ::xsproto::perception::TrackState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::perception::TrackState>() {
  return ::xsproto::perception::TrackState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perception_2fperception_5fobject_5finfo_2eproto__INCLUDED
