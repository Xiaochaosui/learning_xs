// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: control/lqr_config.proto

#ifndef PROTOBUF_control_2flqr_5fconfig_2eproto__INCLUDED
#define PROTOBUF_control_2flqr_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_control_2flqr_5fconfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsLQRParamImpl();
void InitDefaultsLQRParam();
void InitDefaultsVehicleParamImpl();
void InitDefaultsVehicleParam();
void InitDefaultsControlGainImpl();
void InitDefaultsControlGain();
void InitDefaultsLqrParamImpl();
void InitDefaultsLqrParam();
void InitDefaultsLatErrGainSchedulerImpl();
void InitDefaultsLatErrGainScheduler();
void InitDefaultsHeadingErrGainSchedulerImpl();
void InitDefaultsHeadingErrGainScheduler();
void InitDefaultsLeadLagParamImpl();
void InitDefaultsLeadLagParam();
void InitDefaultsComfortParamImpl();
void InitDefaultsComfortParam();
void InitDefaultsK_VInfoImpl();
void InitDefaultsK_VInfo();
inline void InitDefaults() {
  InitDefaultsLQRParam();
  InitDefaultsVehicleParam();
  InitDefaultsControlGain();
  InitDefaultsLqrParam();
  InitDefaultsLatErrGainScheduler();
  InitDefaultsHeadingErrGainScheduler();
  InitDefaultsLeadLagParam();
  InitDefaultsComfortParam();
  InitDefaultsK_VInfo();
}
}  // namespace protobuf_control_2flqr_5fconfig_2eproto
namespace LQR {
class ComfortParam;
class ComfortParamDefaultTypeInternal;
extern ComfortParamDefaultTypeInternal _ComfortParam_default_instance_;
class ControlGain;
class ControlGainDefaultTypeInternal;
extern ControlGainDefaultTypeInternal _ControlGain_default_instance_;
class HeadingErrGainScheduler;
class HeadingErrGainSchedulerDefaultTypeInternal;
extern HeadingErrGainSchedulerDefaultTypeInternal _HeadingErrGainScheduler_default_instance_;
class K_VInfo;
class K_VInfoDefaultTypeInternal;
extern K_VInfoDefaultTypeInternal _K_VInfo_default_instance_;
class LQRParam;
class LQRParamDefaultTypeInternal;
extern LQRParamDefaultTypeInternal _LQRParam_default_instance_;
class LatErrGainScheduler;
class LatErrGainSchedulerDefaultTypeInternal;
extern LatErrGainSchedulerDefaultTypeInternal _LatErrGainScheduler_default_instance_;
class LeadLagParam;
class LeadLagParamDefaultTypeInternal;
extern LeadLagParamDefaultTypeInternal _LeadLagParam_default_instance_;
class LqrParam;
class LqrParamDefaultTypeInternal;
extern LqrParamDefaultTypeInternal _LqrParam_default_instance_;
class VehicleParam;
class VehicleParamDefaultTypeInternal;
extern VehicleParamDefaultTypeInternal _VehicleParam_default_instance_;
}  // namespace LQR
namespace LQR {

// ===================================================================

class LQRParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LQR.LQRParam) */ {
 public:
  LQRParam();
  virtual ~LQRParam();

  LQRParam(const LQRParam& from);

  inline LQRParam& operator=(const LQRParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LQRParam(LQRParam&& from) noexcept
    : LQRParam() {
    *this = ::std::move(from);
  }

  inline LQRParam& operator=(LQRParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LQRParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LQRParam* internal_default_instance() {
    return reinterpret_cast<const LQRParam*>(
               &_LQRParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LQRParam* other);
  friend void swap(LQRParam& a, LQRParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LQRParam* New() const PROTOBUF_FINAL { return New(NULL); }

  LQRParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LQRParam& from);
  void MergeFrom(const LQRParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LQRParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .LQR.K_VInfo v_k_info = 4;
  int v_k_info_size() const;
  void clear_v_k_info();
  static const int kVKInfoFieldNumber = 4;
  const ::LQR::K_VInfo& v_k_info(int index) const;
  ::LQR::K_VInfo* mutable_v_k_info(int index);
  ::LQR::K_VInfo* add_v_k_info();
  ::google::protobuf::RepeatedPtrField< ::LQR::K_VInfo >*
      mutable_v_k_info();
  const ::google::protobuf::RepeatedPtrField< ::LQR::K_VInfo >&
      v_k_info() const;

  // optional .LQR.VehicleParam vehicleparam = 1;
  bool has_vehicleparam() const;
  void clear_vehicleparam();
  static const int kVehicleparamFieldNumber = 1;
  const ::LQR::VehicleParam& vehicleparam() const;
  ::LQR::VehicleParam* release_vehicleparam();
  ::LQR::VehicleParam* mutable_vehicleparam();
  void set_allocated_vehicleparam(::LQR::VehicleParam* vehicleparam);

  // optional .LQR.ControlGain controlgain = 2;
  bool has_controlgain() const;
  void clear_controlgain();
  static const int kControlgainFieldNumber = 2;
  const ::LQR::ControlGain& controlgain() const;
  ::LQR::ControlGain* release_controlgain();
  ::LQR::ControlGain* mutable_controlgain();
  void set_allocated_controlgain(::LQR::ControlGain* controlgain);

  // optional .LQR.LqrParam lqrparam = 3;
  bool has_lqrparam() const;
  void clear_lqrparam();
  static const int kLqrparamFieldNumber = 3;
  const ::LQR::LqrParam& lqrparam() const;
  ::LQR::LqrParam* release_lqrparam();
  ::LQR::LqrParam* mutable_lqrparam();
  void set_allocated_lqrparam(::LQR::LqrParam* lqrparam);

  // optional .LQR.LeadLagParam leadlagparam = 5;
  bool has_leadlagparam() const;
  void clear_leadlagparam();
  static const int kLeadlagparamFieldNumber = 5;
  const ::LQR::LeadLagParam& leadlagparam() const;
  ::LQR::LeadLagParam* release_leadlagparam();
  ::LQR::LeadLagParam* mutable_leadlagparam();
  void set_allocated_leadlagparam(::LQR::LeadLagParam* leadlagparam);

  // optional .LQR.LatErrGainScheduler lat_err_gain_scheduler = 6;
  bool has_lat_err_gain_scheduler() const;
  void clear_lat_err_gain_scheduler();
  static const int kLatErrGainSchedulerFieldNumber = 6;
  const ::LQR::LatErrGainScheduler& lat_err_gain_scheduler() const;
  ::LQR::LatErrGainScheduler* release_lat_err_gain_scheduler();
  ::LQR::LatErrGainScheduler* mutable_lat_err_gain_scheduler();
  void set_allocated_lat_err_gain_scheduler(::LQR::LatErrGainScheduler* lat_err_gain_scheduler);

  // optional .LQR.HeadingErrGainScheduler heading_err_gain_scheduler = 7;
  bool has_heading_err_gain_scheduler() const;
  void clear_heading_err_gain_scheduler();
  static const int kHeadingErrGainSchedulerFieldNumber = 7;
  const ::LQR::HeadingErrGainScheduler& heading_err_gain_scheduler() const;
  ::LQR::HeadingErrGainScheduler* release_heading_err_gain_scheduler();
  ::LQR::HeadingErrGainScheduler* mutable_heading_err_gain_scheduler();
  void set_allocated_heading_err_gain_scheduler(::LQR::HeadingErrGainScheduler* heading_err_gain_scheduler);

  // optional .LQR.ComfortParam comfortparam = 8;
  bool has_comfortparam() const;
  void clear_comfortparam();
  static const int kComfortparamFieldNumber = 8;
  const ::LQR::ComfortParam& comfortparam() const;
  ::LQR::ComfortParam* release_comfortparam();
  ::LQR::ComfortParam* mutable_comfortparam();
  void set_allocated_comfortparam(::LQR::ComfortParam* comfortparam);

  // @@protoc_insertion_point(class_scope:LQR.LQRParam)
 private:
  void set_has_vehicleparam();
  void clear_has_vehicleparam();
  void set_has_controlgain();
  void clear_has_controlgain();
  void set_has_lqrparam();
  void clear_has_lqrparam();
  void set_has_leadlagparam();
  void clear_has_leadlagparam();
  void set_has_lat_err_gain_scheduler();
  void clear_has_lat_err_gain_scheduler();
  void set_has_heading_err_gain_scheduler();
  void clear_has_heading_err_gain_scheduler();
  void set_has_comfortparam();
  void clear_has_comfortparam();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::LQR::K_VInfo > v_k_info_;
  ::LQR::VehicleParam* vehicleparam_;
  ::LQR::ControlGain* controlgain_;
  ::LQR::LqrParam* lqrparam_;
  ::LQR::LeadLagParam* leadlagparam_;
  ::LQR::LatErrGainScheduler* lat_err_gain_scheduler_;
  ::LQR::HeadingErrGainScheduler* heading_err_gain_scheduler_;
  ::LQR::ComfortParam* comfortparam_;
  friend struct ::protobuf_control_2flqr_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flqr_5fconfig_2eproto::InitDefaultsLQRParamImpl();
};
// -------------------------------------------------------------------

class VehicleParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LQR.VehicleParam) */ {
 public:
  VehicleParam();
  virtual ~VehicleParam();

  VehicleParam(const VehicleParam& from);

  inline VehicleParam& operator=(const VehicleParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleParam(VehicleParam&& from) noexcept
    : VehicleParam() {
    *this = ::std::move(from);
  }

  inline VehicleParam& operator=(VehicleParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleParam* internal_default_instance() {
    return reinterpret_cast<const VehicleParam*>(
               &_VehicleParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(VehicleParam* other);
  friend void swap(VehicleParam& a, VehicleParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleParam* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleParam& from);
  void MergeFrom(const VehicleParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float caf = 1;
  bool has_caf() const;
  void clear_caf();
  static const int kCafFieldNumber = 1;
  float caf() const;
  void set_caf(float value);

  // optional float car = 2;
  bool has_car() const;
  void clear_car();
  static const int kCarFieldNumber = 2;
  float car() const;
  void set_car(float value);

  // optional float lf = 3;
  bool has_lf() const;
  void clear_lf();
  static const int kLfFieldNumber = 3;
  float lf() const;
  void set_lf(float value);

  // optional float lr = 4;
  bool has_lr() const;
  void clear_lr();
  static const int kLrFieldNumber = 4;
  float lr() const;
  void set_lr(float value);

  // optional float m = 5;
  bool has_m() const;
  void clear_m();
  static const int kMFieldNumber = 5;
  float m() const;
  void set_m(float value);

  // optional float iz = 6;
  bool has_iz() const;
  void clear_iz();
  static const int kIzFieldNumber = 6;
  float iz() const;
  void set_iz(float value);

  // optional float wheel_base = 7;
  bool has_wheel_base() const;
  void clear_wheel_base();
  static const int kWheelBaseFieldNumber = 7;
  float wheel_base() const;
  void set_wheel_base(float value);

  // optional float front_wheel_limit = 8;
  bool has_front_wheel_limit() const;
  void clear_front_wheel_limit();
  static const int kFrontWheelLimitFieldNumber = 8;
  float front_wheel_limit() const;
  void set_front_wheel_limit(float value);

  // optional float steer_ratio = 9;
  bool has_steer_ratio() const;
  void clear_steer_ratio();
  static const int kSteerRatioFieldNumber = 9;
  float steer_ratio() const;
  void set_steer_ratio(float value);

  // @@protoc_insertion_point(class_scope:LQR.VehicleParam)
 private:
  void set_has_caf();
  void clear_has_caf();
  void set_has_car();
  void clear_has_car();
  void set_has_lf();
  void clear_has_lf();
  void set_has_lr();
  void clear_has_lr();
  void set_has_m();
  void clear_has_m();
  void set_has_iz();
  void clear_has_iz();
  void set_has_wheel_base();
  void clear_has_wheel_base();
  void set_has_front_wheel_limit();
  void clear_has_front_wheel_limit();
  void set_has_steer_ratio();
  void clear_has_steer_ratio();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float caf_;
  float car_;
  float lf_;
  float lr_;
  float m_;
  float iz_;
  float wheel_base_;
  float front_wheel_limit_;
  float steer_ratio_;
  friend struct ::protobuf_control_2flqr_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flqr_5fconfig_2eproto::InitDefaultsVehicleParamImpl();
};
// -------------------------------------------------------------------

class ControlGain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LQR.ControlGain) */ {
 public:
  ControlGain();
  virtual ~ControlGain();

  ControlGain(const ControlGain& from);

  inline ControlGain& operator=(const ControlGain& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ControlGain(ControlGain&& from) noexcept
    : ControlGain() {
    *this = ::std::move(from);
  }

  inline ControlGain& operator=(ControlGain&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlGain& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlGain* internal_default_instance() {
    return reinterpret_cast<const ControlGain*>(
               &_ControlGain_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ControlGain* other);
  friend void swap(ControlGain& a, ControlGain& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ControlGain* New() const PROTOBUF_FINAL { return New(NULL); }

  ControlGain* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControlGain& from);
  void MergeFrom(const ControlGain& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControlGain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float r = 5 [default = 1];
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 5;
  float r() const;
  void set_r(float value);

  // optional float q1 = 1 [default = 1];
  bool has_q1() const;
  void clear_q1();
  static const int kQ1FieldNumber = 1;
  float q1() const;
  void set_q1(float value);

  // optional float q2 = 2 [default = 1];
  bool has_q2() const;
  void clear_q2();
  static const int kQ2FieldNumber = 2;
  float q2() const;
  void set_q2(float value);

  // optional float q3 = 3 [default = 1];
  bool has_q3() const;
  void clear_q3();
  static const int kQ3FieldNumber = 3;
  float q3() const;
  void set_q3(float value);

  // optional float q4 = 4 [default = 1];
  bool has_q4() const;
  void clear_q4();
  static const int kQ4FieldNumber = 4;
  float q4() const;
  void set_q4(float value);

  // @@protoc_insertion_point(class_scope:LQR.ControlGain)
 private:
  void set_has_q1();
  void clear_has_q1();
  void set_has_q2();
  void clear_has_q2();
  void set_has_q3();
  void clear_has_q3();
  void set_has_q4();
  void clear_has_q4();
  void set_has_r();
  void clear_has_r();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float r_;
  float q1_;
  float q2_;
  float q3_;
  float q4_;
  friend struct ::protobuf_control_2flqr_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flqr_5fconfig_2eproto::InitDefaultsControlGainImpl();
};
// -------------------------------------------------------------------

class LqrParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LQR.LqrParam) */ {
 public:
  LqrParam();
  virtual ~LqrParam();

  LqrParam(const LqrParam& from);

  inline LqrParam& operator=(const LqrParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LqrParam(LqrParam&& from) noexcept
    : LqrParam() {
    *this = ::std::move(from);
  }

  inline LqrParam& operator=(LqrParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LqrParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LqrParam* internal_default_instance() {
    return reinterpret_cast<const LqrParam*>(
               &_LqrParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(LqrParam* other);
  friend void swap(LqrParam& a, LqrParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LqrParam* New() const PROTOBUF_FINAL { return New(NULL); }

  LqrParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LqrParam& from);
  void MergeFrom(const LqrParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LqrParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float ts = 1;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 1;
  float ts() const;
  void set_ts(float value);

  // optional float lqr_eps = 2;
  bool has_lqr_eps() const;
  void clear_lqr_eps();
  static const int kLqrEpsFieldNumber = 2;
  float lqr_eps() const;
  void set_lqr_eps(float value);

  // optional float max_iteration = 3;
  bool has_max_iteration() const;
  void clear_max_iteration();
  static const int kMaxIterationFieldNumber = 3;
  float max_iteration() const;
  void set_max_iteration(float value);

  // optional float minimum_speed_protection = 4;
  bool has_minimum_speed_protection() const;
  void clear_minimum_speed_protection();
  static const int kMinimumSpeedProtectionFieldNumber = 4;
  float minimum_speed_protection() const;
  void set_minimum_speed_protection(float value);

  // optional double back_minimum_target_distance = 8;
  bool has_back_minimum_target_distance() const;
  void clear_back_minimum_target_distance();
  static const int kBackMinimumTargetDistanceFieldNumber = 8;
  double back_minimum_target_distance() const;
  void set_back_minimum_target_distance(double value);

  // optional float plan_speed = 7;
  bool has_plan_speed() const;
  void clear_plan_speed();
  static const int kPlanSpeedFieldNumber = 7;
  float plan_speed() const;
  void set_plan_speed(float value);

  // optional bool compute_k = 5;
  bool has_compute_k() const;
  void clear_compute_k();
  static const int kComputeKFieldNumber = 5;
  bool compute_k() const;
  void set_compute_k(bool value);

  // optional bool follow_the_planned_speed = 6;
  bool has_follow_the_planned_speed() const;
  void clear_follow_the_planned_speed();
  static const int kFollowThePlannedSpeedFieldNumber = 6;
  bool follow_the_planned_speed() const;
  void set_follow_the_planned_speed(bool value);

  // optional bool flags_speed_planning_osqp = 11;
  bool has_flags_speed_planning_osqp() const;
  void clear_flags_speed_planning_osqp();
  static const int kFlagsSpeedPlanningOsqpFieldNumber = 11;
  bool flags_speed_planning_osqp() const;
  void set_flags_speed_planning_osqp(bool value);

  // optional bool flags_use_acc_control = 12;
  bool has_flags_use_acc_control() const;
  void clear_flags_use_acc_control();
  static const int kFlagsUseAccControlFieldNumber = 12;
  bool flags_use_acc_control() const;
  void set_flags_use_acc_control(bool value);

  // optional double back_maximum_lateral_error = 9;
  bool has_back_maximum_lateral_error() const;
  void clear_back_maximum_lateral_error();
  static const int kBackMaximumLateralErrorFieldNumber = 9;
  double back_maximum_lateral_error() const;
  void set_back_maximum_lateral_error(double value);

  // optional double back_maximum_heading_error = 10;
  bool has_back_maximum_heading_error() const;
  void clear_back_maximum_heading_error();
  static const int kBackMaximumHeadingErrorFieldNumber = 10;
  double back_maximum_heading_error() const;
  void set_back_maximum_heading_error(double value);

  // optional double digital_filter_forward_freq = 16;
  bool has_digital_filter_forward_freq() const;
  void clear_digital_filter_forward_freq();
  static const int kDigitalFilterForwardFreqFieldNumber = 16;
  double digital_filter_forward_freq() const;
  void set_digital_filter_forward_freq(double value);

  // optional double maximum_lateral_error = 17;
  bool has_maximum_lateral_error() const;
  void clear_maximum_lateral_error();
  static const int kMaximumLateralErrorFieldNumber = 17;
  double maximum_lateral_error() const;
  void set_maximum_lateral_error(double value);

  // optional double maximum_heading_error = 18;
  bool has_maximum_heading_error() const;
  void clear_maximum_heading_error();
  static const int kMaximumHeadingErrorFieldNumber = 18;
  double maximum_heading_error() const;
  void set_maximum_heading_error(double value);

  // optional double preview_time = 19;
  bool has_preview_time() const;
  void clear_preview_time();
  static const int kPreviewTimeFieldNumber = 19;
  double preview_time() const;
  void set_preview_time(double value);

  // optional bool flags_record_data_txt = 13;
  bool has_flags_record_data_txt() const;
  void clear_flags_record_data_txt();
  static const int kFlagsRecordDataTxtFieldNumber = 13;
  bool flags_record_data_txt() const;
  void set_flags_record_data_txt(bool value);

  // optional bool flags_use_old_heading = 14;
  bool has_flags_use_old_heading() const;
  void clear_flags_use_old_heading();
  static const int kFlagsUseOldHeadingFieldNumber = 14;
  bool flags_use_old_heading() const;
  void set_flags_use_old_heading(bool value);

  // optional bool flags_printf_plan_data = 15;
  bool has_flags_printf_plan_data() const;
  void clear_flags_printf_plan_data();
  static const int kFlagsPrintfPlanDataFieldNumber = 15;
  bool flags_printf_plan_data() const;
  void set_flags_printf_plan_data(bool value);

  // optional bool flags_printf_lqr_data = 26;
  bool has_flags_printf_lqr_data() const;
  void clear_flags_printf_lqr_data();
  static const int kFlagsPrintfLqrDataFieldNumber = 26;
  bool flags_printf_lqr_data() const;
  void set_flags_printf_lqr_data(bool value);

  // optional bool reserved_parameter_b = 28;
  bool has_reserved_parameter_b() const;
  void clear_reserved_parameter_b();
  static const int kReservedParameterBFieldNumber = 28;
  bool reserved_parameter_b() const;
  void set_reserved_parameter_b(bool value);

  // optional double minimum_preview_distance = 20;
  bool has_minimum_preview_distance() const;
  void clear_minimum_preview_distance();
  static const int kMinimumPreviewDistanceFieldNumber = 20;
  double minimum_preview_distance() const;
  void set_minimum_preview_distance(double value);

  // optional double target_time = 21;
  bool has_target_time() const;
  void clear_target_time();
  static const int kTargetTimeFieldNumber = 21;
  double target_time() const;
  void set_target_time(double value);

  // optional double minimum_target_distance = 22;
  bool has_minimum_target_distance() const;
  void clear_minimum_target_distance();
  static const int kMinimumTargetDistanceFieldNumber = 22;
  double minimum_target_distance() const;
  void set_minimum_target_distance(double value);

  // optional double curvature_reduction = 23;
  bool has_curvature_reduction() const;
  void clear_curvature_reduction();
  static const int kCurvatureReductionFieldNumber = 23;
  double curvature_reduction() const;
  void set_curvature_reduction(double value);

  // optional double steering_delay = 24;
  bool has_steering_delay() const;
  void clear_steering_delay();
  static const int kSteeringDelayFieldNumber = 24;
  double steering_delay() const;
  void set_steering_delay(double value);

  // optional double digital_filter_k_freq = 25;
  bool has_digital_filter_k_freq() const;
  void clear_digital_filter_k_freq();
  static const int kDigitalFilterKFreqFieldNumber = 25;
  double digital_filter_k_freq() const;
  void set_digital_filter_k_freq(double value);

  // optional double reserved_parameter_a = 27;
  bool has_reserved_parameter_a() const;
  void clear_reserved_parameter_a();
  static const int kReservedParameterAFieldNumber = 27;
  double reserved_parameter_a() const;
  void set_reserved_parameter_a(double value);

  // @@protoc_insertion_point(class_scope:LQR.LqrParam)
 private:
  void set_has_ts();
  void clear_has_ts();
  void set_has_lqr_eps();
  void clear_has_lqr_eps();
  void set_has_max_iteration();
  void clear_has_max_iteration();
  void set_has_minimum_speed_protection();
  void clear_has_minimum_speed_protection();
  void set_has_compute_k();
  void clear_has_compute_k();
  void set_has_follow_the_planned_speed();
  void clear_has_follow_the_planned_speed();
  void set_has_plan_speed();
  void clear_has_plan_speed();
  void set_has_back_minimum_target_distance();
  void clear_has_back_minimum_target_distance();
  void set_has_back_maximum_lateral_error();
  void clear_has_back_maximum_lateral_error();
  void set_has_back_maximum_heading_error();
  void clear_has_back_maximum_heading_error();
  void set_has_flags_speed_planning_osqp();
  void clear_has_flags_speed_planning_osqp();
  void set_has_flags_use_acc_control();
  void clear_has_flags_use_acc_control();
  void set_has_flags_record_data_txt();
  void clear_has_flags_record_data_txt();
  void set_has_flags_use_old_heading();
  void clear_has_flags_use_old_heading();
  void set_has_flags_printf_plan_data();
  void clear_has_flags_printf_plan_data();
  void set_has_digital_filter_forward_freq();
  void clear_has_digital_filter_forward_freq();
  void set_has_maximum_lateral_error();
  void clear_has_maximum_lateral_error();
  void set_has_maximum_heading_error();
  void clear_has_maximum_heading_error();
  void set_has_preview_time();
  void clear_has_preview_time();
  void set_has_minimum_preview_distance();
  void clear_has_minimum_preview_distance();
  void set_has_target_time();
  void clear_has_target_time();
  void set_has_minimum_target_distance();
  void clear_has_minimum_target_distance();
  void set_has_curvature_reduction();
  void clear_has_curvature_reduction();
  void set_has_steering_delay();
  void clear_has_steering_delay();
  void set_has_digital_filter_k_freq();
  void clear_has_digital_filter_k_freq();
  void set_has_flags_printf_lqr_data();
  void clear_has_flags_printf_lqr_data();
  void set_has_reserved_parameter_a();
  void clear_has_reserved_parameter_a();
  void set_has_reserved_parameter_b();
  void clear_has_reserved_parameter_b();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float ts_;
  float lqr_eps_;
  float max_iteration_;
  float minimum_speed_protection_;
  double back_minimum_target_distance_;
  float plan_speed_;
  bool compute_k_;
  bool follow_the_planned_speed_;
  bool flags_speed_planning_osqp_;
  bool flags_use_acc_control_;
  double back_maximum_lateral_error_;
  double back_maximum_heading_error_;
  double digital_filter_forward_freq_;
  double maximum_lateral_error_;
  double maximum_heading_error_;
  double preview_time_;
  bool flags_record_data_txt_;
  bool flags_use_old_heading_;
  bool flags_printf_plan_data_;
  bool flags_printf_lqr_data_;
  bool reserved_parameter_b_;
  double minimum_preview_distance_;
  double target_time_;
  double minimum_target_distance_;
  double curvature_reduction_;
  double steering_delay_;
  double digital_filter_k_freq_;
  double reserved_parameter_a_;
  friend struct ::protobuf_control_2flqr_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flqr_5fconfig_2eproto::InitDefaultsLqrParamImpl();
};
// -------------------------------------------------------------------

class LatErrGainScheduler : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LQR.LatErrGainScheduler) */ {
 public:
  LatErrGainScheduler();
  virtual ~LatErrGainScheduler();

  LatErrGainScheduler(const LatErrGainScheduler& from);

  inline LatErrGainScheduler& operator=(const LatErrGainScheduler& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LatErrGainScheduler(LatErrGainScheduler&& from) noexcept
    : LatErrGainScheduler() {
    *this = ::std::move(from);
  }

  inline LatErrGainScheduler& operator=(LatErrGainScheduler&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LatErrGainScheduler& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LatErrGainScheduler* internal_default_instance() {
    return reinterpret_cast<const LatErrGainScheduler*>(
               &_LatErrGainScheduler_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(LatErrGainScheduler* other);
  friend void swap(LatErrGainScheduler& a, LatErrGainScheduler& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LatErrGainScheduler* New() const PROTOBUF_FINAL { return New(NULL); }

  LatErrGainScheduler* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LatErrGainScheduler& from);
  void MergeFrom(const LatErrGainScheduler& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LatErrGainScheduler* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double scheduler_0 = 1;
  bool has_scheduler_0() const;
  void clear_scheduler_0();
  static const int kScheduler0FieldNumber = 1;
  double scheduler_0() const;
  void set_scheduler_0(double value);

  // optional double scheduler_1_5 = 2;
  bool has_scheduler_1_5() const;
  void clear_scheduler_1_5();
  static const int kScheduler15FieldNumber = 2;
  double scheduler_1_5() const;
  void set_scheduler_1_5(double value);

  // optional double scheduler_3 = 3;
  bool has_scheduler_3() const;
  void clear_scheduler_3();
  static const int kScheduler3FieldNumber = 3;
  double scheduler_3() const;
  void set_scheduler_3(double value);

  // optional double scheduler_6 = 4;
  bool has_scheduler_6() const;
  void clear_scheduler_6();
  static const int kScheduler6FieldNumber = 4;
  double scheduler_6() const;
  void set_scheduler_6(double value);

  // optional double scheduler_12 = 5;
  bool has_scheduler_12() const;
  void clear_scheduler_12();
  static const int kScheduler12FieldNumber = 5;
  double scheduler_12() const;
  void set_scheduler_12(double value);

  // optional double scheduler_20 = 6;
  bool has_scheduler_20() const;
  void clear_scheduler_20();
  static const int kScheduler20FieldNumber = 6;
  double scheduler_20() const;
  void set_scheduler_20(double value);

  // @@protoc_insertion_point(class_scope:LQR.LatErrGainScheduler)
 private:
  void set_has_scheduler_0();
  void clear_has_scheduler_0();
  void set_has_scheduler_1_5();
  void clear_has_scheduler_1_5();
  void set_has_scheduler_3();
  void clear_has_scheduler_3();
  void set_has_scheduler_6();
  void clear_has_scheduler_6();
  void set_has_scheduler_12();
  void clear_has_scheduler_12();
  void set_has_scheduler_20();
  void clear_has_scheduler_20();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double scheduler_0_;
  double scheduler_1_5_;
  double scheduler_3_;
  double scheduler_6_;
  double scheduler_12_;
  double scheduler_20_;
  friend struct ::protobuf_control_2flqr_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flqr_5fconfig_2eproto::InitDefaultsLatErrGainSchedulerImpl();
};
// -------------------------------------------------------------------

class HeadingErrGainScheduler : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LQR.HeadingErrGainScheduler) */ {
 public:
  HeadingErrGainScheduler();
  virtual ~HeadingErrGainScheduler();

  HeadingErrGainScheduler(const HeadingErrGainScheduler& from);

  inline HeadingErrGainScheduler& operator=(const HeadingErrGainScheduler& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeadingErrGainScheduler(HeadingErrGainScheduler&& from) noexcept
    : HeadingErrGainScheduler() {
    *this = ::std::move(from);
  }

  inline HeadingErrGainScheduler& operator=(HeadingErrGainScheduler&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeadingErrGainScheduler& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeadingErrGainScheduler* internal_default_instance() {
    return reinterpret_cast<const HeadingErrGainScheduler*>(
               &_HeadingErrGainScheduler_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(HeadingErrGainScheduler* other);
  friend void swap(HeadingErrGainScheduler& a, HeadingErrGainScheduler& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeadingErrGainScheduler* New() const PROTOBUF_FINAL { return New(NULL); }

  HeadingErrGainScheduler* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HeadingErrGainScheduler& from);
  void MergeFrom(const HeadingErrGainScheduler& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HeadingErrGainScheduler* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double scheduler_0 = 1;
  bool has_scheduler_0() const;
  void clear_scheduler_0();
  static const int kScheduler0FieldNumber = 1;
  double scheduler_0() const;
  void set_scheduler_0(double value);

  // optional double scheduler_1_5 = 2;
  bool has_scheduler_1_5() const;
  void clear_scheduler_1_5();
  static const int kScheduler15FieldNumber = 2;
  double scheduler_1_5() const;
  void set_scheduler_1_5(double value);

  // optional double scheduler_3 = 3;
  bool has_scheduler_3() const;
  void clear_scheduler_3();
  static const int kScheduler3FieldNumber = 3;
  double scheduler_3() const;
  void set_scheduler_3(double value);

  // optional double scheduler_6 = 4;
  bool has_scheduler_6() const;
  void clear_scheduler_6();
  static const int kScheduler6FieldNumber = 4;
  double scheduler_6() const;
  void set_scheduler_6(double value);

  // optional double scheduler_12 = 5;
  bool has_scheduler_12() const;
  void clear_scheduler_12();
  static const int kScheduler12FieldNumber = 5;
  double scheduler_12() const;
  void set_scheduler_12(double value);

  // optional double scheduler_20 = 6;
  bool has_scheduler_20() const;
  void clear_scheduler_20();
  static const int kScheduler20FieldNumber = 6;
  double scheduler_20() const;
  void set_scheduler_20(double value);

  // @@protoc_insertion_point(class_scope:LQR.HeadingErrGainScheduler)
 private:
  void set_has_scheduler_0();
  void clear_has_scheduler_0();
  void set_has_scheduler_1_5();
  void clear_has_scheduler_1_5();
  void set_has_scheduler_3();
  void clear_has_scheduler_3();
  void set_has_scheduler_6();
  void clear_has_scheduler_6();
  void set_has_scheduler_12();
  void clear_has_scheduler_12();
  void set_has_scheduler_20();
  void clear_has_scheduler_20();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double scheduler_0_;
  double scheduler_1_5_;
  double scheduler_3_;
  double scheduler_6_;
  double scheduler_12_;
  double scheduler_20_;
  friend struct ::protobuf_control_2flqr_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flqr_5fconfig_2eproto::InitDefaultsHeadingErrGainSchedulerImpl();
};
// -------------------------------------------------------------------

class LeadLagParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LQR.LeadLagParam) */ {
 public:
  LeadLagParam();
  virtual ~LeadLagParam();

  LeadLagParam(const LeadLagParam& from);

  inline LeadLagParam& operator=(const LeadLagParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeadLagParam(LeadLagParam&& from) noexcept
    : LeadLagParam() {
    *this = ::std::move(from);
  }

  inline LeadLagParam& operator=(LeadLagParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeadLagParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeadLagParam* internal_default_instance() {
    return reinterpret_cast<const LeadLagParam*>(
               &_LeadLagParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(LeadLagParam* other);
  friend void swap(LeadLagParam& a, LeadLagParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeadLagParam* New() const PROTOBUF_FINAL { return New(NULL); }

  LeadLagParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LeadLagParam& from);
  void MergeFrom(const LeadLagParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LeadLagParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double innerstate_saturation_level = 1;
  bool has_innerstate_saturation_level() const;
  void clear_innerstate_saturation_level();
  static const int kInnerstateSaturationLevelFieldNumber = 1;
  double innerstate_saturation_level() const;
  void set_innerstate_saturation_level(double value);

  // optional double alpha = 2;
  bool has_alpha() const;
  void clear_alpha();
  static const int kAlphaFieldNumber = 2;
  double alpha() const;
  void set_alpha(double value);

  // optional double beta = 3;
  bool has_beta() const;
  void clear_beta();
  static const int kBetaFieldNumber = 3;
  double beta() const;
  void set_beta(double value);

  // optional double tau = 4;
  bool has_tau() const;
  void clear_tau();
  static const int kTauFieldNumber = 4;
  double tau() const;
  void set_tau(double value);

  // @@protoc_insertion_point(class_scope:LQR.LeadLagParam)
 private:
  void set_has_innerstate_saturation_level();
  void clear_has_innerstate_saturation_level();
  void set_has_alpha();
  void clear_has_alpha();
  void set_has_beta();
  void clear_has_beta();
  void set_has_tau();
  void clear_has_tau();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double innerstate_saturation_level_;
  double alpha_;
  double beta_;
  double tau_;
  friend struct ::protobuf_control_2flqr_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flqr_5fconfig_2eproto::InitDefaultsLeadLagParamImpl();
};
// -------------------------------------------------------------------

class ComfortParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LQR.ComfortParam) */ {
 public:
  ComfortParam();
  virtual ~ComfortParam();

  ComfortParam(const ComfortParam& from);

  inline ComfortParam& operator=(const ComfortParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ComfortParam(ComfortParam&& from) noexcept
    : ComfortParam() {
    *this = ::std::move(from);
  }

  inline ComfortParam& operator=(ComfortParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComfortParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ComfortParam* internal_default_instance() {
    return reinterpret_cast<const ComfortParam*>(
               &_ComfortParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ComfortParam* other);
  friend void swap(ComfortParam& a, ComfortParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ComfortParam* New() const PROTOBUF_FINAL { return New(NULL); }

  ComfortParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ComfortParam& from);
  void MergeFrom(const ComfortParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ComfortParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double max_lat_acc_ = 2;
  bool has_max_lat_acc_() const;
  void clear_max_lat_acc_();
  static const int kMaxLatAccFieldNumber = 2;
  double max_lat_acc_() const;
  void set_max_lat_acc_(double value);

  // optional double cutoff_freq = 4;
  bool has_cutoff_freq() const;
  void clear_cutoff_freq();
  static const int kCutoffFreqFieldNumber = 4;
  double cutoff_freq() const;
  void set_cutoff_freq(double value);

  // optional double mean_filter_window_size = 5;
  bool has_mean_filter_window_size() const;
  void clear_mean_filter_window_size();
  static const int kMeanFilterWindowSizeFieldNumber = 5;
  double mean_filter_window_size() const;
  void set_mean_filter_window_size(double value);

  // optional double max_steer_angle_rate = 7;
  bool has_max_steer_angle_rate() const;
  void clear_max_steer_angle_rate();
  static const int kMaxSteerAngleRateFieldNumber = 7;
  double max_steer_angle_rate() const;
  void set_max_steer_angle_rate(double value);

  // optional bool flags_set_steer_limit = 1;
  bool has_flags_set_steer_limit() const;
  void clear_flags_set_steer_limit();
  static const int kFlagsSetSteerLimitFieldNumber = 1;
  bool flags_set_steer_limit() const;
  void set_flags_set_steer_limit(bool value);

  // optional bool flags_steering_digital_filter = 3;
  bool has_flags_steering_digital_filter() const;
  void clear_flags_steering_digital_filter();
  static const int kFlagsSteeringDigitalFilterFieldNumber = 3;
  bool flags_steering_digital_filter() const;
  void set_flags_steering_digital_filter(bool value);

  // optional bool flags_enable_maximum_steer_rate_limit = 6;
  bool has_flags_enable_maximum_steer_rate_limit() const;
  void clear_flags_enable_maximum_steer_rate_limit();
  static const int kFlagsEnableMaximumSteerRateLimitFieldNumber = 6;
  bool flags_enable_maximum_steer_rate_limit() const;
  void set_flags_enable_maximum_steer_rate_limit(bool value);

  // optional bool flags_enable_minimum_steer_rate_limit = 8;
  bool has_flags_enable_minimum_steer_rate_limit() const;
  void clear_flags_enable_minimum_steer_rate_limit();
  static const int kFlagsEnableMinimumSteerRateLimitFieldNumber = 8;
  bool flags_enable_minimum_steer_rate_limit() const;
  void set_flags_enable_minimum_steer_rate_limit(bool value);

  // optional bool flags_steer_median_filtering = 10;
  bool has_flags_steer_median_filtering() const;
  void clear_flags_steer_median_filtering();
  static const int kFlagsSteerMedianFilteringFieldNumber = 10;
  bool flags_steer_median_filtering() const;
  void set_flags_steer_median_filtering(bool value);

  // optional bool look_ahead_index_by_k_mean = 12;
  bool has_look_ahead_index_by_k_mean() const;
  void clear_look_ahead_index_by_k_mean();
  static const int kLookAheadIndexByKMeanFieldNumber = 12;
  bool look_ahead_index_by_k_mean() const;
  void set_look_ahead_index_by_k_mean(bool value);

  // optional bool look_ahead_index_by_k_median = 14;
  bool has_look_ahead_index_by_k_median() const;
  void clear_look_ahead_index_by_k_median();
  static const int kLookAheadIndexByKMedianFieldNumber = 14;
  bool look_ahead_index_by_k_median() const;
  void set_look_ahead_index_by_k_median(bool value);

  // optional double min_steer_angle_rate = 9;
  bool has_min_steer_angle_rate() const;
  void clear_min_steer_angle_rate();
  static const int kMinSteerAngleRateFieldNumber = 9;
  double min_steer_angle_rate() const;
  void set_min_steer_angle_rate(double value);

  // optional double steer_angle_median_num = 11;
  bool has_steer_angle_median_num() const;
  void clear_steer_angle_median_num();
  static const int kSteerAngleMedianNumFieldNumber = 11;
  double steer_angle_median_num() const;
  void set_steer_angle_median_num(double value);

  // optional double target_point_windows_by_k_mean = 13;
  bool has_target_point_windows_by_k_mean() const;
  void clear_target_point_windows_by_k_mean();
  static const int kTargetPointWindowsByKMeanFieldNumber = 13;
  double target_point_windows_by_k_mean() const;
  void set_target_point_windows_by_k_mean(double value);

  // optional double target_point_windows_by_k_median = 15;
  bool has_target_point_windows_by_k_median() const;
  void clear_target_point_windows_by_k_median();
  static const int kTargetPointWindowsByKMedianFieldNumber = 15;
  double target_point_windows_by_k_median() const;
  void set_target_point_windows_by_k_median(double value);

  // @@protoc_insertion_point(class_scope:LQR.ComfortParam)
 private:
  void set_has_flags_set_steer_limit();
  void clear_has_flags_set_steer_limit();
  void set_has_max_lat_acc_();
  void clear_has_max_lat_acc_();
  void set_has_flags_steering_digital_filter();
  void clear_has_flags_steering_digital_filter();
  void set_has_cutoff_freq();
  void clear_has_cutoff_freq();
  void set_has_mean_filter_window_size();
  void clear_has_mean_filter_window_size();
  void set_has_flags_enable_maximum_steer_rate_limit();
  void clear_has_flags_enable_maximum_steer_rate_limit();
  void set_has_max_steer_angle_rate();
  void clear_has_max_steer_angle_rate();
  void set_has_flags_enable_minimum_steer_rate_limit();
  void clear_has_flags_enable_minimum_steer_rate_limit();
  void set_has_min_steer_angle_rate();
  void clear_has_min_steer_angle_rate();
  void set_has_flags_steer_median_filtering();
  void clear_has_flags_steer_median_filtering();
  void set_has_steer_angle_median_num();
  void clear_has_steer_angle_median_num();
  void set_has_look_ahead_index_by_k_mean();
  void clear_has_look_ahead_index_by_k_mean();
  void set_has_target_point_windows_by_k_mean();
  void clear_has_target_point_windows_by_k_mean();
  void set_has_look_ahead_index_by_k_median();
  void clear_has_look_ahead_index_by_k_median();
  void set_has_target_point_windows_by_k_median();
  void clear_has_target_point_windows_by_k_median();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double max_lat_acc__;
  double cutoff_freq_;
  double mean_filter_window_size_;
  double max_steer_angle_rate_;
  bool flags_set_steer_limit_;
  bool flags_steering_digital_filter_;
  bool flags_enable_maximum_steer_rate_limit_;
  bool flags_enable_minimum_steer_rate_limit_;
  bool flags_steer_median_filtering_;
  bool look_ahead_index_by_k_mean_;
  bool look_ahead_index_by_k_median_;
  double min_steer_angle_rate_;
  double steer_angle_median_num_;
  double target_point_windows_by_k_mean_;
  double target_point_windows_by_k_median_;
  friend struct ::protobuf_control_2flqr_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flqr_5fconfig_2eproto::InitDefaultsComfortParamImpl();
};
// -------------------------------------------------------------------

class K_VInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LQR.K_VInfo) */ {
 public:
  K_VInfo();
  virtual ~K_VInfo();

  K_VInfo(const K_VInfo& from);

  inline K_VInfo& operator=(const K_VInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  K_VInfo(K_VInfo&& from) noexcept
    : K_VInfo() {
    *this = ::std::move(from);
  }

  inline K_VInfo& operator=(K_VInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const K_VInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const K_VInfo* internal_default_instance() {
    return reinterpret_cast<const K_VInfo*>(
               &_K_VInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(K_VInfo* other);
  friend void swap(K_VInfo& a, K_VInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline K_VInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  K_VInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const K_VInfo& from);
  void MergeFrom(const K_VInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(K_VInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double speed = 1;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 1;
  double speed() const;
  void set_speed(double value);

  // optional double k1 = 2;
  bool has_k1() const;
  void clear_k1();
  static const int kK1FieldNumber = 2;
  double k1() const;
  void set_k1(double value);

  // optional double k2 = 3;
  bool has_k2() const;
  void clear_k2();
  static const int kK2FieldNumber = 3;
  double k2() const;
  void set_k2(double value);

  // optional double k3 = 4;
  bool has_k3() const;
  void clear_k3();
  static const int kK3FieldNumber = 4;
  double k3() const;
  void set_k3(double value);

  // optional double k4 = 5;
  bool has_k4() const;
  void clear_k4();
  static const int kK4FieldNumber = 5;
  double k4() const;
  void set_k4(double value);

  // @@protoc_insertion_point(class_scope:LQR.K_VInfo)
 private:
  void set_has_speed();
  void clear_has_speed();
  void set_has_k1();
  void clear_has_k1();
  void set_has_k2();
  void clear_has_k2();
  void set_has_k3();
  void clear_has_k3();
  void set_has_k4();
  void clear_has_k4();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double speed_;
  double k1_;
  double k2_;
  double k3_;
  double k4_;
  friend struct ::protobuf_control_2flqr_5fconfig_2eproto::TableStruct;
  friend void ::protobuf_control_2flqr_5fconfig_2eproto::InitDefaultsK_VInfoImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LQRParam

// optional .LQR.VehicleParam vehicleparam = 1;
inline bool LQRParam::has_vehicleparam() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LQRParam::set_has_vehicleparam() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LQRParam::clear_has_vehicleparam() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LQRParam::clear_vehicleparam() {
  if (vehicleparam_ != NULL) vehicleparam_->Clear();
  clear_has_vehicleparam();
}
inline const ::LQR::VehicleParam& LQRParam::vehicleparam() const {
  const ::LQR::VehicleParam* p = vehicleparam_;
  // @@protoc_insertion_point(field_get:LQR.LQRParam.vehicleparam)
  return p != NULL ? *p : *reinterpret_cast<const ::LQR::VehicleParam*>(
      &::LQR::_VehicleParam_default_instance_);
}
inline ::LQR::VehicleParam* LQRParam::release_vehicleparam() {
  // @@protoc_insertion_point(field_release:LQR.LQRParam.vehicleparam)
  clear_has_vehicleparam();
  ::LQR::VehicleParam* temp = vehicleparam_;
  vehicleparam_ = NULL;
  return temp;
}
inline ::LQR::VehicleParam* LQRParam::mutable_vehicleparam() {
  set_has_vehicleparam();
  if (vehicleparam_ == NULL) {
    vehicleparam_ = new ::LQR::VehicleParam;
  }
  // @@protoc_insertion_point(field_mutable:LQR.LQRParam.vehicleparam)
  return vehicleparam_;
}
inline void LQRParam::set_allocated_vehicleparam(::LQR::VehicleParam* vehicleparam) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vehicleparam_;
  }
  if (vehicleparam) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vehicleparam = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vehicleparam, submessage_arena);
    }
    set_has_vehicleparam();
  } else {
    clear_has_vehicleparam();
  }
  vehicleparam_ = vehicleparam;
  // @@protoc_insertion_point(field_set_allocated:LQR.LQRParam.vehicleparam)
}

// optional .LQR.ControlGain controlgain = 2;
inline bool LQRParam::has_controlgain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LQRParam::set_has_controlgain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LQRParam::clear_has_controlgain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LQRParam::clear_controlgain() {
  if (controlgain_ != NULL) controlgain_->Clear();
  clear_has_controlgain();
}
inline const ::LQR::ControlGain& LQRParam::controlgain() const {
  const ::LQR::ControlGain* p = controlgain_;
  // @@protoc_insertion_point(field_get:LQR.LQRParam.controlgain)
  return p != NULL ? *p : *reinterpret_cast<const ::LQR::ControlGain*>(
      &::LQR::_ControlGain_default_instance_);
}
inline ::LQR::ControlGain* LQRParam::release_controlgain() {
  // @@protoc_insertion_point(field_release:LQR.LQRParam.controlgain)
  clear_has_controlgain();
  ::LQR::ControlGain* temp = controlgain_;
  controlgain_ = NULL;
  return temp;
}
inline ::LQR::ControlGain* LQRParam::mutable_controlgain() {
  set_has_controlgain();
  if (controlgain_ == NULL) {
    controlgain_ = new ::LQR::ControlGain;
  }
  // @@protoc_insertion_point(field_mutable:LQR.LQRParam.controlgain)
  return controlgain_;
}
inline void LQRParam::set_allocated_controlgain(::LQR::ControlGain* controlgain) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete controlgain_;
  }
  if (controlgain) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      controlgain = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controlgain, submessage_arena);
    }
    set_has_controlgain();
  } else {
    clear_has_controlgain();
  }
  controlgain_ = controlgain;
  // @@protoc_insertion_point(field_set_allocated:LQR.LQRParam.controlgain)
}

// optional .LQR.LqrParam lqrparam = 3;
inline bool LQRParam::has_lqrparam() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LQRParam::set_has_lqrparam() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LQRParam::clear_has_lqrparam() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LQRParam::clear_lqrparam() {
  if (lqrparam_ != NULL) lqrparam_->Clear();
  clear_has_lqrparam();
}
inline const ::LQR::LqrParam& LQRParam::lqrparam() const {
  const ::LQR::LqrParam* p = lqrparam_;
  // @@protoc_insertion_point(field_get:LQR.LQRParam.lqrparam)
  return p != NULL ? *p : *reinterpret_cast<const ::LQR::LqrParam*>(
      &::LQR::_LqrParam_default_instance_);
}
inline ::LQR::LqrParam* LQRParam::release_lqrparam() {
  // @@protoc_insertion_point(field_release:LQR.LQRParam.lqrparam)
  clear_has_lqrparam();
  ::LQR::LqrParam* temp = lqrparam_;
  lqrparam_ = NULL;
  return temp;
}
inline ::LQR::LqrParam* LQRParam::mutable_lqrparam() {
  set_has_lqrparam();
  if (lqrparam_ == NULL) {
    lqrparam_ = new ::LQR::LqrParam;
  }
  // @@protoc_insertion_point(field_mutable:LQR.LQRParam.lqrparam)
  return lqrparam_;
}
inline void LQRParam::set_allocated_lqrparam(::LQR::LqrParam* lqrparam) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lqrparam_;
  }
  if (lqrparam) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lqrparam = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lqrparam, submessage_arena);
    }
    set_has_lqrparam();
  } else {
    clear_has_lqrparam();
  }
  lqrparam_ = lqrparam;
  // @@protoc_insertion_point(field_set_allocated:LQR.LQRParam.lqrparam)
}

// repeated .LQR.K_VInfo v_k_info = 4;
inline int LQRParam::v_k_info_size() const {
  return v_k_info_.size();
}
inline void LQRParam::clear_v_k_info() {
  v_k_info_.Clear();
}
inline const ::LQR::K_VInfo& LQRParam::v_k_info(int index) const {
  // @@protoc_insertion_point(field_get:LQR.LQRParam.v_k_info)
  return v_k_info_.Get(index);
}
inline ::LQR::K_VInfo* LQRParam::mutable_v_k_info(int index) {
  // @@protoc_insertion_point(field_mutable:LQR.LQRParam.v_k_info)
  return v_k_info_.Mutable(index);
}
inline ::LQR::K_VInfo* LQRParam::add_v_k_info() {
  // @@protoc_insertion_point(field_add:LQR.LQRParam.v_k_info)
  return v_k_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::LQR::K_VInfo >*
LQRParam::mutable_v_k_info() {
  // @@protoc_insertion_point(field_mutable_list:LQR.LQRParam.v_k_info)
  return &v_k_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::LQR::K_VInfo >&
LQRParam::v_k_info() const {
  // @@protoc_insertion_point(field_list:LQR.LQRParam.v_k_info)
  return v_k_info_;
}

// optional .LQR.LeadLagParam leadlagparam = 5;
inline bool LQRParam::has_leadlagparam() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LQRParam::set_has_leadlagparam() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LQRParam::clear_has_leadlagparam() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LQRParam::clear_leadlagparam() {
  if (leadlagparam_ != NULL) leadlagparam_->Clear();
  clear_has_leadlagparam();
}
inline const ::LQR::LeadLagParam& LQRParam::leadlagparam() const {
  const ::LQR::LeadLagParam* p = leadlagparam_;
  // @@protoc_insertion_point(field_get:LQR.LQRParam.leadlagparam)
  return p != NULL ? *p : *reinterpret_cast<const ::LQR::LeadLagParam*>(
      &::LQR::_LeadLagParam_default_instance_);
}
inline ::LQR::LeadLagParam* LQRParam::release_leadlagparam() {
  // @@protoc_insertion_point(field_release:LQR.LQRParam.leadlagparam)
  clear_has_leadlagparam();
  ::LQR::LeadLagParam* temp = leadlagparam_;
  leadlagparam_ = NULL;
  return temp;
}
inline ::LQR::LeadLagParam* LQRParam::mutable_leadlagparam() {
  set_has_leadlagparam();
  if (leadlagparam_ == NULL) {
    leadlagparam_ = new ::LQR::LeadLagParam;
  }
  // @@protoc_insertion_point(field_mutable:LQR.LQRParam.leadlagparam)
  return leadlagparam_;
}
inline void LQRParam::set_allocated_leadlagparam(::LQR::LeadLagParam* leadlagparam) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete leadlagparam_;
  }
  if (leadlagparam) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      leadlagparam = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leadlagparam, submessage_arena);
    }
    set_has_leadlagparam();
  } else {
    clear_has_leadlagparam();
  }
  leadlagparam_ = leadlagparam;
  // @@protoc_insertion_point(field_set_allocated:LQR.LQRParam.leadlagparam)
}

// optional .LQR.LatErrGainScheduler lat_err_gain_scheduler = 6;
inline bool LQRParam::has_lat_err_gain_scheduler() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LQRParam::set_has_lat_err_gain_scheduler() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LQRParam::clear_has_lat_err_gain_scheduler() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LQRParam::clear_lat_err_gain_scheduler() {
  if (lat_err_gain_scheduler_ != NULL) lat_err_gain_scheduler_->Clear();
  clear_has_lat_err_gain_scheduler();
}
inline const ::LQR::LatErrGainScheduler& LQRParam::lat_err_gain_scheduler() const {
  const ::LQR::LatErrGainScheduler* p = lat_err_gain_scheduler_;
  // @@protoc_insertion_point(field_get:LQR.LQRParam.lat_err_gain_scheduler)
  return p != NULL ? *p : *reinterpret_cast<const ::LQR::LatErrGainScheduler*>(
      &::LQR::_LatErrGainScheduler_default_instance_);
}
inline ::LQR::LatErrGainScheduler* LQRParam::release_lat_err_gain_scheduler() {
  // @@protoc_insertion_point(field_release:LQR.LQRParam.lat_err_gain_scheduler)
  clear_has_lat_err_gain_scheduler();
  ::LQR::LatErrGainScheduler* temp = lat_err_gain_scheduler_;
  lat_err_gain_scheduler_ = NULL;
  return temp;
}
inline ::LQR::LatErrGainScheduler* LQRParam::mutable_lat_err_gain_scheduler() {
  set_has_lat_err_gain_scheduler();
  if (lat_err_gain_scheduler_ == NULL) {
    lat_err_gain_scheduler_ = new ::LQR::LatErrGainScheduler;
  }
  // @@protoc_insertion_point(field_mutable:LQR.LQRParam.lat_err_gain_scheduler)
  return lat_err_gain_scheduler_;
}
inline void LQRParam::set_allocated_lat_err_gain_scheduler(::LQR::LatErrGainScheduler* lat_err_gain_scheduler) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lat_err_gain_scheduler_;
  }
  if (lat_err_gain_scheduler) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lat_err_gain_scheduler = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lat_err_gain_scheduler, submessage_arena);
    }
    set_has_lat_err_gain_scheduler();
  } else {
    clear_has_lat_err_gain_scheduler();
  }
  lat_err_gain_scheduler_ = lat_err_gain_scheduler;
  // @@protoc_insertion_point(field_set_allocated:LQR.LQRParam.lat_err_gain_scheduler)
}

// optional .LQR.HeadingErrGainScheduler heading_err_gain_scheduler = 7;
inline bool LQRParam::has_heading_err_gain_scheduler() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LQRParam::set_has_heading_err_gain_scheduler() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LQRParam::clear_has_heading_err_gain_scheduler() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LQRParam::clear_heading_err_gain_scheduler() {
  if (heading_err_gain_scheduler_ != NULL) heading_err_gain_scheduler_->Clear();
  clear_has_heading_err_gain_scheduler();
}
inline const ::LQR::HeadingErrGainScheduler& LQRParam::heading_err_gain_scheduler() const {
  const ::LQR::HeadingErrGainScheduler* p = heading_err_gain_scheduler_;
  // @@protoc_insertion_point(field_get:LQR.LQRParam.heading_err_gain_scheduler)
  return p != NULL ? *p : *reinterpret_cast<const ::LQR::HeadingErrGainScheduler*>(
      &::LQR::_HeadingErrGainScheduler_default_instance_);
}
inline ::LQR::HeadingErrGainScheduler* LQRParam::release_heading_err_gain_scheduler() {
  // @@protoc_insertion_point(field_release:LQR.LQRParam.heading_err_gain_scheduler)
  clear_has_heading_err_gain_scheduler();
  ::LQR::HeadingErrGainScheduler* temp = heading_err_gain_scheduler_;
  heading_err_gain_scheduler_ = NULL;
  return temp;
}
inline ::LQR::HeadingErrGainScheduler* LQRParam::mutable_heading_err_gain_scheduler() {
  set_has_heading_err_gain_scheduler();
  if (heading_err_gain_scheduler_ == NULL) {
    heading_err_gain_scheduler_ = new ::LQR::HeadingErrGainScheduler;
  }
  // @@protoc_insertion_point(field_mutable:LQR.LQRParam.heading_err_gain_scheduler)
  return heading_err_gain_scheduler_;
}
inline void LQRParam::set_allocated_heading_err_gain_scheduler(::LQR::HeadingErrGainScheduler* heading_err_gain_scheduler) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete heading_err_gain_scheduler_;
  }
  if (heading_err_gain_scheduler) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      heading_err_gain_scheduler = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, heading_err_gain_scheduler, submessage_arena);
    }
    set_has_heading_err_gain_scheduler();
  } else {
    clear_has_heading_err_gain_scheduler();
  }
  heading_err_gain_scheduler_ = heading_err_gain_scheduler;
  // @@protoc_insertion_point(field_set_allocated:LQR.LQRParam.heading_err_gain_scheduler)
}

// optional .LQR.ComfortParam comfortparam = 8;
inline bool LQRParam::has_comfortparam() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LQRParam::set_has_comfortparam() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LQRParam::clear_has_comfortparam() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LQRParam::clear_comfortparam() {
  if (comfortparam_ != NULL) comfortparam_->Clear();
  clear_has_comfortparam();
}
inline const ::LQR::ComfortParam& LQRParam::comfortparam() const {
  const ::LQR::ComfortParam* p = comfortparam_;
  // @@protoc_insertion_point(field_get:LQR.LQRParam.comfortparam)
  return p != NULL ? *p : *reinterpret_cast<const ::LQR::ComfortParam*>(
      &::LQR::_ComfortParam_default_instance_);
}
inline ::LQR::ComfortParam* LQRParam::release_comfortparam() {
  // @@protoc_insertion_point(field_release:LQR.LQRParam.comfortparam)
  clear_has_comfortparam();
  ::LQR::ComfortParam* temp = comfortparam_;
  comfortparam_ = NULL;
  return temp;
}
inline ::LQR::ComfortParam* LQRParam::mutable_comfortparam() {
  set_has_comfortparam();
  if (comfortparam_ == NULL) {
    comfortparam_ = new ::LQR::ComfortParam;
  }
  // @@protoc_insertion_point(field_mutable:LQR.LQRParam.comfortparam)
  return comfortparam_;
}
inline void LQRParam::set_allocated_comfortparam(::LQR::ComfortParam* comfortparam) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete comfortparam_;
  }
  if (comfortparam) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      comfortparam = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, comfortparam, submessage_arena);
    }
    set_has_comfortparam();
  } else {
    clear_has_comfortparam();
  }
  comfortparam_ = comfortparam;
  // @@protoc_insertion_point(field_set_allocated:LQR.LQRParam.comfortparam)
}

// -------------------------------------------------------------------

// VehicleParam

// optional float caf = 1;
inline bool VehicleParam::has_caf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleParam::set_has_caf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleParam::clear_has_caf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleParam::clear_caf() {
  caf_ = 0;
  clear_has_caf();
}
inline float VehicleParam::caf() const {
  // @@protoc_insertion_point(field_get:LQR.VehicleParam.caf)
  return caf_;
}
inline void VehicleParam::set_caf(float value) {
  set_has_caf();
  caf_ = value;
  // @@protoc_insertion_point(field_set:LQR.VehicleParam.caf)
}

// optional float car = 2;
inline bool VehicleParam::has_car() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleParam::set_has_car() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleParam::clear_has_car() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleParam::clear_car() {
  car_ = 0;
  clear_has_car();
}
inline float VehicleParam::car() const {
  // @@protoc_insertion_point(field_get:LQR.VehicleParam.car)
  return car_;
}
inline void VehicleParam::set_car(float value) {
  set_has_car();
  car_ = value;
  // @@protoc_insertion_point(field_set:LQR.VehicleParam.car)
}

// optional float lf = 3;
inline bool VehicleParam::has_lf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleParam::set_has_lf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleParam::clear_has_lf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleParam::clear_lf() {
  lf_ = 0;
  clear_has_lf();
}
inline float VehicleParam::lf() const {
  // @@protoc_insertion_point(field_get:LQR.VehicleParam.lf)
  return lf_;
}
inline void VehicleParam::set_lf(float value) {
  set_has_lf();
  lf_ = value;
  // @@protoc_insertion_point(field_set:LQR.VehicleParam.lf)
}

// optional float lr = 4;
inline bool VehicleParam::has_lr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleParam::set_has_lr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleParam::clear_has_lr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleParam::clear_lr() {
  lr_ = 0;
  clear_has_lr();
}
inline float VehicleParam::lr() const {
  // @@protoc_insertion_point(field_get:LQR.VehicleParam.lr)
  return lr_;
}
inline void VehicleParam::set_lr(float value) {
  set_has_lr();
  lr_ = value;
  // @@protoc_insertion_point(field_set:LQR.VehicleParam.lr)
}

// optional float m = 5;
inline bool VehicleParam::has_m() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleParam::set_has_m() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleParam::clear_has_m() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleParam::clear_m() {
  m_ = 0;
  clear_has_m();
}
inline float VehicleParam::m() const {
  // @@protoc_insertion_point(field_get:LQR.VehicleParam.m)
  return m_;
}
inline void VehicleParam::set_m(float value) {
  set_has_m();
  m_ = value;
  // @@protoc_insertion_point(field_set:LQR.VehicleParam.m)
}

// optional float iz = 6;
inline bool VehicleParam::has_iz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleParam::set_has_iz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleParam::clear_has_iz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleParam::clear_iz() {
  iz_ = 0;
  clear_has_iz();
}
inline float VehicleParam::iz() const {
  // @@protoc_insertion_point(field_get:LQR.VehicleParam.iz)
  return iz_;
}
inline void VehicleParam::set_iz(float value) {
  set_has_iz();
  iz_ = value;
  // @@protoc_insertion_point(field_set:LQR.VehicleParam.iz)
}

// optional float wheel_base = 7;
inline bool VehicleParam::has_wheel_base() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleParam::set_has_wheel_base() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleParam::clear_has_wheel_base() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleParam::clear_wheel_base() {
  wheel_base_ = 0;
  clear_has_wheel_base();
}
inline float VehicleParam::wheel_base() const {
  // @@protoc_insertion_point(field_get:LQR.VehicleParam.wheel_base)
  return wheel_base_;
}
inline void VehicleParam::set_wheel_base(float value) {
  set_has_wheel_base();
  wheel_base_ = value;
  // @@protoc_insertion_point(field_set:LQR.VehicleParam.wheel_base)
}

// optional float front_wheel_limit = 8;
inline bool VehicleParam::has_front_wheel_limit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehicleParam::set_has_front_wheel_limit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehicleParam::clear_has_front_wheel_limit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehicleParam::clear_front_wheel_limit() {
  front_wheel_limit_ = 0;
  clear_has_front_wheel_limit();
}
inline float VehicleParam::front_wheel_limit() const {
  // @@protoc_insertion_point(field_get:LQR.VehicleParam.front_wheel_limit)
  return front_wheel_limit_;
}
inline void VehicleParam::set_front_wheel_limit(float value) {
  set_has_front_wheel_limit();
  front_wheel_limit_ = value;
  // @@protoc_insertion_point(field_set:LQR.VehicleParam.front_wheel_limit)
}

// optional float steer_ratio = 9;
inline bool VehicleParam::has_steer_ratio() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VehicleParam::set_has_steer_ratio() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VehicleParam::clear_has_steer_ratio() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VehicleParam::clear_steer_ratio() {
  steer_ratio_ = 0;
  clear_has_steer_ratio();
}
inline float VehicleParam::steer_ratio() const {
  // @@protoc_insertion_point(field_get:LQR.VehicleParam.steer_ratio)
  return steer_ratio_;
}
inline void VehicleParam::set_steer_ratio(float value) {
  set_has_steer_ratio();
  steer_ratio_ = value;
  // @@protoc_insertion_point(field_set:LQR.VehicleParam.steer_ratio)
}

// -------------------------------------------------------------------

// ControlGain

// optional float q1 = 1 [default = 1];
inline bool ControlGain::has_q1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlGain::set_has_q1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlGain::clear_has_q1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlGain::clear_q1() {
  q1_ = 1;
  clear_has_q1();
}
inline float ControlGain::q1() const {
  // @@protoc_insertion_point(field_get:LQR.ControlGain.q1)
  return q1_;
}
inline void ControlGain::set_q1(float value) {
  set_has_q1();
  q1_ = value;
  // @@protoc_insertion_point(field_set:LQR.ControlGain.q1)
}

// optional float q2 = 2 [default = 1];
inline bool ControlGain::has_q2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControlGain::set_has_q2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControlGain::clear_has_q2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControlGain::clear_q2() {
  q2_ = 1;
  clear_has_q2();
}
inline float ControlGain::q2() const {
  // @@protoc_insertion_point(field_get:LQR.ControlGain.q2)
  return q2_;
}
inline void ControlGain::set_q2(float value) {
  set_has_q2();
  q2_ = value;
  // @@protoc_insertion_point(field_set:LQR.ControlGain.q2)
}

// optional float q3 = 3 [default = 1];
inline bool ControlGain::has_q3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControlGain::set_has_q3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControlGain::clear_has_q3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControlGain::clear_q3() {
  q3_ = 1;
  clear_has_q3();
}
inline float ControlGain::q3() const {
  // @@protoc_insertion_point(field_get:LQR.ControlGain.q3)
  return q3_;
}
inline void ControlGain::set_q3(float value) {
  set_has_q3();
  q3_ = value;
  // @@protoc_insertion_point(field_set:LQR.ControlGain.q3)
}

// optional float q4 = 4 [default = 1];
inline bool ControlGain::has_q4() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ControlGain::set_has_q4() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ControlGain::clear_has_q4() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ControlGain::clear_q4() {
  q4_ = 1;
  clear_has_q4();
}
inline float ControlGain::q4() const {
  // @@protoc_insertion_point(field_get:LQR.ControlGain.q4)
  return q4_;
}
inline void ControlGain::set_q4(float value) {
  set_has_q4();
  q4_ = value;
  // @@protoc_insertion_point(field_set:LQR.ControlGain.q4)
}

// optional float r = 5 [default = 1];
inline bool ControlGain::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlGain::set_has_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlGain::clear_has_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlGain::clear_r() {
  r_ = 1;
  clear_has_r();
}
inline float ControlGain::r() const {
  // @@protoc_insertion_point(field_get:LQR.ControlGain.r)
  return r_;
}
inline void ControlGain::set_r(float value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:LQR.ControlGain.r)
}

// -------------------------------------------------------------------

// LqrParam

// optional float ts = 1;
inline bool LqrParam::has_ts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LqrParam::set_has_ts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LqrParam::clear_has_ts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LqrParam::clear_ts() {
  ts_ = 0;
  clear_has_ts();
}
inline float LqrParam::ts() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.ts)
  return ts_;
}
inline void LqrParam::set_ts(float value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.ts)
}

// optional float lqr_eps = 2;
inline bool LqrParam::has_lqr_eps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LqrParam::set_has_lqr_eps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LqrParam::clear_has_lqr_eps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LqrParam::clear_lqr_eps() {
  lqr_eps_ = 0;
  clear_has_lqr_eps();
}
inline float LqrParam::lqr_eps() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.lqr_eps)
  return lqr_eps_;
}
inline void LqrParam::set_lqr_eps(float value) {
  set_has_lqr_eps();
  lqr_eps_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.lqr_eps)
}

// optional float max_iteration = 3;
inline bool LqrParam::has_max_iteration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LqrParam::set_has_max_iteration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LqrParam::clear_has_max_iteration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LqrParam::clear_max_iteration() {
  max_iteration_ = 0;
  clear_has_max_iteration();
}
inline float LqrParam::max_iteration() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.max_iteration)
  return max_iteration_;
}
inline void LqrParam::set_max_iteration(float value) {
  set_has_max_iteration();
  max_iteration_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.max_iteration)
}

// optional float minimum_speed_protection = 4;
inline bool LqrParam::has_minimum_speed_protection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LqrParam::set_has_minimum_speed_protection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LqrParam::clear_has_minimum_speed_protection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LqrParam::clear_minimum_speed_protection() {
  minimum_speed_protection_ = 0;
  clear_has_minimum_speed_protection();
}
inline float LqrParam::minimum_speed_protection() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.minimum_speed_protection)
  return minimum_speed_protection_;
}
inline void LqrParam::set_minimum_speed_protection(float value) {
  set_has_minimum_speed_protection();
  minimum_speed_protection_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.minimum_speed_protection)
}

// optional bool compute_k = 5;
inline bool LqrParam::has_compute_k() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LqrParam::set_has_compute_k() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LqrParam::clear_has_compute_k() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LqrParam::clear_compute_k() {
  compute_k_ = false;
  clear_has_compute_k();
}
inline bool LqrParam::compute_k() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.compute_k)
  return compute_k_;
}
inline void LqrParam::set_compute_k(bool value) {
  set_has_compute_k();
  compute_k_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.compute_k)
}

// optional bool follow_the_planned_speed = 6;
inline bool LqrParam::has_follow_the_planned_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LqrParam::set_has_follow_the_planned_speed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LqrParam::clear_has_follow_the_planned_speed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LqrParam::clear_follow_the_planned_speed() {
  follow_the_planned_speed_ = false;
  clear_has_follow_the_planned_speed();
}
inline bool LqrParam::follow_the_planned_speed() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.follow_the_planned_speed)
  return follow_the_planned_speed_;
}
inline void LqrParam::set_follow_the_planned_speed(bool value) {
  set_has_follow_the_planned_speed();
  follow_the_planned_speed_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.follow_the_planned_speed)
}

// optional float plan_speed = 7;
inline bool LqrParam::has_plan_speed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LqrParam::set_has_plan_speed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LqrParam::clear_has_plan_speed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LqrParam::clear_plan_speed() {
  plan_speed_ = 0;
  clear_has_plan_speed();
}
inline float LqrParam::plan_speed() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.plan_speed)
  return plan_speed_;
}
inline void LqrParam::set_plan_speed(float value) {
  set_has_plan_speed();
  plan_speed_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.plan_speed)
}

// optional double back_minimum_target_distance = 8;
inline bool LqrParam::has_back_minimum_target_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LqrParam::set_has_back_minimum_target_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LqrParam::clear_has_back_minimum_target_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LqrParam::clear_back_minimum_target_distance() {
  back_minimum_target_distance_ = 0;
  clear_has_back_minimum_target_distance();
}
inline double LqrParam::back_minimum_target_distance() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.back_minimum_target_distance)
  return back_minimum_target_distance_;
}
inline void LqrParam::set_back_minimum_target_distance(double value) {
  set_has_back_minimum_target_distance();
  back_minimum_target_distance_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.back_minimum_target_distance)
}

// optional double back_maximum_lateral_error = 9;
inline bool LqrParam::has_back_maximum_lateral_error() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LqrParam::set_has_back_maximum_lateral_error() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LqrParam::clear_has_back_maximum_lateral_error() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LqrParam::clear_back_maximum_lateral_error() {
  back_maximum_lateral_error_ = 0;
  clear_has_back_maximum_lateral_error();
}
inline double LqrParam::back_maximum_lateral_error() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.back_maximum_lateral_error)
  return back_maximum_lateral_error_;
}
inline void LqrParam::set_back_maximum_lateral_error(double value) {
  set_has_back_maximum_lateral_error();
  back_maximum_lateral_error_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.back_maximum_lateral_error)
}

// optional double back_maximum_heading_error = 10;
inline bool LqrParam::has_back_maximum_heading_error() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LqrParam::set_has_back_maximum_heading_error() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LqrParam::clear_has_back_maximum_heading_error() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LqrParam::clear_back_maximum_heading_error() {
  back_maximum_heading_error_ = 0;
  clear_has_back_maximum_heading_error();
}
inline double LqrParam::back_maximum_heading_error() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.back_maximum_heading_error)
  return back_maximum_heading_error_;
}
inline void LqrParam::set_back_maximum_heading_error(double value) {
  set_has_back_maximum_heading_error();
  back_maximum_heading_error_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.back_maximum_heading_error)
}

// optional bool flags_speed_planning_osqp = 11;
inline bool LqrParam::has_flags_speed_planning_osqp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LqrParam::set_has_flags_speed_planning_osqp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LqrParam::clear_has_flags_speed_planning_osqp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LqrParam::clear_flags_speed_planning_osqp() {
  flags_speed_planning_osqp_ = false;
  clear_has_flags_speed_planning_osqp();
}
inline bool LqrParam::flags_speed_planning_osqp() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.flags_speed_planning_osqp)
  return flags_speed_planning_osqp_;
}
inline void LqrParam::set_flags_speed_planning_osqp(bool value) {
  set_has_flags_speed_planning_osqp();
  flags_speed_planning_osqp_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.flags_speed_planning_osqp)
}

// optional bool flags_use_acc_control = 12;
inline bool LqrParam::has_flags_use_acc_control() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LqrParam::set_has_flags_use_acc_control() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LqrParam::clear_has_flags_use_acc_control() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LqrParam::clear_flags_use_acc_control() {
  flags_use_acc_control_ = false;
  clear_has_flags_use_acc_control();
}
inline bool LqrParam::flags_use_acc_control() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.flags_use_acc_control)
  return flags_use_acc_control_;
}
inline void LqrParam::set_flags_use_acc_control(bool value) {
  set_has_flags_use_acc_control();
  flags_use_acc_control_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.flags_use_acc_control)
}

// optional bool flags_record_data_txt = 13;
inline bool LqrParam::has_flags_record_data_txt() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LqrParam::set_has_flags_record_data_txt() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LqrParam::clear_has_flags_record_data_txt() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LqrParam::clear_flags_record_data_txt() {
  flags_record_data_txt_ = false;
  clear_has_flags_record_data_txt();
}
inline bool LqrParam::flags_record_data_txt() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.flags_record_data_txt)
  return flags_record_data_txt_;
}
inline void LqrParam::set_flags_record_data_txt(bool value) {
  set_has_flags_record_data_txt();
  flags_record_data_txt_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.flags_record_data_txt)
}

// optional bool flags_use_old_heading = 14;
inline bool LqrParam::has_flags_use_old_heading() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LqrParam::set_has_flags_use_old_heading() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LqrParam::clear_has_flags_use_old_heading() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LqrParam::clear_flags_use_old_heading() {
  flags_use_old_heading_ = false;
  clear_has_flags_use_old_heading();
}
inline bool LqrParam::flags_use_old_heading() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.flags_use_old_heading)
  return flags_use_old_heading_;
}
inline void LqrParam::set_flags_use_old_heading(bool value) {
  set_has_flags_use_old_heading();
  flags_use_old_heading_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.flags_use_old_heading)
}

// optional bool flags_printf_plan_data = 15;
inline bool LqrParam::has_flags_printf_plan_data() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LqrParam::set_has_flags_printf_plan_data() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LqrParam::clear_has_flags_printf_plan_data() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LqrParam::clear_flags_printf_plan_data() {
  flags_printf_plan_data_ = false;
  clear_has_flags_printf_plan_data();
}
inline bool LqrParam::flags_printf_plan_data() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.flags_printf_plan_data)
  return flags_printf_plan_data_;
}
inline void LqrParam::set_flags_printf_plan_data(bool value) {
  set_has_flags_printf_plan_data();
  flags_printf_plan_data_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.flags_printf_plan_data)
}

// optional double digital_filter_forward_freq = 16;
inline bool LqrParam::has_digital_filter_forward_freq() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LqrParam::set_has_digital_filter_forward_freq() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LqrParam::clear_has_digital_filter_forward_freq() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LqrParam::clear_digital_filter_forward_freq() {
  digital_filter_forward_freq_ = 0;
  clear_has_digital_filter_forward_freq();
}
inline double LqrParam::digital_filter_forward_freq() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.digital_filter_forward_freq)
  return digital_filter_forward_freq_;
}
inline void LqrParam::set_digital_filter_forward_freq(double value) {
  set_has_digital_filter_forward_freq();
  digital_filter_forward_freq_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.digital_filter_forward_freq)
}

// optional double maximum_lateral_error = 17;
inline bool LqrParam::has_maximum_lateral_error() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LqrParam::set_has_maximum_lateral_error() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LqrParam::clear_has_maximum_lateral_error() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LqrParam::clear_maximum_lateral_error() {
  maximum_lateral_error_ = 0;
  clear_has_maximum_lateral_error();
}
inline double LqrParam::maximum_lateral_error() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.maximum_lateral_error)
  return maximum_lateral_error_;
}
inline void LqrParam::set_maximum_lateral_error(double value) {
  set_has_maximum_lateral_error();
  maximum_lateral_error_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.maximum_lateral_error)
}

// optional double maximum_heading_error = 18;
inline bool LqrParam::has_maximum_heading_error() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LqrParam::set_has_maximum_heading_error() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LqrParam::clear_has_maximum_heading_error() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LqrParam::clear_maximum_heading_error() {
  maximum_heading_error_ = 0;
  clear_has_maximum_heading_error();
}
inline double LqrParam::maximum_heading_error() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.maximum_heading_error)
  return maximum_heading_error_;
}
inline void LqrParam::set_maximum_heading_error(double value) {
  set_has_maximum_heading_error();
  maximum_heading_error_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.maximum_heading_error)
}

// optional double preview_time = 19;
inline bool LqrParam::has_preview_time() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LqrParam::set_has_preview_time() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LqrParam::clear_has_preview_time() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LqrParam::clear_preview_time() {
  preview_time_ = 0;
  clear_has_preview_time();
}
inline double LqrParam::preview_time() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.preview_time)
  return preview_time_;
}
inline void LqrParam::set_preview_time(double value) {
  set_has_preview_time();
  preview_time_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.preview_time)
}

// optional double minimum_preview_distance = 20;
inline bool LqrParam::has_minimum_preview_distance() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void LqrParam::set_has_minimum_preview_distance() {
  _has_bits_[0] |= 0x00200000u;
}
inline void LqrParam::clear_has_minimum_preview_distance() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void LqrParam::clear_minimum_preview_distance() {
  minimum_preview_distance_ = 0;
  clear_has_minimum_preview_distance();
}
inline double LqrParam::minimum_preview_distance() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.minimum_preview_distance)
  return minimum_preview_distance_;
}
inline void LqrParam::set_minimum_preview_distance(double value) {
  set_has_minimum_preview_distance();
  minimum_preview_distance_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.minimum_preview_distance)
}

// optional double target_time = 21;
inline bool LqrParam::has_target_time() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void LqrParam::set_has_target_time() {
  _has_bits_[0] |= 0x00400000u;
}
inline void LqrParam::clear_has_target_time() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void LqrParam::clear_target_time() {
  target_time_ = 0;
  clear_has_target_time();
}
inline double LqrParam::target_time() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.target_time)
  return target_time_;
}
inline void LqrParam::set_target_time(double value) {
  set_has_target_time();
  target_time_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.target_time)
}

// optional double minimum_target_distance = 22;
inline bool LqrParam::has_minimum_target_distance() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void LqrParam::set_has_minimum_target_distance() {
  _has_bits_[0] |= 0x00800000u;
}
inline void LqrParam::clear_has_minimum_target_distance() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void LqrParam::clear_minimum_target_distance() {
  minimum_target_distance_ = 0;
  clear_has_minimum_target_distance();
}
inline double LqrParam::minimum_target_distance() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.minimum_target_distance)
  return minimum_target_distance_;
}
inline void LqrParam::set_minimum_target_distance(double value) {
  set_has_minimum_target_distance();
  minimum_target_distance_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.minimum_target_distance)
}

// optional double curvature_reduction = 23;
inline bool LqrParam::has_curvature_reduction() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void LqrParam::set_has_curvature_reduction() {
  _has_bits_[0] |= 0x01000000u;
}
inline void LqrParam::clear_has_curvature_reduction() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void LqrParam::clear_curvature_reduction() {
  curvature_reduction_ = 0;
  clear_has_curvature_reduction();
}
inline double LqrParam::curvature_reduction() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.curvature_reduction)
  return curvature_reduction_;
}
inline void LqrParam::set_curvature_reduction(double value) {
  set_has_curvature_reduction();
  curvature_reduction_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.curvature_reduction)
}

// optional double steering_delay = 24;
inline bool LqrParam::has_steering_delay() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void LqrParam::set_has_steering_delay() {
  _has_bits_[0] |= 0x02000000u;
}
inline void LqrParam::clear_has_steering_delay() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void LqrParam::clear_steering_delay() {
  steering_delay_ = 0;
  clear_has_steering_delay();
}
inline double LqrParam::steering_delay() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.steering_delay)
  return steering_delay_;
}
inline void LqrParam::set_steering_delay(double value) {
  set_has_steering_delay();
  steering_delay_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.steering_delay)
}

// optional double digital_filter_k_freq = 25;
inline bool LqrParam::has_digital_filter_k_freq() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void LqrParam::set_has_digital_filter_k_freq() {
  _has_bits_[0] |= 0x04000000u;
}
inline void LqrParam::clear_has_digital_filter_k_freq() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void LqrParam::clear_digital_filter_k_freq() {
  digital_filter_k_freq_ = 0;
  clear_has_digital_filter_k_freq();
}
inline double LqrParam::digital_filter_k_freq() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.digital_filter_k_freq)
  return digital_filter_k_freq_;
}
inline void LqrParam::set_digital_filter_k_freq(double value) {
  set_has_digital_filter_k_freq();
  digital_filter_k_freq_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.digital_filter_k_freq)
}

// optional bool flags_printf_lqr_data = 26;
inline bool LqrParam::has_flags_printf_lqr_data() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void LqrParam::set_has_flags_printf_lqr_data() {
  _has_bits_[0] |= 0x00080000u;
}
inline void LqrParam::clear_has_flags_printf_lqr_data() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void LqrParam::clear_flags_printf_lqr_data() {
  flags_printf_lqr_data_ = false;
  clear_has_flags_printf_lqr_data();
}
inline bool LqrParam::flags_printf_lqr_data() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.flags_printf_lqr_data)
  return flags_printf_lqr_data_;
}
inline void LqrParam::set_flags_printf_lqr_data(bool value) {
  set_has_flags_printf_lqr_data();
  flags_printf_lqr_data_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.flags_printf_lqr_data)
}

// optional double reserved_parameter_a = 27;
inline bool LqrParam::has_reserved_parameter_a() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void LqrParam::set_has_reserved_parameter_a() {
  _has_bits_[0] |= 0x08000000u;
}
inline void LqrParam::clear_has_reserved_parameter_a() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void LqrParam::clear_reserved_parameter_a() {
  reserved_parameter_a_ = 0;
  clear_has_reserved_parameter_a();
}
inline double LqrParam::reserved_parameter_a() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.reserved_parameter_a)
  return reserved_parameter_a_;
}
inline void LqrParam::set_reserved_parameter_a(double value) {
  set_has_reserved_parameter_a();
  reserved_parameter_a_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.reserved_parameter_a)
}

// optional bool reserved_parameter_b = 28;
inline bool LqrParam::has_reserved_parameter_b() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void LqrParam::set_has_reserved_parameter_b() {
  _has_bits_[0] |= 0x00100000u;
}
inline void LqrParam::clear_has_reserved_parameter_b() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void LqrParam::clear_reserved_parameter_b() {
  reserved_parameter_b_ = false;
  clear_has_reserved_parameter_b();
}
inline bool LqrParam::reserved_parameter_b() const {
  // @@protoc_insertion_point(field_get:LQR.LqrParam.reserved_parameter_b)
  return reserved_parameter_b_;
}
inline void LqrParam::set_reserved_parameter_b(bool value) {
  set_has_reserved_parameter_b();
  reserved_parameter_b_ = value;
  // @@protoc_insertion_point(field_set:LQR.LqrParam.reserved_parameter_b)
}

// -------------------------------------------------------------------

// LatErrGainScheduler

// optional double scheduler_0 = 1;
inline bool LatErrGainScheduler::has_scheduler_0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LatErrGainScheduler::set_has_scheduler_0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LatErrGainScheduler::clear_has_scheduler_0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LatErrGainScheduler::clear_scheduler_0() {
  scheduler_0_ = 0;
  clear_has_scheduler_0();
}
inline double LatErrGainScheduler::scheduler_0() const {
  // @@protoc_insertion_point(field_get:LQR.LatErrGainScheduler.scheduler_0)
  return scheduler_0_;
}
inline void LatErrGainScheduler::set_scheduler_0(double value) {
  set_has_scheduler_0();
  scheduler_0_ = value;
  // @@protoc_insertion_point(field_set:LQR.LatErrGainScheduler.scheduler_0)
}

// optional double scheduler_1_5 = 2;
inline bool LatErrGainScheduler::has_scheduler_1_5() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LatErrGainScheduler::set_has_scheduler_1_5() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LatErrGainScheduler::clear_has_scheduler_1_5() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LatErrGainScheduler::clear_scheduler_1_5() {
  scheduler_1_5_ = 0;
  clear_has_scheduler_1_5();
}
inline double LatErrGainScheduler::scheduler_1_5() const {
  // @@protoc_insertion_point(field_get:LQR.LatErrGainScheduler.scheduler_1_5)
  return scheduler_1_5_;
}
inline void LatErrGainScheduler::set_scheduler_1_5(double value) {
  set_has_scheduler_1_5();
  scheduler_1_5_ = value;
  // @@protoc_insertion_point(field_set:LQR.LatErrGainScheduler.scheduler_1_5)
}

// optional double scheduler_3 = 3;
inline bool LatErrGainScheduler::has_scheduler_3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LatErrGainScheduler::set_has_scheduler_3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LatErrGainScheduler::clear_has_scheduler_3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LatErrGainScheduler::clear_scheduler_3() {
  scheduler_3_ = 0;
  clear_has_scheduler_3();
}
inline double LatErrGainScheduler::scheduler_3() const {
  // @@protoc_insertion_point(field_get:LQR.LatErrGainScheduler.scheduler_3)
  return scheduler_3_;
}
inline void LatErrGainScheduler::set_scheduler_3(double value) {
  set_has_scheduler_3();
  scheduler_3_ = value;
  // @@protoc_insertion_point(field_set:LQR.LatErrGainScheduler.scheduler_3)
}

// optional double scheduler_6 = 4;
inline bool LatErrGainScheduler::has_scheduler_6() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LatErrGainScheduler::set_has_scheduler_6() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LatErrGainScheduler::clear_has_scheduler_6() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LatErrGainScheduler::clear_scheduler_6() {
  scheduler_6_ = 0;
  clear_has_scheduler_6();
}
inline double LatErrGainScheduler::scheduler_6() const {
  // @@protoc_insertion_point(field_get:LQR.LatErrGainScheduler.scheduler_6)
  return scheduler_6_;
}
inline void LatErrGainScheduler::set_scheduler_6(double value) {
  set_has_scheduler_6();
  scheduler_6_ = value;
  // @@protoc_insertion_point(field_set:LQR.LatErrGainScheduler.scheduler_6)
}

// optional double scheduler_12 = 5;
inline bool LatErrGainScheduler::has_scheduler_12() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LatErrGainScheduler::set_has_scheduler_12() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LatErrGainScheduler::clear_has_scheduler_12() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LatErrGainScheduler::clear_scheduler_12() {
  scheduler_12_ = 0;
  clear_has_scheduler_12();
}
inline double LatErrGainScheduler::scheduler_12() const {
  // @@protoc_insertion_point(field_get:LQR.LatErrGainScheduler.scheduler_12)
  return scheduler_12_;
}
inline void LatErrGainScheduler::set_scheduler_12(double value) {
  set_has_scheduler_12();
  scheduler_12_ = value;
  // @@protoc_insertion_point(field_set:LQR.LatErrGainScheduler.scheduler_12)
}

// optional double scheduler_20 = 6;
inline bool LatErrGainScheduler::has_scheduler_20() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LatErrGainScheduler::set_has_scheduler_20() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LatErrGainScheduler::clear_has_scheduler_20() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LatErrGainScheduler::clear_scheduler_20() {
  scheduler_20_ = 0;
  clear_has_scheduler_20();
}
inline double LatErrGainScheduler::scheduler_20() const {
  // @@protoc_insertion_point(field_get:LQR.LatErrGainScheduler.scheduler_20)
  return scheduler_20_;
}
inline void LatErrGainScheduler::set_scheduler_20(double value) {
  set_has_scheduler_20();
  scheduler_20_ = value;
  // @@protoc_insertion_point(field_set:LQR.LatErrGainScheduler.scheduler_20)
}

// -------------------------------------------------------------------

// HeadingErrGainScheduler

// optional double scheduler_0 = 1;
inline bool HeadingErrGainScheduler::has_scheduler_0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeadingErrGainScheduler::set_has_scheduler_0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeadingErrGainScheduler::clear_has_scheduler_0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeadingErrGainScheduler::clear_scheduler_0() {
  scheduler_0_ = 0;
  clear_has_scheduler_0();
}
inline double HeadingErrGainScheduler::scheduler_0() const {
  // @@protoc_insertion_point(field_get:LQR.HeadingErrGainScheduler.scheduler_0)
  return scheduler_0_;
}
inline void HeadingErrGainScheduler::set_scheduler_0(double value) {
  set_has_scheduler_0();
  scheduler_0_ = value;
  // @@protoc_insertion_point(field_set:LQR.HeadingErrGainScheduler.scheduler_0)
}

// optional double scheduler_1_5 = 2;
inline bool HeadingErrGainScheduler::has_scheduler_1_5() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeadingErrGainScheduler::set_has_scheduler_1_5() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeadingErrGainScheduler::clear_has_scheduler_1_5() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeadingErrGainScheduler::clear_scheduler_1_5() {
  scheduler_1_5_ = 0;
  clear_has_scheduler_1_5();
}
inline double HeadingErrGainScheduler::scheduler_1_5() const {
  // @@protoc_insertion_point(field_get:LQR.HeadingErrGainScheduler.scheduler_1_5)
  return scheduler_1_5_;
}
inline void HeadingErrGainScheduler::set_scheduler_1_5(double value) {
  set_has_scheduler_1_5();
  scheduler_1_5_ = value;
  // @@protoc_insertion_point(field_set:LQR.HeadingErrGainScheduler.scheduler_1_5)
}

// optional double scheduler_3 = 3;
inline bool HeadingErrGainScheduler::has_scheduler_3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeadingErrGainScheduler::set_has_scheduler_3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeadingErrGainScheduler::clear_has_scheduler_3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeadingErrGainScheduler::clear_scheduler_3() {
  scheduler_3_ = 0;
  clear_has_scheduler_3();
}
inline double HeadingErrGainScheduler::scheduler_3() const {
  // @@protoc_insertion_point(field_get:LQR.HeadingErrGainScheduler.scheduler_3)
  return scheduler_3_;
}
inline void HeadingErrGainScheduler::set_scheduler_3(double value) {
  set_has_scheduler_3();
  scheduler_3_ = value;
  // @@protoc_insertion_point(field_set:LQR.HeadingErrGainScheduler.scheduler_3)
}

// optional double scheduler_6 = 4;
inline bool HeadingErrGainScheduler::has_scheduler_6() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeadingErrGainScheduler::set_has_scheduler_6() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeadingErrGainScheduler::clear_has_scheduler_6() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeadingErrGainScheduler::clear_scheduler_6() {
  scheduler_6_ = 0;
  clear_has_scheduler_6();
}
inline double HeadingErrGainScheduler::scheduler_6() const {
  // @@protoc_insertion_point(field_get:LQR.HeadingErrGainScheduler.scheduler_6)
  return scheduler_6_;
}
inline void HeadingErrGainScheduler::set_scheduler_6(double value) {
  set_has_scheduler_6();
  scheduler_6_ = value;
  // @@protoc_insertion_point(field_set:LQR.HeadingErrGainScheduler.scheduler_6)
}

// optional double scheduler_12 = 5;
inline bool HeadingErrGainScheduler::has_scheduler_12() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HeadingErrGainScheduler::set_has_scheduler_12() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HeadingErrGainScheduler::clear_has_scheduler_12() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HeadingErrGainScheduler::clear_scheduler_12() {
  scheduler_12_ = 0;
  clear_has_scheduler_12();
}
inline double HeadingErrGainScheduler::scheduler_12() const {
  // @@protoc_insertion_point(field_get:LQR.HeadingErrGainScheduler.scheduler_12)
  return scheduler_12_;
}
inline void HeadingErrGainScheduler::set_scheduler_12(double value) {
  set_has_scheduler_12();
  scheduler_12_ = value;
  // @@protoc_insertion_point(field_set:LQR.HeadingErrGainScheduler.scheduler_12)
}

// optional double scheduler_20 = 6;
inline bool HeadingErrGainScheduler::has_scheduler_20() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HeadingErrGainScheduler::set_has_scheduler_20() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HeadingErrGainScheduler::clear_has_scheduler_20() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HeadingErrGainScheduler::clear_scheduler_20() {
  scheduler_20_ = 0;
  clear_has_scheduler_20();
}
inline double HeadingErrGainScheduler::scheduler_20() const {
  // @@protoc_insertion_point(field_get:LQR.HeadingErrGainScheduler.scheduler_20)
  return scheduler_20_;
}
inline void HeadingErrGainScheduler::set_scheduler_20(double value) {
  set_has_scheduler_20();
  scheduler_20_ = value;
  // @@protoc_insertion_point(field_set:LQR.HeadingErrGainScheduler.scheduler_20)
}

// -------------------------------------------------------------------

// LeadLagParam

// optional double innerstate_saturation_level = 1;
inline bool LeadLagParam::has_innerstate_saturation_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeadLagParam::set_has_innerstate_saturation_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeadLagParam::clear_has_innerstate_saturation_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeadLagParam::clear_innerstate_saturation_level() {
  innerstate_saturation_level_ = 0;
  clear_has_innerstate_saturation_level();
}
inline double LeadLagParam::innerstate_saturation_level() const {
  // @@protoc_insertion_point(field_get:LQR.LeadLagParam.innerstate_saturation_level)
  return innerstate_saturation_level_;
}
inline void LeadLagParam::set_innerstate_saturation_level(double value) {
  set_has_innerstate_saturation_level();
  innerstate_saturation_level_ = value;
  // @@protoc_insertion_point(field_set:LQR.LeadLagParam.innerstate_saturation_level)
}

// optional double alpha = 2;
inline bool LeadLagParam::has_alpha() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeadLagParam::set_has_alpha() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeadLagParam::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeadLagParam::clear_alpha() {
  alpha_ = 0;
  clear_has_alpha();
}
inline double LeadLagParam::alpha() const {
  // @@protoc_insertion_point(field_get:LQR.LeadLagParam.alpha)
  return alpha_;
}
inline void LeadLagParam::set_alpha(double value) {
  set_has_alpha();
  alpha_ = value;
  // @@protoc_insertion_point(field_set:LQR.LeadLagParam.alpha)
}

// optional double beta = 3;
inline bool LeadLagParam::has_beta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeadLagParam::set_has_beta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LeadLagParam::clear_has_beta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LeadLagParam::clear_beta() {
  beta_ = 0;
  clear_has_beta();
}
inline double LeadLagParam::beta() const {
  // @@protoc_insertion_point(field_get:LQR.LeadLagParam.beta)
  return beta_;
}
inline void LeadLagParam::set_beta(double value) {
  set_has_beta();
  beta_ = value;
  // @@protoc_insertion_point(field_set:LQR.LeadLagParam.beta)
}

// optional double tau = 4;
inline bool LeadLagParam::has_tau() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LeadLagParam::set_has_tau() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LeadLagParam::clear_has_tau() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LeadLagParam::clear_tau() {
  tau_ = 0;
  clear_has_tau();
}
inline double LeadLagParam::tau() const {
  // @@protoc_insertion_point(field_get:LQR.LeadLagParam.tau)
  return tau_;
}
inline void LeadLagParam::set_tau(double value) {
  set_has_tau();
  tau_ = value;
  // @@protoc_insertion_point(field_set:LQR.LeadLagParam.tau)
}

// -------------------------------------------------------------------

// ComfortParam

// optional bool flags_set_steer_limit = 1;
inline bool ComfortParam::has_flags_set_steer_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ComfortParam::set_has_flags_set_steer_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ComfortParam::clear_has_flags_set_steer_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ComfortParam::clear_flags_set_steer_limit() {
  flags_set_steer_limit_ = false;
  clear_has_flags_set_steer_limit();
}
inline bool ComfortParam::flags_set_steer_limit() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.flags_set_steer_limit)
  return flags_set_steer_limit_;
}
inline void ComfortParam::set_flags_set_steer_limit(bool value) {
  set_has_flags_set_steer_limit();
  flags_set_steer_limit_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.flags_set_steer_limit)
}

// optional double max_lat_acc_ = 2;
inline bool ComfortParam::has_max_lat_acc_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComfortParam::set_has_max_lat_acc_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComfortParam::clear_has_max_lat_acc_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComfortParam::clear_max_lat_acc_() {
  max_lat_acc__ = 0;
  clear_has_max_lat_acc_();
}
inline double ComfortParam::max_lat_acc_() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.max_lat_acc_)
  return max_lat_acc__;
}
inline void ComfortParam::set_max_lat_acc_(double value) {
  set_has_max_lat_acc_();
  max_lat_acc__ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.max_lat_acc_)
}

// optional bool flags_steering_digital_filter = 3;
inline bool ComfortParam::has_flags_steering_digital_filter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ComfortParam::set_has_flags_steering_digital_filter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ComfortParam::clear_has_flags_steering_digital_filter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ComfortParam::clear_flags_steering_digital_filter() {
  flags_steering_digital_filter_ = false;
  clear_has_flags_steering_digital_filter();
}
inline bool ComfortParam::flags_steering_digital_filter() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.flags_steering_digital_filter)
  return flags_steering_digital_filter_;
}
inline void ComfortParam::set_flags_steering_digital_filter(bool value) {
  set_has_flags_steering_digital_filter();
  flags_steering_digital_filter_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.flags_steering_digital_filter)
}

// optional double cutoff_freq = 4;
inline bool ComfortParam::has_cutoff_freq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComfortParam::set_has_cutoff_freq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComfortParam::clear_has_cutoff_freq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComfortParam::clear_cutoff_freq() {
  cutoff_freq_ = 0;
  clear_has_cutoff_freq();
}
inline double ComfortParam::cutoff_freq() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.cutoff_freq)
  return cutoff_freq_;
}
inline void ComfortParam::set_cutoff_freq(double value) {
  set_has_cutoff_freq();
  cutoff_freq_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.cutoff_freq)
}

// optional double mean_filter_window_size = 5;
inline bool ComfortParam::has_mean_filter_window_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ComfortParam::set_has_mean_filter_window_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ComfortParam::clear_has_mean_filter_window_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ComfortParam::clear_mean_filter_window_size() {
  mean_filter_window_size_ = 0;
  clear_has_mean_filter_window_size();
}
inline double ComfortParam::mean_filter_window_size() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.mean_filter_window_size)
  return mean_filter_window_size_;
}
inline void ComfortParam::set_mean_filter_window_size(double value) {
  set_has_mean_filter_window_size();
  mean_filter_window_size_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.mean_filter_window_size)
}

// optional bool flags_enable_maximum_steer_rate_limit = 6;
inline bool ComfortParam::has_flags_enable_maximum_steer_rate_limit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ComfortParam::set_has_flags_enable_maximum_steer_rate_limit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ComfortParam::clear_has_flags_enable_maximum_steer_rate_limit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ComfortParam::clear_flags_enable_maximum_steer_rate_limit() {
  flags_enable_maximum_steer_rate_limit_ = false;
  clear_has_flags_enable_maximum_steer_rate_limit();
}
inline bool ComfortParam::flags_enable_maximum_steer_rate_limit() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.flags_enable_maximum_steer_rate_limit)
  return flags_enable_maximum_steer_rate_limit_;
}
inline void ComfortParam::set_flags_enable_maximum_steer_rate_limit(bool value) {
  set_has_flags_enable_maximum_steer_rate_limit();
  flags_enable_maximum_steer_rate_limit_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.flags_enable_maximum_steer_rate_limit)
}

// optional double max_steer_angle_rate = 7;
inline bool ComfortParam::has_max_steer_angle_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ComfortParam::set_has_max_steer_angle_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ComfortParam::clear_has_max_steer_angle_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ComfortParam::clear_max_steer_angle_rate() {
  max_steer_angle_rate_ = 0;
  clear_has_max_steer_angle_rate();
}
inline double ComfortParam::max_steer_angle_rate() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.max_steer_angle_rate)
  return max_steer_angle_rate_;
}
inline void ComfortParam::set_max_steer_angle_rate(double value) {
  set_has_max_steer_angle_rate();
  max_steer_angle_rate_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.max_steer_angle_rate)
}

// optional bool flags_enable_minimum_steer_rate_limit = 8;
inline bool ComfortParam::has_flags_enable_minimum_steer_rate_limit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ComfortParam::set_has_flags_enable_minimum_steer_rate_limit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ComfortParam::clear_has_flags_enable_minimum_steer_rate_limit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ComfortParam::clear_flags_enable_minimum_steer_rate_limit() {
  flags_enable_minimum_steer_rate_limit_ = false;
  clear_has_flags_enable_minimum_steer_rate_limit();
}
inline bool ComfortParam::flags_enable_minimum_steer_rate_limit() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.flags_enable_minimum_steer_rate_limit)
  return flags_enable_minimum_steer_rate_limit_;
}
inline void ComfortParam::set_flags_enable_minimum_steer_rate_limit(bool value) {
  set_has_flags_enable_minimum_steer_rate_limit();
  flags_enable_minimum_steer_rate_limit_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.flags_enable_minimum_steer_rate_limit)
}

// optional double min_steer_angle_rate = 9;
inline bool ComfortParam::has_min_steer_angle_rate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ComfortParam::set_has_min_steer_angle_rate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ComfortParam::clear_has_min_steer_angle_rate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ComfortParam::clear_min_steer_angle_rate() {
  min_steer_angle_rate_ = 0;
  clear_has_min_steer_angle_rate();
}
inline double ComfortParam::min_steer_angle_rate() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.min_steer_angle_rate)
  return min_steer_angle_rate_;
}
inline void ComfortParam::set_min_steer_angle_rate(double value) {
  set_has_min_steer_angle_rate();
  min_steer_angle_rate_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.min_steer_angle_rate)
}

// optional bool flags_steer_median_filtering = 10;
inline bool ComfortParam::has_flags_steer_median_filtering() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ComfortParam::set_has_flags_steer_median_filtering() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ComfortParam::clear_has_flags_steer_median_filtering() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ComfortParam::clear_flags_steer_median_filtering() {
  flags_steer_median_filtering_ = false;
  clear_has_flags_steer_median_filtering();
}
inline bool ComfortParam::flags_steer_median_filtering() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.flags_steer_median_filtering)
  return flags_steer_median_filtering_;
}
inline void ComfortParam::set_flags_steer_median_filtering(bool value) {
  set_has_flags_steer_median_filtering();
  flags_steer_median_filtering_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.flags_steer_median_filtering)
}

// optional double steer_angle_median_num = 11;
inline bool ComfortParam::has_steer_angle_median_num() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ComfortParam::set_has_steer_angle_median_num() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ComfortParam::clear_has_steer_angle_median_num() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ComfortParam::clear_steer_angle_median_num() {
  steer_angle_median_num_ = 0;
  clear_has_steer_angle_median_num();
}
inline double ComfortParam::steer_angle_median_num() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.steer_angle_median_num)
  return steer_angle_median_num_;
}
inline void ComfortParam::set_steer_angle_median_num(double value) {
  set_has_steer_angle_median_num();
  steer_angle_median_num_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.steer_angle_median_num)
}

// optional bool look_ahead_index_by_k_mean = 12;
inline bool ComfortParam::has_look_ahead_index_by_k_mean() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ComfortParam::set_has_look_ahead_index_by_k_mean() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ComfortParam::clear_has_look_ahead_index_by_k_mean() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ComfortParam::clear_look_ahead_index_by_k_mean() {
  look_ahead_index_by_k_mean_ = false;
  clear_has_look_ahead_index_by_k_mean();
}
inline bool ComfortParam::look_ahead_index_by_k_mean() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.look_ahead_index_by_k_mean)
  return look_ahead_index_by_k_mean_;
}
inline void ComfortParam::set_look_ahead_index_by_k_mean(bool value) {
  set_has_look_ahead_index_by_k_mean();
  look_ahead_index_by_k_mean_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.look_ahead_index_by_k_mean)
}

// optional double target_point_windows_by_k_mean = 13;
inline bool ComfortParam::has_target_point_windows_by_k_mean() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ComfortParam::set_has_target_point_windows_by_k_mean() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ComfortParam::clear_has_target_point_windows_by_k_mean() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ComfortParam::clear_target_point_windows_by_k_mean() {
  target_point_windows_by_k_mean_ = 0;
  clear_has_target_point_windows_by_k_mean();
}
inline double ComfortParam::target_point_windows_by_k_mean() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.target_point_windows_by_k_mean)
  return target_point_windows_by_k_mean_;
}
inline void ComfortParam::set_target_point_windows_by_k_mean(double value) {
  set_has_target_point_windows_by_k_mean();
  target_point_windows_by_k_mean_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.target_point_windows_by_k_mean)
}

// optional bool look_ahead_index_by_k_median = 14;
inline bool ComfortParam::has_look_ahead_index_by_k_median() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ComfortParam::set_has_look_ahead_index_by_k_median() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ComfortParam::clear_has_look_ahead_index_by_k_median() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ComfortParam::clear_look_ahead_index_by_k_median() {
  look_ahead_index_by_k_median_ = false;
  clear_has_look_ahead_index_by_k_median();
}
inline bool ComfortParam::look_ahead_index_by_k_median() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.look_ahead_index_by_k_median)
  return look_ahead_index_by_k_median_;
}
inline void ComfortParam::set_look_ahead_index_by_k_median(bool value) {
  set_has_look_ahead_index_by_k_median();
  look_ahead_index_by_k_median_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.look_ahead_index_by_k_median)
}

// optional double target_point_windows_by_k_median = 15;
inline bool ComfortParam::has_target_point_windows_by_k_median() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ComfortParam::set_has_target_point_windows_by_k_median() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ComfortParam::clear_has_target_point_windows_by_k_median() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ComfortParam::clear_target_point_windows_by_k_median() {
  target_point_windows_by_k_median_ = 0;
  clear_has_target_point_windows_by_k_median();
}
inline double ComfortParam::target_point_windows_by_k_median() const {
  // @@protoc_insertion_point(field_get:LQR.ComfortParam.target_point_windows_by_k_median)
  return target_point_windows_by_k_median_;
}
inline void ComfortParam::set_target_point_windows_by_k_median(double value) {
  set_has_target_point_windows_by_k_median();
  target_point_windows_by_k_median_ = value;
  // @@protoc_insertion_point(field_set:LQR.ComfortParam.target_point_windows_by_k_median)
}

// -------------------------------------------------------------------

// K_VInfo

// optional double speed = 1;
inline bool K_VInfo::has_speed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void K_VInfo::set_has_speed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void K_VInfo::clear_has_speed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void K_VInfo::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double K_VInfo::speed() const {
  // @@protoc_insertion_point(field_get:LQR.K_VInfo.speed)
  return speed_;
}
inline void K_VInfo::set_speed(double value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:LQR.K_VInfo.speed)
}

// optional double k1 = 2;
inline bool K_VInfo::has_k1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void K_VInfo::set_has_k1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void K_VInfo::clear_has_k1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void K_VInfo::clear_k1() {
  k1_ = 0;
  clear_has_k1();
}
inline double K_VInfo::k1() const {
  // @@protoc_insertion_point(field_get:LQR.K_VInfo.k1)
  return k1_;
}
inline void K_VInfo::set_k1(double value) {
  set_has_k1();
  k1_ = value;
  // @@protoc_insertion_point(field_set:LQR.K_VInfo.k1)
}

// optional double k2 = 3;
inline bool K_VInfo::has_k2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void K_VInfo::set_has_k2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void K_VInfo::clear_has_k2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void K_VInfo::clear_k2() {
  k2_ = 0;
  clear_has_k2();
}
inline double K_VInfo::k2() const {
  // @@protoc_insertion_point(field_get:LQR.K_VInfo.k2)
  return k2_;
}
inline void K_VInfo::set_k2(double value) {
  set_has_k2();
  k2_ = value;
  // @@protoc_insertion_point(field_set:LQR.K_VInfo.k2)
}

// optional double k3 = 4;
inline bool K_VInfo::has_k3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void K_VInfo::set_has_k3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void K_VInfo::clear_has_k3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void K_VInfo::clear_k3() {
  k3_ = 0;
  clear_has_k3();
}
inline double K_VInfo::k3() const {
  // @@protoc_insertion_point(field_get:LQR.K_VInfo.k3)
  return k3_;
}
inline void K_VInfo::set_k3(double value) {
  set_has_k3();
  k3_ = value;
  // @@protoc_insertion_point(field_set:LQR.K_VInfo.k3)
}

// optional double k4 = 5;
inline bool K_VInfo::has_k4() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void K_VInfo::set_has_k4() {
  _has_bits_[0] |= 0x00000010u;
}
inline void K_VInfo::clear_has_k4() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void K_VInfo::clear_k4() {
  k4_ = 0;
  clear_has_k4();
}
inline double K_VInfo::k4() const {
  // @@protoc_insertion_point(field_get:LQR.K_VInfo.k4)
  return k4_;
}
inline void K_VInfo::set_k4(double value) {
  set_has_k4();
  k4_ = value;
  // @@protoc_insertion_point(field_set:LQR.K_VInfo.k4)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace LQR

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_control_2flqr_5fconfig_2eproto__INCLUDED
