// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: control/monitor_simulate.proto

#ifndef PROTOBUF_control_2fmonitor_5fsimulate_2eproto__INCLUDED
#define PROTOBUF_control_2fmonitor_5fsimulate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_control_2fmonitor_5fsimulate_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsSimulateDataImpl();
void InitDefaultsSimulateData();
void InitDefaultsSimulatePointImpl();
void InitDefaultsSimulatePoint();
void InitDefaultsSimulateCoordImpl();
void InitDefaultsSimulateCoord();
void InitDefaultsSimulatePlanImpl();
void InitDefaultsSimulatePlan();
inline void InitDefaults() {
  InitDefaultsSimulateData();
  InitDefaultsSimulatePoint();
  InitDefaultsSimulateCoord();
  InitDefaultsSimulatePlan();
}
}  // namespace protobuf_control_2fmonitor_5fsimulate_2eproto
namespace control {
class SimulateCoord;
class SimulateCoordDefaultTypeInternal;
extern SimulateCoordDefaultTypeInternal _SimulateCoord_default_instance_;
class SimulateData;
class SimulateDataDefaultTypeInternal;
extern SimulateDataDefaultTypeInternal _SimulateData_default_instance_;
class SimulatePlan;
class SimulatePlanDefaultTypeInternal;
extern SimulatePlanDefaultTypeInternal _SimulatePlan_default_instance_;
class SimulatePoint;
class SimulatePointDefaultTypeInternal;
extern SimulatePointDefaultTypeInternal _SimulatePoint_default_instance_;
}  // namespace control
namespace control {

// ===================================================================

class SimulateData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:control.SimulateData) */ {
 public:
  SimulateData();
  virtual ~SimulateData();

  SimulateData(const SimulateData& from);

  inline SimulateData& operator=(const SimulateData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimulateData(SimulateData&& from) noexcept
    : SimulateData() {
    *this = ::std::move(from);
  }

  inline SimulateData& operator=(SimulateData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimulateData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimulateData* internal_default_instance() {
    return reinterpret_cast<const SimulateData*>(
               &_SimulateData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(SimulateData* other);
  friend void swap(SimulateData& a, SimulateData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimulateData* New() const PROTOBUF_FINAL { return New(NULL); }

  SimulateData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SimulateData& from);
  void MergeFrom(const SimulateData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SimulateData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 seq = 1;
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 1;
  ::google::protobuf::int64 seq() const;
  void set_seq(::google::protobuf::int64 value);

  // optional double time = 2;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  double time() const;
  void set_time(double value);

  // optional double gauss_x = 3;
  bool has_gauss_x() const;
  void clear_gauss_x();
  static const int kGaussXFieldNumber = 3;
  double gauss_x() const;
  void set_gauss_x(double value);

  // optional double gauss_y = 4;
  bool has_gauss_y() const;
  void clear_gauss_y();
  static const int kGaussYFieldNumber = 4;
  double gauss_y() const;
  void set_gauss_y(double value);

  // optional double gauss_azimuth = 5;
  bool has_gauss_azimuth() const;
  void clear_gauss_azimuth();
  static const int kGaussAzimuthFieldNumber = 5;
  double gauss_azimuth() const;
  void set_gauss_azimuth(double value);

  // optional double lp_x = 6;
  bool has_lp_x() const;
  void clear_lp_x();
  static const int kLpXFieldNumber = 6;
  double lp_x() const;
  void set_lp_x(double value);

  // optional double lp_y = 7;
  bool has_lp_y() const;
  void clear_lp_y();
  static const int kLpYFieldNumber = 7;
  double lp_y() const;
  void set_lp_y(double value);

  // optional double lp_heading = 8;
  bool has_lp_heading() const;
  void clear_lp_heading();
  static const int kLpHeadingFieldNumber = 8;
  double lp_heading() const;
  void set_lp_heading(double value);

  // optional double lp_roll = 9;
  bool has_lp_roll() const;
  void clear_lp_roll();
  static const int kLpRollFieldNumber = 9;
  double lp_roll() const;
  void set_lp_roll(double value);

  // optional double lp_pitch = 10;
  bool has_lp_pitch() const;
  void clear_lp_pitch();
  static const int kLpPitchFieldNumber = 10;
  double lp_pitch() const;
  void set_lp_pitch(double value);

  // optional double lp_steer = 11;
  bool has_lp_steer() const;
  void clear_lp_steer();
  static const int kLpSteerFieldNumber = 11;
  double lp_steer() const;
  void set_lp_steer(double value);

  // optional double lp_brake = 12;
  bool has_lp_brake() const;
  void clear_lp_brake();
  static const int kLpBrakeFieldNumber = 12;
  double lp_brake() const;
  void set_lp_brake(double value);

  // optional double lp_fuel = 13;
  bool has_lp_fuel() const;
  void clear_lp_fuel();
  static const int kLpFuelFieldNumber = 13;
  double lp_fuel() const;
  void set_lp_fuel(double value);

  // optional double lp_lr_speed = 14;
  bool has_lp_lr_speed() const;
  void clear_lp_lr_speed();
  static const int kLpLrSpeedFieldNumber = 14;
  double lp_lr_speed() const;
  void set_lp_lr_speed(double value);

  // optional double lp_rr_speed = 15;
  bool has_lp_rr_speed() const;
  void clear_lp_rr_speed();
  static const int kLpRrSpeedFieldNumber = 15;
  double lp_rr_speed() const;
  void set_lp_rr_speed(double value);

  // optional double lp_acc_x = 16;
  bool has_lp_acc_x() const;
  void clear_lp_acc_x();
  static const int kLpAccXFieldNumber = 16;
  double lp_acc_x() const;
  void set_lp_acc_x(double value);

  // optional double lp_acc_y = 17;
  bool has_lp_acc_y() const;
  void clear_lp_acc_y();
  static const int kLpAccYFieldNumber = 17;
  double lp_acc_y() const;
  void set_lp_acc_y(double value);

  // optional double lp_acc_z = 18;
  bool has_lp_acc_z() const;
  void clear_lp_acc_z();
  static const int kLpAccZFieldNumber = 18;
  double lp_acc_z() const;
  void set_lp_acc_z(double value);

  // @@protoc_insertion_point(class_scope:control.SimulateData)
 private:
  void set_has_seq();
  void clear_has_seq();
  void set_has_time();
  void clear_has_time();
  void set_has_gauss_x();
  void clear_has_gauss_x();
  void set_has_gauss_y();
  void clear_has_gauss_y();
  void set_has_gauss_azimuth();
  void clear_has_gauss_azimuth();
  void set_has_lp_x();
  void clear_has_lp_x();
  void set_has_lp_y();
  void clear_has_lp_y();
  void set_has_lp_heading();
  void clear_has_lp_heading();
  void set_has_lp_roll();
  void clear_has_lp_roll();
  void set_has_lp_pitch();
  void clear_has_lp_pitch();
  void set_has_lp_steer();
  void clear_has_lp_steer();
  void set_has_lp_brake();
  void clear_has_lp_brake();
  void set_has_lp_fuel();
  void clear_has_lp_fuel();
  void set_has_lp_lr_speed();
  void clear_has_lp_lr_speed();
  void set_has_lp_rr_speed();
  void clear_has_lp_rr_speed();
  void set_has_lp_acc_x();
  void clear_has_lp_acc_x();
  void set_has_lp_acc_y();
  void clear_has_lp_acc_y();
  void set_has_lp_acc_z();
  void clear_has_lp_acc_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 seq_;
  double time_;
  double gauss_x_;
  double gauss_y_;
  double gauss_azimuth_;
  double lp_x_;
  double lp_y_;
  double lp_heading_;
  double lp_roll_;
  double lp_pitch_;
  double lp_steer_;
  double lp_brake_;
  double lp_fuel_;
  double lp_lr_speed_;
  double lp_rr_speed_;
  double lp_acc_x_;
  double lp_acc_y_;
  double lp_acc_z_;
  friend struct ::protobuf_control_2fmonitor_5fsimulate_2eproto::TableStruct;
  friend void ::protobuf_control_2fmonitor_5fsimulate_2eproto::InitDefaultsSimulateDataImpl();
};
// -------------------------------------------------------------------

class SimulatePoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:control.SimulatePoint) */ {
 public:
  SimulatePoint();
  virtual ~SimulatePoint();

  SimulatePoint(const SimulatePoint& from);

  inline SimulatePoint& operator=(const SimulatePoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimulatePoint(SimulatePoint&& from) noexcept
    : SimulatePoint() {
    *this = ::std::move(from);
  }

  inline SimulatePoint& operator=(SimulatePoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimulatePoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimulatePoint* internal_default_instance() {
    return reinterpret_cast<const SimulatePoint*>(
               &_SimulatePoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SimulatePoint* other);
  friend void swap(SimulatePoint& a, SimulatePoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimulatePoint* New() const PROTOBUF_FINAL { return New(NULL); }

  SimulatePoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SimulatePoint& from);
  void MergeFrom(const SimulatePoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SimulatePoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double velocity = 3;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  double velocity() const;
  void set_velocity(double value);

  // optional double acceleration = 4;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 4;
  double acceleration() const;
  void set_acceleration(double value);

  // optional double time = 5;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 5;
  double time() const;
  void set_time(double value);

  // optional double theta = 6;
  bool has_theta() const;
  void clear_theta();
  static const int kThetaFieldNumber = 6;
  double theta() const;
  void set_theta(double value);

  // optional double kappa = 7;
  bool has_kappa() const;
  void clear_kappa();
  static const int kKappaFieldNumber = 7;
  double kappa() const;
  void set_kappa(double value);

  // optional double dkappa = 8;
  bool has_dkappa() const;
  void clear_dkappa();
  static const int kDkappaFieldNumber = 8;
  double dkappa() const;
  void set_dkappa(double value);

  // optional double ddkappa = 9;
  bool has_ddkappa() const;
  void clear_ddkappa();
  static const int kDdkappaFieldNumber = 9;
  double ddkappa() const;
  void set_ddkappa(double value);

  // @@protoc_insertion_point(class_scope:control.SimulatePoint)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_acceleration();
  void clear_has_acceleration();
  void set_has_time();
  void clear_has_time();
  void set_has_theta();
  void clear_has_theta();
  void set_has_kappa();
  void clear_has_kappa();
  void set_has_dkappa();
  void clear_has_dkappa();
  void set_has_ddkappa();
  void clear_has_ddkappa();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  double velocity_;
  double acceleration_;
  double time_;
  double theta_;
  double kappa_;
  double dkappa_;
  double ddkappa_;
  friend struct ::protobuf_control_2fmonitor_5fsimulate_2eproto::TableStruct;
  friend void ::protobuf_control_2fmonitor_5fsimulate_2eproto::InitDefaultsSimulatePointImpl();
};
// -------------------------------------------------------------------

class SimulateCoord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:control.SimulateCoord) */ {
 public:
  SimulateCoord();
  virtual ~SimulateCoord();

  SimulateCoord(const SimulateCoord& from);

  inline SimulateCoord& operator=(const SimulateCoord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimulateCoord(SimulateCoord&& from) noexcept
    : SimulateCoord() {
    *this = ::std::move(from);
  }

  inline SimulateCoord& operator=(SimulateCoord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimulateCoord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimulateCoord* internal_default_instance() {
    return reinterpret_cast<const SimulateCoord*>(
               &_SimulateCoord_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(SimulateCoord* other);
  friend void swap(SimulateCoord& a, SimulateCoord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimulateCoord* New() const PROTOBUF_FINAL { return New(NULL); }

  SimulateCoord* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SimulateCoord& from);
  void MergeFrom(const SimulateCoord& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SimulateCoord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  double time() const;
  void set_time(double value);

  // optional double x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  double x() const;
  void set_x(double value);

  // optional double y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  double y() const;
  void set_y(double value);

  // optional double heading = 4;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 4;
  double heading() const;
  void set_heading(double value);

  // optional double roll = 5;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 5;
  double roll() const;
  void set_roll(double value);

  // optional double pitch = 6;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 6;
  double pitch() const;
  void set_pitch(double value);

  // optional double lr_speed = 7;
  bool has_lr_speed() const;
  void clear_lr_speed();
  static const int kLrSpeedFieldNumber = 7;
  double lr_speed() const;
  void set_lr_speed(double value);

  // optional double rr_speed = 8;
  bool has_rr_speed() const;
  void clear_rr_speed();
  static const int kRrSpeedFieldNumber = 8;
  double rr_speed() const;
  void set_rr_speed(double value);

  // optional double rot_x = 9;
  bool has_rot_x() const;
  void clear_rot_x();
  static const int kRotXFieldNumber = 9;
  double rot_x() const;
  void set_rot_x(double value);

  // optional double rot_y = 10;
  bool has_rot_y() const;
  void clear_rot_y();
  static const int kRotYFieldNumber = 10;
  double rot_y() const;
  void set_rot_y(double value);

  // optional double rot_z = 11;
  bool has_rot_z() const;
  void clear_rot_z();
  static const int kRotZFieldNumber = 11;
  double rot_z() const;
  void set_rot_z(double value);

  // optional double acc_x = 12;
  bool has_acc_x() const;
  void clear_acc_x();
  static const int kAccXFieldNumber = 12;
  double acc_x() const;
  void set_acc_x(double value);

  // optional double acc_y = 13;
  bool has_acc_y() const;
  void clear_acc_y();
  static const int kAccYFieldNumber = 13;
  double acc_y() const;
  void set_acc_y(double value);

  // optional double acc_z = 14;
  bool has_acc_z() const;
  void clear_acc_z();
  static const int kAccZFieldNumber = 14;
  double acc_z() const;
  void set_acc_z(double value);

  // optional double steer = 15;
  bool has_steer() const;
  void clear_steer();
  static const int kSteerFieldNumber = 15;
  double steer() const;
  void set_steer(double value);

  // optional double brake = 16;
  bool has_brake() const;
  void clear_brake();
  static const int kBrakeFieldNumber = 16;
  double brake() const;
  void set_brake(double value);

  // optional double fuel = 17;
  bool has_fuel() const;
  void clear_fuel();
  static const int kFuelFieldNumber = 17;
  double fuel() const;
  void set_fuel(double value);

  // @@protoc_insertion_point(class_scope:control.SimulateCoord)
 private:
  void set_has_time();
  void clear_has_time();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_heading();
  void clear_has_heading();
  void set_has_roll();
  void clear_has_roll();
  void set_has_pitch();
  void clear_has_pitch();
  void set_has_lr_speed();
  void clear_has_lr_speed();
  void set_has_rr_speed();
  void clear_has_rr_speed();
  void set_has_rot_x();
  void clear_has_rot_x();
  void set_has_rot_y();
  void clear_has_rot_y();
  void set_has_rot_z();
  void clear_has_rot_z();
  void set_has_acc_x();
  void clear_has_acc_x();
  void set_has_acc_y();
  void clear_has_acc_y();
  void set_has_acc_z();
  void clear_has_acc_z();
  void set_has_steer();
  void clear_has_steer();
  void set_has_brake();
  void clear_has_brake();
  void set_has_fuel();
  void clear_has_fuel();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double time_;
  double x_;
  double y_;
  double heading_;
  double roll_;
  double pitch_;
  double lr_speed_;
  double rr_speed_;
  double rot_x_;
  double rot_y_;
  double rot_z_;
  double acc_x_;
  double acc_y_;
  double acc_z_;
  double steer_;
  double brake_;
  double fuel_;
  friend struct ::protobuf_control_2fmonitor_5fsimulate_2eproto::TableStruct;
  friend void ::protobuf_control_2fmonitor_5fsimulate_2eproto::InitDefaultsSimulateCoordImpl();
};
// -------------------------------------------------------------------

class SimulatePlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:control.SimulatePlan) */ {
 public:
  SimulatePlan();
  virtual ~SimulatePlan();

  SimulatePlan(const SimulatePlan& from);

  inline SimulatePlan& operator=(const SimulatePlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SimulatePlan(SimulatePlan&& from) noexcept
    : SimulatePlan() {
    *this = ::std::move(from);
  }

  inline SimulatePlan& operator=(SimulatePlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimulatePlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimulatePlan* internal_default_instance() {
    return reinterpret_cast<const SimulatePlan*>(
               &_SimulatePlan_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(SimulatePlan* other);
  friend void swap(SimulatePlan& a, SimulatePlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SimulatePlan* New() const PROTOBUF_FINAL { return New(NULL); }

  SimulatePlan* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SimulatePlan& from);
  void MergeFrom(const SimulatePlan& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SimulatePlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .control.SimulatePoint plan_path = 4;
  int plan_path_size() const;
  void clear_plan_path();
  static const int kPlanPathFieldNumber = 4;
  const ::control::SimulatePoint& plan_path(int index) const;
  ::control::SimulatePoint* mutable_plan_path(int index);
  ::control::SimulatePoint* add_plan_path();
  ::google::protobuf::RepeatedPtrField< ::control::SimulatePoint >*
      mutable_plan_path();
  const ::google::protobuf::RepeatedPtrField< ::control::SimulatePoint >&
      plan_path() const;

  // optional double time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  double time() const;
  void set_time(double value);

  // optional int32 vehicle_command = 2;
  bool has_vehicle_command() const;
  void clear_vehicle_command();
  static const int kVehicleCommandFieldNumber = 2;
  ::google::protobuf::int32 vehicle_command() const;
  void set_vehicle_command(::google::protobuf::int32 value);

  // optional int32 turning_state = 3;
  bool has_turning_state() const;
  void clear_turning_state();
  static const int kTurningStateFieldNumber = 3;
  ::google::protobuf::int32 turning_state() const;
  void set_turning_state(::google::protobuf::int32 value);

  // optional double plan_speed = 5;
  bool has_plan_speed() const;
  void clear_plan_speed();
  static const int kPlanSpeedFieldNumber = 5;
  double plan_speed() const;
  void set_plan_speed(double value);

  // optional double plan_acceleration = 6;
  bool has_plan_acceleration() const;
  void clear_plan_acceleration();
  static const int kPlanAccelerationFieldNumber = 6;
  double plan_acceleration() const;
  void set_plan_acceleration(double value);

  // @@protoc_insertion_point(class_scope:control.SimulatePlan)
 private:
  void set_has_time();
  void clear_has_time();
  void set_has_vehicle_command();
  void clear_has_vehicle_command();
  void set_has_turning_state();
  void clear_has_turning_state();
  void set_has_plan_speed();
  void clear_has_plan_speed();
  void set_has_plan_acceleration();
  void clear_has_plan_acceleration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::control::SimulatePoint > plan_path_;
  double time_;
  ::google::protobuf::int32 vehicle_command_;
  ::google::protobuf::int32 turning_state_;
  double plan_speed_;
  double plan_acceleration_;
  friend struct ::protobuf_control_2fmonitor_5fsimulate_2eproto::TableStruct;
  friend void ::protobuf_control_2fmonitor_5fsimulate_2eproto::InitDefaultsSimulatePlanImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SimulateData

// optional int64 seq = 1;
inline bool SimulateData::has_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimulateData::set_has_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimulateData::clear_has_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimulateData::clear_seq() {
  seq_ = GOOGLE_LONGLONG(0);
  clear_has_seq();
}
inline ::google::protobuf::int64 SimulateData::seq() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.seq)
  return seq_;
}
inline void SimulateData::set_seq(::google::protobuf::int64 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.seq)
}

// optional double time = 2;
inline bool SimulateData::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimulateData::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimulateData::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimulateData::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double SimulateData::time() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.time)
  return time_;
}
inline void SimulateData::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.time)
}

// optional double gauss_x = 3;
inline bool SimulateData::has_gauss_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimulateData::set_has_gauss_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimulateData::clear_has_gauss_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimulateData::clear_gauss_x() {
  gauss_x_ = 0;
  clear_has_gauss_x();
}
inline double SimulateData::gauss_x() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.gauss_x)
  return gauss_x_;
}
inline void SimulateData::set_gauss_x(double value) {
  set_has_gauss_x();
  gauss_x_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.gauss_x)
}

// optional double gauss_y = 4;
inline bool SimulateData::has_gauss_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SimulateData::set_has_gauss_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SimulateData::clear_has_gauss_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SimulateData::clear_gauss_y() {
  gauss_y_ = 0;
  clear_has_gauss_y();
}
inline double SimulateData::gauss_y() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.gauss_y)
  return gauss_y_;
}
inline void SimulateData::set_gauss_y(double value) {
  set_has_gauss_y();
  gauss_y_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.gauss_y)
}

// optional double gauss_azimuth = 5;
inline bool SimulateData::has_gauss_azimuth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SimulateData::set_has_gauss_azimuth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SimulateData::clear_has_gauss_azimuth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SimulateData::clear_gauss_azimuth() {
  gauss_azimuth_ = 0;
  clear_has_gauss_azimuth();
}
inline double SimulateData::gauss_azimuth() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.gauss_azimuth)
  return gauss_azimuth_;
}
inline void SimulateData::set_gauss_azimuth(double value) {
  set_has_gauss_azimuth();
  gauss_azimuth_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.gauss_azimuth)
}

// optional double lp_x = 6;
inline bool SimulateData::has_lp_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SimulateData::set_has_lp_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SimulateData::clear_has_lp_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SimulateData::clear_lp_x() {
  lp_x_ = 0;
  clear_has_lp_x();
}
inline double SimulateData::lp_x() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.lp_x)
  return lp_x_;
}
inline void SimulateData::set_lp_x(double value) {
  set_has_lp_x();
  lp_x_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.lp_x)
}

// optional double lp_y = 7;
inline bool SimulateData::has_lp_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SimulateData::set_has_lp_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SimulateData::clear_has_lp_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SimulateData::clear_lp_y() {
  lp_y_ = 0;
  clear_has_lp_y();
}
inline double SimulateData::lp_y() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.lp_y)
  return lp_y_;
}
inline void SimulateData::set_lp_y(double value) {
  set_has_lp_y();
  lp_y_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.lp_y)
}

// optional double lp_heading = 8;
inline bool SimulateData::has_lp_heading() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SimulateData::set_has_lp_heading() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SimulateData::clear_has_lp_heading() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SimulateData::clear_lp_heading() {
  lp_heading_ = 0;
  clear_has_lp_heading();
}
inline double SimulateData::lp_heading() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.lp_heading)
  return lp_heading_;
}
inline void SimulateData::set_lp_heading(double value) {
  set_has_lp_heading();
  lp_heading_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.lp_heading)
}

// optional double lp_roll = 9;
inline bool SimulateData::has_lp_roll() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SimulateData::set_has_lp_roll() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SimulateData::clear_has_lp_roll() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SimulateData::clear_lp_roll() {
  lp_roll_ = 0;
  clear_has_lp_roll();
}
inline double SimulateData::lp_roll() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.lp_roll)
  return lp_roll_;
}
inline void SimulateData::set_lp_roll(double value) {
  set_has_lp_roll();
  lp_roll_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.lp_roll)
}

// optional double lp_pitch = 10;
inline bool SimulateData::has_lp_pitch() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SimulateData::set_has_lp_pitch() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SimulateData::clear_has_lp_pitch() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SimulateData::clear_lp_pitch() {
  lp_pitch_ = 0;
  clear_has_lp_pitch();
}
inline double SimulateData::lp_pitch() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.lp_pitch)
  return lp_pitch_;
}
inline void SimulateData::set_lp_pitch(double value) {
  set_has_lp_pitch();
  lp_pitch_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.lp_pitch)
}

// optional double lp_steer = 11;
inline bool SimulateData::has_lp_steer() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SimulateData::set_has_lp_steer() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SimulateData::clear_has_lp_steer() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SimulateData::clear_lp_steer() {
  lp_steer_ = 0;
  clear_has_lp_steer();
}
inline double SimulateData::lp_steer() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.lp_steer)
  return lp_steer_;
}
inline void SimulateData::set_lp_steer(double value) {
  set_has_lp_steer();
  lp_steer_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.lp_steer)
}

// optional double lp_brake = 12;
inline bool SimulateData::has_lp_brake() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SimulateData::set_has_lp_brake() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SimulateData::clear_has_lp_brake() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SimulateData::clear_lp_brake() {
  lp_brake_ = 0;
  clear_has_lp_brake();
}
inline double SimulateData::lp_brake() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.lp_brake)
  return lp_brake_;
}
inline void SimulateData::set_lp_brake(double value) {
  set_has_lp_brake();
  lp_brake_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.lp_brake)
}

// optional double lp_fuel = 13;
inline bool SimulateData::has_lp_fuel() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SimulateData::set_has_lp_fuel() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SimulateData::clear_has_lp_fuel() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SimulateData::clear_lp_fuel() {
  lp_fuel_ = 0;
  clear_has_lp_fuel();
}
inline double SimulateData::lp_fuel() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.lp_fuel)
  return lp_fuel_;
}
inline void SimulateData::set_lp_fuel(double value) {
  set_has_lp_fuel();
  lp_fuel_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.lp_fuel)
}

// optional double lp_lr_speed = 14;
inline bool SimulateData::has_lp_lr_speed() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SimulateData::set_has_lp_lr_speed() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SimulateData::clear_has_lp_lr_speed() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SimulateData::clear_lp_lr_speed() {
  lp_lr_speed_ = 0;
  clear_has_lp_lr_speed();
}
inline double SimulateData::lp_lr_speed() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.lp_lr_speed)
  return lp_lr_speed_;
}
inline void SimulateData::set_lp_lr_speed(double value) {
  set_has_lp_lr_speed();
  lp_lr_speed_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.lp_lr_speed)
}

// optional double lp_rr_speed = 15;
inline bool SimulateData::has_lp_rr_speed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SimulateData::set_has_lp_rr_speed() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SimulateData::clear_has_lp_rr_speed() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SimulateData::clear_lp_rr_speed() {
  lp_rr_speed_ = 0;
  clear_has_lp_rr_speed();
}
inline double SimulateData::lp_rr_speed() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.lp_rr_speed)
  return lp_rr_speed_;
}
inline void SimulateData::set_lp_rr_speed(double value) {
  set_has_lp_rr_speed();
  lp_rr_speed_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.lp_rr_speed)
}

// optional double lp_acc_x = 16;
inline bool SimulateData::has_lp_acc_x() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SimulateData::set_has_lp_acc_x() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SimulateData::clear_has_lp_acc_x() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SimulateData::clear_lp_acc_x() {
  lp_acc_x_ = 0;
  clear_has_lp_acc_x();
}
inline double SimulateData::lp_acc_x() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.lp_acc_x)
  return lp_acc_x_;
}
inline void SimulateData::set_lp_acc_x(double value) {
  set_has_lp_acc_x();
  lp_acc_x_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.lp_acc_x)
}

// optional double lp_acc_y = 17;
inline bool SimulateData::has_lp_acc_y() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SimulateData::set_has_lp_acc_y() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SimulateData::clear_has_lp_acc_y() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SimulateData::clear_lp_acc_y() {
  lp_acc_y_ = 0;
  clear_has_lp_acc_y();
}
inline double SimulateData::lp_acc_y() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.lp_acc_y)
  return lp_acc_y_;
}
inline void SimulateData::set_lp_acc_y(double value) {
  set_has_lp_acc_y();
  lp_acc_y_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.lp_acc_y)
}

// optional double lp_acc_z = 18;
inline bool SimulateData::has_lp_acc_z() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SimulateData::set_has_lp_acc_z() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SimulateData::clear_has_lp_acc_z() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SimulateData::clear_lp_acc_z() {
  lp_acc_z_ = 0;
  clear_has_lp_acc_z();
}
inline double SimulateData::lp_acc_z() const {
  // @@protoc_insertion_point(field_get:control.SimulateData.lp_acc_z)
  return lp_acc_z_;
}
inline void SimulateData::set_lp_acc_z(double value) {
  set_has_lp_acc_z();
  lp_acc_z_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateData.lp_acc_z)
}

// -------------------------------------------------------------------

// SimulatePoint

// optional double x = 1;
inline bool SimulatePoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimulatePoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimulatePoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimulatePoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double SimulatePoint::x() const {
  // @@protoc_insertion_point(field_get:control.SimulatePoint.x)
  return x_;
}
inline void SimulatePoint::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePoint.x)
}

// optional double y = 2;
inline bool SimulatePoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimulatePoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimulatePoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimulatePoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double SimulatePoint::y() const {
  // @@protoc_insertion_point(field_get:control.SimulatePoint.y)
  return y_;
}
inline void SimulatePoint::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePoint.y)
}

// optional double velocity = 3;
inline bool SimulatePoint::has_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimulatePoint::set_has_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimulatePoint::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimulatePoint::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline double SimulatePoint::velocity() const {
  // @@protoc_insertion_point(field_get:control.SimulatePoint.velocity)
  return velocity_;
}
inline void SimulatePoint::set_velocity(double value) {
  set_has_velocity();
  velocity_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePoint.velocity)
}

// optional double acceleration = 4;
inline bool SimulatePoint::has_acceleration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SimulatePoint::set_has_acceleration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SimulatePoint::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SimulatePoint::clear_acceleration() {
  acceleration_ = 0;
  clear_has_acceleration();
}
inline double SimulatePoint::acceleration() const {
  // @@protoc_insertion_point(field_get:control.SimulatePoint.acceleration)
  return acceleration_;
}
inline void SimulatePoint::set_acceleration(double value) {
  set_has_acceleration();
  acceleration_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePoint.acceleration)
}

// optional double time = 5;
inline bool SimulatePoint::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SimulatePoint::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SimulatePoint::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SimulatePoint::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double SimulatePoint::time() const {
  // @@protoc_insertion_point(field_get:control.SimulatePoint.time)
  return time_;
}
inline void SimulatePoint::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePoint.time)
}

// optional double theta = 6;
inline bool SimulatePoint::has_theta() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SimulatePoint::set_has_theta() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SimulatePoint::clear_has_theta() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SimulatePoint::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double SimulatePoint::theta() const {
  // @@protoc_insertion_point(field_get:control.SimulatePoint.theta)
  return theta_;
}
inline void SimulatePoint::set_theta(double value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePoint.theta)
}

// optional double kappa = 7;
inline bool SimulatePoint::has_kappa() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SimulatePoint::set_has_kappa() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SimulatePoint::clear_has_kappa() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SimulatePoint::clear_kappa() {
  kappa_ = 0;
  clear_has_kappa();
}
inline double SimulatePoint::kappa() const {
  // @@protoc_insertion_point(field_get:control.SimulatePoint.kappa)
  return kappa_;
}
inline void SimulatePoint::set_kappa(double value) {
  set_has_kappa();
  kappa_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePoint.kappa)
}

// optional double dkappa = 8;
inline bool SimulatePoint::has_dkappa() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SimulatePoint::set_has_dkappa() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SimulatePoint::clear_has_dkappa() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SimulatePoint::clear_dkappa() {
  dkappa_ = 0;
  clear_has_dkappa();
}
inline double SimulatePoint::dkappa() const {
  // @@protoc_insertion_point(field_get:control.SimulatePoint.dkappa)
  return dkappa_;
}
inline void SimulatePoint::set_dkappa(double value) {
  set_has_dkappa();
  dkappa_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePoint.dkappa)
}

// optional double ddkappa = 9;
inline bool SimulatePoint::has_ddkappa() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SimulatePoint::set_has_ddkappa() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SimulatePoint::clear_has_ddkappa() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SimulatePoint::clear_ddkappa() {
  ddkappa_ = 0;
  clear_has_ddkappa();
}
inline double SimulatePoint::ddkappa() const {
  // @@protoc_insertion_point(field_get:control.SimulatePoint.ddkappa)
  return ddkappa_;
}
inline void SimulatePoint::set_ddkappa(double value) {
  set_has_ddkappa();
  ddkappa_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePoint.ddkappa)
}

// -------------------------------------------------------------------

// SimulateCoord

// optional double time = 1;
inline bool SimulateCoord::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimulateCoord::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimulateCoord::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimulateCoord::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double SimulateCoord::time() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.time)
  return time_;
}
inline void SimulateCoord::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.time)
}

// optional double x = 2;
inline bool SimulateCoord::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimulateCoord::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimulateCoord::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimulateCoord::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double SimulateCoord::x() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.x)
  return x_;
}
inline void SimulateCoord::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.x)
}

// optional double y = 3;
inline bool SimulateCoord::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimulateCoord::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimulateCoord::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimulateCoord::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double SimulateCoord::y() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.y)
  return y_;
}
inline void SimulateCoord::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.y)
}

// optional double heading = 4;
inline bool SimulateCoord::has_heading() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SimulateCoord::set_has_heading() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SimulateCoord::clear_has_heading() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SimulateCoord::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline double SimulateCoord::heading() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.heading)
  return heading_;
}
inline void SimulateCoord::set_heading(double value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.heading)
}

// optional double roll = 5;
inline bool SimulateCoord::has_roll() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SimulateCoord::set_has_roll() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SimulateCoord::clear_has_roll() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SimulateCoord::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline double SimulateCoord::roll() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.roll)
  return roll_;
}
inline void SimulateCoord::set_roll(double value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.roll)
}

// optional double pitch = 6;
inline bool SimulateCoord::has_pitch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SimulateCoord::set_has_pitch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SimulateCoord::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SimulateCoord::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline double SimulateCoord::pitch() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.pitch)
  return pitch_;
}
inline void SimulateCoord::set_pitch(double value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.pitch)
}

// optional double lr_speed = 7;
inline bool SimulateCoord::has_lr_speed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SimulateCoord::set_has_lr_speed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SimulateCoord::clear_has_lr_speed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SimulateCoord::clear_lr_speed() {
  lr_speed_ = 0;
  clear_has_lr_speed();
}
inline double SimulateCoord::lr_speed() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.lr_speed)
  return lr_speed_;
}
inline void SimulateCoord::set_lr_speed(double value) {
  set_has_lr_speed();
  lr_speed_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.lr_speed)
}

// optional double rr_speed = 8;
inline bool SimulateCoord::has_rr_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SimulateCoord::set_has_rr_speed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SimulateCoord::clear_has_rr_speed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SimulateCoord::clear_rr_speed() {
  rr_speed_ = 0;
  clear_has_rr_speed();
}
inline double SimulateCoord::rr_speed() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.rr_speed)
  return rr_speed_;
}
inline void SimulateCoord::set_rr_speed(double value) {
  set_has_rr_speed();
  rr_speed_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.rr_speed)
}

// optional double rot_x = 9;
inline bool SimulateCoord::has_rot_x() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SimulateCoord::set_has_rot_x() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SimulateCoord::clear_has_rot_x() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SimulateCoord::clear_rot_x() {
  rot_x_ = 0;
  clear_has_rot_x();
}
inline double SimulateCoord::rot_x() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.rot_x)
  return rot_x_;
}
inline void SimulateCoord::set_rot_x(double value) {
  set_has_rot_x();
  rot_x_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.rot_x)
}

// optional double rot_y = 10;
inline bool SimulateCoord::has_rot_y() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SimulateCoord::set_has_rot_y() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SimulateCoord::clear_has_rot_y() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SimulateCoord::clear_rot_y() {
  rot_y_ = 0;
  clear_has_rot_y();
}
inline double SimulateCoord::rot_y() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.rot_y)
  return rot_y_;
}
inline void SimulateCoord::set_rot_y(double value) {
  set_has_rot_y();
  rot_y_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.rot_y)
}

// optional double rot_z = 11;
inline bool SimulateCoord::has_rot_z() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SimulateCoord::set_has_rot_z() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SimulateCoord::clear_has_rot_z() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SimulateCoord::clear_rot_z() {
  rot_z_ = 0;
  clear_has_rot_z();
}
inline double SimulateCoord::rot_z() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.rot_z)
  return rot_z_;
}
inline void SimulateCoord::set_rot_z(double value) {
  set_has_rot_z();
  rot_z_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.rot_z)
}

// optional double acc_x = 12;
inline bool SimulateCoord::has_acc_x() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SimulateCoord::set_has_acc_x() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SimulateCoord::clear_has_acc_x() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SimulateCoord::clear_acc_x() {
  acc_x_ = 0;
  clear_has_acc_x();
}
inline double SimulateCoord::acc_x() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.acc_x)
  return acc_x_;
}
inline void SimulateCoord::set_acc_x(double value) {
  set_has_acc_x();
  acc_x_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.acc_x)
}

// optional double acc_y = 13;
inline bool SimulateCoord::has_acc_y() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SimulateCoord::set_has_acc_y() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SimulateCoord::clear_has_acc_y() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SimulateCoord::clear_acc_y() {
  acc_y_ = 0;
  clear_has_acc_y();
}
inline double SimulateCoord::acc_y() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.acc_y)
  return acc_y_;
}
inline void SimulateCoord::set_acc_y(double value) {
  set_has_acc_y();
  acc_y_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.acc_y)
}

// optional double acc_z = 14;
inline bool SimulateCoord::has_acc_z() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SimulateCoord::set_has_acc_z() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SimulateCoord::clear_has_acc_z() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SimulateCoord::clear_acc_z() {
  acc_z_ = 0;
  clear_has_acc_z();
}
inline double SimulateCoord::acc_z() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.acc_z)
  return acc_z_;
}
inline void SimulateCoord::set_acc_z(double value) {
  set_has_acc_z();
  acc_z_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.acc_z)
}

// optional double steer = 15;
inline bool SimulateCoord::has_steer() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SimulateCoord::set_has_steer() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SimulateCoord::clear_has_steer() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SimulateCoord::clear_steer() {
  steer_ = 0;
  clear_has_steer();
}
inline double SimulateCoord::steer() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.steer)
  return steer_;
}
inline void SimulateCoord::set_steer(double value) {
  set_has_steer();
  steer_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.steer)
}

// optional double brake = 16;
inline bool SimulateCoord::has_brake() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SimulateCoord::set_has_brake() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SimulateCoord::clear_has_brake() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SimulateCoord::clear_brake() {
  brake_ = 0;
  clear_has_brake();
}
inline double SimulateCoord::brake() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.brake)
  return brake_;
}
inline void SimulateCoord::set_brake(double value) {
  set_has_brake();
  brake_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.brake)
}

// optional double fuel = 17;
inline bool SimulateCoord::has_fuel() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SimulateCoord::set_has_fuel() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SimulateCoord::clear_has_fuel() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SimulateCoord::clear_fuel() {
  fuel_ = 0;
  clear_has_fuel();
}
inline double SimulateCoord::fuel() const {
  // @@protoc_insertion_point(field_get:control.SimulateCoord.fuel)
  return fuel_;
}
inline void SimulateCoord::set_fuel(double value) {
  set_has_fuel();
  fuel_ = value;
  // @@protoc_insertion_point(field_set:control.SimulateCoord.fuel)
}

// -------------------------------------------------------------------

// SimulatePlan

// optional double time = 1;
inline bool SimulatePlan::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimulatePlan::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimulatePlan::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimulatePlan::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double SimulatePlan::time() const {
  // @@protoc_insertion_point(field_get:control.SimulatePlan.time)
  return time_;
}
inline void SimulatePlan::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePlan.time)
}

// optional int32 vehicle_command = 2;
inline bool SimulatePlan::has_vehicle_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimulatePlan::set_has_vehicle_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimulatePlan::clear_has_vehicle_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimulatePlan::clear_vehicle_command() {
  vehicle_command_ = 0;
  clear_has_vehicle_command();
}
inline ::google::protobuf::int32 SimulatePlan::vehicle_command() const {
  // @@protoc_insertion_point(field_get:control.SimulatePlan.vehicle_command)
  return vehicle_command_;
}
inline void SimulatePlan::set_vehicle_command(::google::protobuf::int32 value) {
  set_has_vehicle_command();
  vehicle_command_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePlan.vehicle_command)
}

// optional int32 turning_state = 3;
inline bool SimulatePlan::has_turning_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimulatePlan::set_has_turning_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimulatePlan::clear_has_turning_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimulatePlan::clear_turning_state() {
  turning_state_ = 0;
  clear_has_turning_state();
}
inline ::google::protobuf::int32 SimulatePlan::turning_state() const {
  // @@protoc_insertion_point(field_get:control.SimulatePlan.turning_state)
  return turning_state_;
}
inline void SimulatePlan::set_turning_state(::google::protobuf::int32 value) {
  set_has_turning_state();
  turning_state_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePlan.turning_state)
}

// repeated .control.SimulatePoint plan_path = 4;
inline int SimulatePlan::plan_path_size() const {
  return plan_path_.size();
}
inline void SimulatePlan::clear_plan_path() {
  plan_path_.Clear();
}
inline const ::control::SimulatePoint& SimulatePlan::plan_path(int index) const {
  // @@protoc_insertion_point(field_get:control.SimulatePlan.plan_path)
  return plan_path_.Get(index);
}
inline ::control::SimulatePoint* SimulatePlan::mutable_plan_path(int index) {
  // @@protoc_insertion_point(field_mutable:control.SimulatePlan.plan_path)
  return plan_path_.Mutable(index);
}
inline ::control::SimulatePoint* SimulatePlan::add_plan_path() {
  // @@protoc_insertion_point(field_add:control.SimulatePlan.plan_path)
  return plan_path_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::control::SimulatePoint >*
SimulatePlan::mutable_plan_path() {
  // @@protoc_insertion_point(field_mutable_list:control.SimulatePlan.plan_path)
  return &plan_path_;
}
inline const ::google::protobuf::RepeatedPtrField< ::control::SimulatePoint >&
SimulatePlan::plan_path() const {
  // @@protoc_insertion_point(field_list:control.SimulatePlan.plan_path)
  return plan_path_;
}

// optional double plan_speed = 5;
inline bool SimulatePlan::has_plan_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SimulatePlan::set_has_plan_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SimulatePlan::clear_has_plan_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SimulatePlan::clear_plan_speed() {
  plan_speed_ = 0;
  clear_has_plan_speed();
}
inline double SimulatePlan::plan_speed() const {
  // @@protoc_insertion_point(field_get:control.SimulatePlan.plan_speed)
  return plan_speed_;
}
inline void SimulatePlan::set_plan_speed(double value) {
  set_has_plan_speed();
  plan_speed_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePlan.plan_speed)
}

// optional double plan_acceleration = 6;
inline bool SimulatePlan::has_plan_acceleration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SimulatePlan::set_has_plan_acceleration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SimulatePlan::clear_has_plan_acceleration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SimulatePlan::clear_plan_acceleration() {
  plan_acceleration_ = 0;
  clear_has_plan_acceleration();
}
inline double SimulatePlan::plan_acceleration() const {
  // @@protoc_insertion_point(field_get:control.SimulatePlan.plan_acceleration)
  return plan_acceleration_;
}
inline void SimulatePlan::set_plan_acceleration(double value) {
  set_has_plan_acceleration();
  plan_acceleration_ = value;
  // @@protoc_insertion_point(field_set:control.SimulatePlan.plan_acceleration)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace control

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_control_2fmonitor_5fsimulate_2eproto__INCLUDED
