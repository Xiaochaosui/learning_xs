// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planner/open_space.proto

#ifndef PROTOBUF_planner_2fopen_5fspace_2eproto__INCLUDED
#define PROTOBUF_planner_2fopen_5fspace_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_planner_2fopen_5fspace_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPlannerOpenSpaceConfigImpl();
void InitDefaultsPlannerOpenSpaceConfig();
void InitDefaultsHybridAStarImpl();
void InitDefaultsHybridAStar();
void InitDefaultsVehicleParamImpl();
void InitDefaultsVehicleParam();
inline void InitDefaults() {
  InitDefaultsPlannerOpenSpaceConfig();
  InitDefaultsHybridAStar();
  InitDefaultsVehicleParam();
}
}  // namespace protobuf_planner_2fopen_5fspace_2eproto
namespace plan {
class HybridAStar;
class HybridAStarDefaultTypeInternal;
extern HybridAStarDefaultTypeInternal _HybridAStar_default_instance_;
class PlannerOpenSpaceConfig;
class PlannerOpenSpaceConfigDefaultTypeInternal;
extern PlannerOpenSpaceConfigDefaultTypeInternal _PlannerOpenSpaceConfig_default_instance_;
class VehicleParam;
class VehicleParamDefaultTypeInternal;
extern VehicleParamDefaultTypeInternal _VehicleParam_default_instance_;
}  // namespace plan
namespace plan {

// ===================================================================

class PlannerOpenSpaceConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:plan.PlannerOpenSpaceConfig) */ {
 public:
  PlannerOpenSpaceConfig();
  virtual ~PlannerOpenSpaceConfig();

  PlannerOpenSpaceConfig(const PlannerOpenSpaceConfig& from);

  inline PlannerOpenSpaceConfig& operator=(const PlannerOpenSpaceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlannerOpenSpaceConfig(PlannerOpenSpaceConfig&& from) noexcept
    : PlannerOpenSpaceConfig() {
    *this = ::std::move(from);
  }

  inline PlannerOpenSpaceConfig& operator=(PlannerOpenSpaceConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlannerOpenSpaceConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlannerOpenSpaceConfig* internal_default_instance() {
    return reinterpret_cast<const PlannerOpenSpaceConfig*>(
               &_PlannerOpenSpaceConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PlannerOpenSpaceConfig* other);
  friend void swap(PlannerOpenSpaceConfig& a, PlannerOpenSpaceConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlannerOpenSpaceConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  PlannerOpenSpaceConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlannerOpenSpaceConfig& from);
  void MergeFrom(const PlannerOpenSpaceConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlannerOpenSpaceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .plan.HybridAStar hybrid_a_star = 1;
  bool has_hybrid_a_star() const;
  void clear_hybrid_a_star();
  static const int kHybridAStarFieldNumber = 1;
  const ::plan::HybridAStar& hybrid_a_star() const;
  ::plan::HybridAStar* release_hybrid_a_star();
  ::plan::HybridAStar* mutable_hybrid_a_star();
  void set_allocated_hybrid_a_star(::plan::HybridAStar* hybrid_a_star);

  // optional .plan.VehicleParam vehicle_param = 4;
  bool has_vehicle_param() const;
  void clear_vehicle_param();
  static const int kVehicleParamFieldNumber = 4;
  const ::plan::VehicleParam& vehicle_param() const;
  ::plan::VehicleParam* release_vehicle_param();
  ::plan::VehicleParam* mutable_vehicle_param();
  void set_allocated_vehicle_param(::plan::VehicleParam* vehicle_param);

  // @@protoc_insertion_point(class_scope:plan.PlannerOpenSpaceConfig)
 private:
  void set_has_hybrid_a_star();
  void clear_has_hybrid_a_star();
  void set_has_vehicle_param();
  void clear_has_vehicle_param();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::plan::HybridAStar* hybrid_a_star_;
  ::plan::VehicleParam* vehicle_param_;
  friend struct ::protobuf_planner_2fopen_5fspace_2eproto::TableStruct;
  friend void ::protobuf_planner_2fopen_5fspace_2eproto::InitDefaultsPlannerOpenSpaceConfigImpl();
};
// -------------------------------------------------------------------

class HybridAStar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:plan.HybridAStar) */ {
 public:
  HybridAStar();
  virtual ~HybridAStar();

  HybridAStar(const HybridAStar& from);

  inline HybridAStar& operator=(const HybridAStar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HybridAStar(HybridAStar&& from) noexcept
    : HybridAStar() {
    *this = ::std::move(from);
  }

  inline HybridAStar& operator=(HybridAStar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HybridAStar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HybridAStar* internal_default_instance() {
    return reinterpret_cast<const HybridAStar*>(
               &_HybridAStar_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HybridAStar* other);
  friend void swap(HybridAStar& a, HybridAStar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HybridAStar* New() const PROTOBUF_FINAL { return New(NULL); }

  HybridAStar* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HybridAStar& from);
  void MergeFrom(const HybridAStar& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HybridAStar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double traj_forward_penalty = 5 [default = 0];
  bool has_traj_forward_penalty() const;
  void clear_traj_forward_penalty();
  static const int kTrajForwardPenaltyFieldNumber = 5;
  double traj_forward_penalty() const;
  void set_traj_forward_penalty(double value);

  // optional double traj_back_penalty = 6 [default = 0];
  bool has_traj_back_penalty() const;
  void clear_traj_back_penalty();
  static const int kTrajBackPenaltyFieldNumber = 6;
  double traj_back_penalty() const;
  void set_traj_back_penalty(double value);

  // optional float delta_t = 10 [default = 1];
  bool has_delta_t() const;
  void clear_delta_t();
  static const int kDeltaTFieldNumber = 10;
  float delta_t() const;
  void set_delta_t(float value);

  // optional double xy_grid_resolution = 1 [default = 0.2];
  bool has_xy_grid_resolution() const;
  void clear_xy_grid_resolution();
  static const int kXyGridResolutionFieldNumber = 1;
  double xy_grid_resolution() const;
  void set_xy_grid_resolution(double value);

  // optional double phi_grid_resolution = 2 [default = 0.05];
  bool has_phi_grid_resolution() const;
  void clear_phi_grid_resolution();
  static const int kPhiGridResolutionFieldNumber = 2;
  double phi_grid_resolution() const;
  void set_phi_grid_resolution(double value);

  // optional uint64 next_node_num = 3 [default = 10];
  bool has_next_node_num() const;
  void clear_next_node_num();
  static const int kNextNodeNumFieldNumber = 3;
  ::google::protobuf::uint64 next_node_num() const;
  void set_next_node_num(::google::protobuf::uint64 value);

  // optional double step_size = 4 [default = 0.5];
  bool has_step_size() const;
  void clear_step_size();
  static const int kStepSizeFieldNumber = 4;
  double step_size() const;
  void set_step_size(double value);

  // optional double traj_gear_switch_penalty = 7 [default = 10];
  bool has_traj_gear_switch_penalty() const;
  void clear_traj_gear_switch_penalty();
  static const int kTrajGearSwitchPenaltyFieldNumber = 7;
  double traj_gear_switch_penalty() const;
  void set_traj_gear_switch_penalty(double value);

  // optional double traj_steer_penalty = 8 [default = 100];
  bool has_traj_steer_penalty() const;
  void clear_traj_steer_penalty();
  static const int kTrajSteerPenaltyFieldNumber = 8;
  double traj_steer_penalty() const;
  void set_traj_steer_penalty(double value);

  // optional double traj_steer_change_penalty = 9 [default = 10];
  bool has_traj_steer_change_penalty() const;
  void clear_traj_steer_change_penalty();
  static const int kTrajSteerChangePenaltyFieldNumber = 9;
  double traj_steer_change_penalty() const;
  void set_traj_steer_change_penalty(double value);

  // optional double grid_a_star_xy_resolution = 15 [default = 0.1];
  bool has_grid_a_star_xy_resolution() const;
  void clear_grid_a_star_xy_resolution();
  static const int kGridAStarXyResolutionFieldNumber = 15;
  double grid_a_star_xy_resolution() const;
  void set_grid_a_star_xy_resolution(double value);

  // optional double node_radius = 16 [default = 0.5];
  bool has_node_radius() const;
  void clear_node_radius();
  static const int kNodeRadiusFieldNumber = 16;
  double node_radius() const;
  void set_node_radius(double value);

  // optional double safe_distance = 17 [default = 0.2];
  bool has_safe_distance() const;
  void clear_safe_distance();
  static const int kSafeDistanceFieldNumber = 17;
  double safe_distance() const;
  void set_safe_distance(double value);

  // @@protoc_insertion_point(class_scope:plan.HybridAStar)
 private:
  void set_has_xy_grid_resolution();
  void clear_has_xy_grid_resolution();
  void set_has_phi_grid_resolution();
  void clear_has_phi_grid_resolution();
  void set_has_next_node_num();
  void clear_has_next_node_num();
  void set_has_step_size();
  void clear_has_step_size();
  void set_has_traj_forward_penalty();
  void clear_has_traj_forward_penalty();
  void set_has_traj_back_penalty();
  void clear_has_traj_back_penalty();
  void set_has_traj_gear_switch_penalty();
  void clear_has_traj_gear_switch_penalty();
  void set_has_traj_steer_penalty();
  void clear_has_traj_steer_penalty();
  void set_has_traj_steer_change_penalty();
  void clear_has_traj_steer_change_penalty();
  void set_has_delta_t();
  void clear_has_delta_t();
  void set_has_grid_a_star_xy_resolution();
  void clear_has_grid_a_star_xy_resolution();
  void set_has_node_radius();
  void clear_has_node_radius();
  void set_has_safe_distance();
  void clear_has_safe_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double traj_forward_penalty_;
  double traj_back_penalty_;
  float delta_t_;
  double xy_grid_resolution_;
  double phi_grid_resolution_;
  ::google::protobuf::uint64 next_node_num_;
  double step_size_;
  double traj_gear_switch_penalty_;
  double traj_steer_penalty_;
  double traj_steer_change_penalty_;
  double grid_a_star_xy_resolution_;
  double node_radius_;
  double safe_distance_;
  friend struct ::protobuf_planner_2fopen_5fspace_2eproto::TableStruct;
  friend void ::protobuf_planner_2fopen_5fspace_2eproto::InitDefaultsHybridAStarImpl();
};
// -------------------------------------------------------------------

class VehicleParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:plan.VehicleParam) */ {
 public:
  VehicleParam();
  virtual ~VehicleParam();

  VehicleParam(const VehicleParam& from);

  inline VehicleParam& operator=(const VehicleParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleParam(VehicleParam&& from) noexcept
    : VehicleParam() {
    *this = ::std::move(from);
  }

  inline VehicleParam& operator=(VehicleParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleParam* internal_default_instance() {
    return reinterpret_cast<const VehicleParam*>(
               &_VehicleParam_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(VehicleParam* other);
  friend void swap(VehicleParam& a, VehicleParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleParam* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleParam* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleParam& from);
  void MergeFrom(const VehicleParam& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double max_steer_angle = 1 [default = 0.67];
  bool has_max_steer_angle() const;
  void clear_max_steer_angle();
  static const int kMaxSteerAngleFieldNumber = 1;
  double max_steer_angle() const;
  void set_max_steer_angle(double value);

  // optional double wheel_base = 2 [default = 1.6];
  bool has_wheel_base() const;
  void clear_wheel_base();
  static const int kWheelBaseFieldNumber = 2;
  double wheel_base() const;
  void set_wheel_base(double value);

  // optional double ego_length = 3 [default = 2];
  bool has_ego_length() const;
  void clear_ego_length();
  static const int kEgoLengthFieldNumber = 3;
  double ego_length() const;
  void set_ego_length(double value);

  // optional double ego_width = 4 [default = 1];
  bool has_ego_width() const;
  void clear_ego_width();
  static const int kEgoWidthFieldNumber = 4;
  double ego_width() const;
  void set_ego_width(double value);

  // optional double steer_ratio = 5 [default = 1];
  bool has_steer_ratio() const;
  void clear_steer_ratio();
  static const int kSteerRatioFieldNumber = 5;
  double steer_ratio() const;
  void set_steer_ratio(double value);

  // optional double back_edge_to_center = 6 [default = 0.38];
  bool has_back_edge_to_center() const;
  void clear_back_edge_to_center();
  static const int kBackEdgeToCenterFieldNumber = 6;
  double back_edge_to_center() const;
  void set_back_edge_to_center(double value);

  // @@protoc_insertion_point(class_scope:plan.VehicleParam)
 private:
  void set_has_max_steer_angle();
  void clear_has_max_steer_angle();
  void set_has_wheel_base();
  void clear_has_wheel_base();
  void set_has_ego_length();
  void clear_has_ego_length();
  void set_has_ego_width();
  void clear_has_ego_width();
  void set_has_steer_ratio();
  void clear_has_steer_ratio();
  void set_has_back_edge_to_center();
  void clear_has_back_edge_to_center();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double max_steer_angle_;
  double wheel_base_;
  double ego_length_;
  double ego_width_;
  double steer_ratio_;
  double back_edge_to_center_;
  friend struct ::protobuf_planner_2fopen_5fspace_2eproto::TableStruct;
  friend void ::protobuf_planner_2fopen_5fspace_2eproto::InitDefaultsVehicleParamImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlannerOpenSpaceConfig

// optional .plan.HybridAStar hybrid_a_star = 1;
inline bool PlannerOpenSpaceConfig::has_hybrid_a_star() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlannerOpenSpaceConfig::set_has_hybrid_a_star() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlannerOpenSpaceConfig::clear_has_hybrid_a_star() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlannerOpenSpaceConfig::clear_hybrid_a_star() {
  if (hybrid_a_star_ != NULL) hybrid_a_star_->Clear();
  clear_has_hybrid_a_star();
}
inline const ::plan::HybridAStar& PlannerOpenSpaceConfig::hybrid_a_star() const {
  const ::plan::HybridAStar* p = hybrid_a_star_;
  // @@protoc_insertion_point(field_get:plan.PlannerOpenSpaceConfig.hybrid_a_star)
  return p != NULL ? *p : *reinterpret_cast<const ::plan::HybridAStar*>(
      &::plan::_HybridAStar_default_instance_);
}
inline ::plan::HybridAStar* PlannerOpenSpaceConfig::release_hybrid_a_star() {
  // @@protoc_insertion_point(field_release:plan.PlannerOpenSpaceConfig.hybrid_a_star)
  clear_has_hybrid_a_star();
  ::plan::HybridAStar* temp = hybrid_a_star_;
  hybrid_a_star_ = NULL;
  return temp;
}
inline ::plan::HybridAStar* PlannerOpenSpaceConfig::mutable_hybrid_a_star() {
  set_has_hybrid_a_star();
  if (hybrid_a_star_ == NULL) {
    hybrid_a_star_ = new ::plan::HybridAStar;
  }
  // @@protoc_insertion_point(field_mutable:plan.PlannerOpenSpaceConfig.hybrid_a_star)
  return hybrid_a_star_;
}
inline void PlannerOpenSpaceConfig::set_allocated_hybrid_a_star(::plan::HybridAStar* hybrid_a_star) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hybrid_a_star_;
  }
  if (hybrid_a_star) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hybrid_a_star = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hybrid_a_star, submessage_arena);
    }
    set_has_hybrid_a_star();
  } else {
    clear_has_hybrid_a_star();
  }
  hybrid_a_star_ = hybrid_a_star;
  // @@protoc_insertion_point(field_set_allocated:plan.PlannerOpenSpaceConfig.hybrid_a_star)
}

// optional .plan.VehicleParam vehicle_param = 4;
inline bool PlannerOpenSpaceConfig::has_vehicle_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlannerOpenSpaceConfig::set_has_vehicle_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlannerOpenSpaceConfig::clear_has_vehicle_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlannerOpenSpaceConfig::clear_vehicle_param() {
  if (vehicle_param_ != NULL) vehicle_param_->Clear();
  clear_has_vehicle_param();
}
inline const ::plan::VehicleParam& PlannerOpenSpaceConfig::vehicle_param() const {
  const ::plan::VehicleParam* p = vehicle_param_;
  // @@protoc_insertion_point(field_get:plan.PlannerOpenSpaceConfig.vehicle_param)
  return p != NULL ? *p : *reinterpret_cast<const ::plan::VehicleParam*>(
      &::plan::_VehicleParam_default_instance_);
}
inline ::plan::VehicleParam* PlannerOpenSpaceConfig::release_vehicle_param() {
  // @@protoc_insertion_point(field_release:plan.PlannerOpenSpaceConfig.vehicle_param)
  clear_has_vehicle_param();
  ::plan::VehicleParam* temp = vehicle_param_;
  vehicle_param_ = NULL;
  return temp;
}
inline ::plan::VehicleParam* PlannerOpenSpaceConfig::mutable_vehicle_param() {
  set_has_vehicle_param();
  if (vehicle_param_ == NULL) {
    vehicle_param_ = new ::plan::VehicleParam;
  }
  // @@protoc_insertion_point(field_mutable:plan.PlannerOpenSpaceConfig.vehicle_param)
  return vehicle_param_;
}
inline void PlannerOpenSpaceConfig::set_allocated_vehicle_param(::plan::VehicleParam* vehicle_param) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vehicle_param_;
  }
  if (vehicle_param) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vehicle_param = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vehicle_param, submessage_arena);
    }
    set_has_vehicle_param();
  } else {
    clear_has_vehicle_param();
  }
  vehicle_param_ = vehicle_param;
  // @@protoc_insertion_point(field_set_allocated:plan.PlannerOpenSpaceConfig.vehicle_param)
}

// -------------------------------------------------------------------

// HybridAStar

// optional double xy_grid_resolution = 1 [default = 0.2];
inline bool HybridAStar::has_xy_grid_resolution() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HybridAStar::set_has_xy_grid_resolution() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HybridAStar::clear_has_xy_grid_resolution() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HybridAStar::clear_xy_grid_resolution() {
  xy_grid_resolution_ = 0.2;
  clear_has_xy_grid_resolution();
}
inline double HybridAStar::xy_grid_resolution() const {
  // @@protoc_insertion_point(field_get:plan.HybridAStar.xy_grid_resolution)
  return xy_grid_resolution_;
}
inline void HybridAStar::set_xy_grid_resolution(double value) {
  set_has_xy_grid_resolution();
  xy_grid_resolution_ = value;
  // @@protoc_insertion_point(field_set:plan.HybridAStar.xy_grid_resolution)
}

// optional double phi_grid_resolution = 2 [default = 0.05];
inline bool HybridAStar::has_phi_grid_resolution() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HybridAStar::set_has_phi_grid_resolution() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HybridAStar::clear_has_phi_grid_resolution() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HybridAStar::clear_phi_grid_resolution() {
  phi_grid_resolution_ = 0.05;
  clear_has_phi_grid_resolution();
}
inline double HybridAStar::phi_grid_resolution() const {
  // @@protoc_insertion_point(field_get:plan.HybridAStar.phi_grid_resolution)
  return phi_grid_resolution_;
}
inline void HybridAStar::set_phi_grid_resolution(double value) {
  set_has_phi_grid_resolution();
  phi_grid_resolution_ = value;
  // @@protoc_insertion_point(field_set:plan.HybridAStar.phi_grid_resolution)
}

// optional uint64 next_node_num = 3 [default = 10];
inline bool HybridAStar::has_next_node_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HybridAStar::set_has_next_node_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HybridAStar::clear_has_next_node_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HybridAStar::clear_next_node_num() {
  next_node_num_ = GOOGLE_ULONGLONG(10);
  clear_has_next_node_num();
}
inline ::google::protobuf::uint64 HybridAStar::next_node_num() const {
  // @@protoc_insertion_point(field_get:plan.HybridAStar.next_node_num)
  return next_node_num_;
}
inline void HybridAStar::set_next_node_num(::google::protobuf::uint64 value) {
  set_has_next_node_num();
  next_node_num_ = value;
  // @@protoc_insertion_point(field_set:plan.HybridAStar.next_node_num)
}

// optional double step_size = 4 [default = 0.5];
inline bool HybridAStar::has_step_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HybridAStar::set_has_step_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HybridAStar::clear_has_step_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HybridAStar::clear_step_size() {
  step_size_ = 0.5;
  clear_has_step_size();
}
inline double HybridAStar::step_size() const {
  // @@protoc_insertion_point(field_get:plan.HybridAStar.step_size)
  return step_size_;
}
inline void HybridAStar::set_step_size(double value) {
  set_has_step_size();
  step_size_ = value;
  // @@protoc_insertion_point(field_set:plan.HybridAStar.step_size)
}

// optional double traj_forward_penalty = 5 [default = 0];
inline bool HybridAStar::has_traj_forward_penalty() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HybridAStar::set_has_traj_forward_penalty() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HybridAStar::clear_has_traj_forward_penalty() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HybridAStar::clear_traj_forward_penalty() {
  traj_forward_penalty_ = 0;
  clear_has_traj_forward_penalty();
}
inline double HybridAStar::traj_forward_penalty() const {
  // @@protoc_insertion_point(field_get:plan.HybridAStar.traj_forward_penalty)
  return traj_forward_penalty_;
}
inline void HybridAStar::set_traj_forward_penalty(double value) {
  set_has_traj_forward_penalty();
  traj_forward_penalty_ = value;
  // @@protoc_insertion_point(field_set:plan.HybridAStar.traj_forward_penalty)
}

// optional double traj_back_penalty = 6 [default = 0];
inline bool HybridAStar::has_traj_back_penalty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HybridAStar::set_has_traj_back_penalty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HybridAStar::clear_has_traj_back_penalty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HybridAStar::clear_traj_back_penalty() {
  traj_back_penalty_ = 0;
  clear_has_traj_back_penalty();
}
inline double HybridAStar::traj_back_penalty() const {
  // @@protoc_insertion_point(field_get:plan.HybridAStar.traj_back_penalty)
  return traj_back_penalty_;
}
inline void HybridAStar::set_traj_back_penalty(double value) {
  set_has_traj_back_penalty();
  traj_back_penalty_ = value;
  // @@protoc_insertion_point(field_set:plan.HybridAStar.traj_back_penalty)
}

// optional double traj_gear_switch_penalty = 7 [default = 10];
inline bool HybridAStar::has_traj_gear_switch_penalty() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HybridAStar::set_has_traj_gear_switch_penalty() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HybridAStar::clear_has_traj_gear_switch_penalty() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HybridAStar::clear_traj_gear_switch_penalty() {
  traj_gear_switch_penalty_ = 10;
  clear_has_traj_gear_switch_penalty();
}
inline double HybridAStar::traj_gear_switch_penalty() const {
  // @@protoc_insertion_point(field_get:plan.HybridAStar.traj_gear_switch_penalty)
  return traj_gear_switch_penalty_;
}
inline void HybridAStar::set_traj_gear_switch_penalty(double value) {
  set_has_traj_gear_switch_penalty();
  traj_gear_switch_penalty_ = value;
  // @@protoc_insertion_point(field_set:plan.HybridAStar.traj_gear_switch_penalty)
}

// optional double traj_steer_penalty = 8 [default = 100];
inline bool HybridAStar::has_traj_steer_penalty() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HybridAStar::set_has_traj_steer_penalty() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HybridAStar::clear_has_traj_steer_penalty() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HybridAStar::clear_traj_steer_penalty() {
  traj_steer_penalty_ = 100;
  clear_has_traj_steer_penalty();
}
inline double HybridAStar::traj_steer_penalty() const {
  // @@protoc_insertion_point(field_get:plan.HybridAStar.traj_steer_penalty)
  return traj_steer_penalty_;
}
inline void HybridAStar::set_traj_steer_penalty(double value) {
  set_has_traj_steer_penalty();
  traj_steer_penalty_ = value;
  // @@protoc_insertion_point(field_set:plan.HybridAStar.traj_steer_penalty)
}

// optional double traj_steer_change_penalty = 9 [default = 10];
inline bool HybridAStar::has_traj_steer_change_penalty() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HybridAStar::set_has_traj_steer_change_penalty() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HybridAStar::clear_has_traj_steer_change_penalty() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HybridAStar::clear_traj_steer_change_penalty() {
  traj_steer_change_penalty_ = 10;
  clear_has_traj_steer_change_penalty();
}
inline double HybridAStar::traj_steer_change_penalty() const {
  // @@protoc_insertion_point(field_get:plan.HybridAStar.traj_steer_change_penalty)
  return traj_steer_change_penalty_;
}
inline void HybridAStar::set_traj_steer_change_penalty(double value) {
  set_has_traj_steer_change_penalty();
  traj_steer_change_penalty_ = value;
  // @@protoc_insertion_point(field_set:plan.HybridAStar.traj_steer_change_penalty)
}

// optional float delta_t = 10 [default = 1];
inline bool HybridAStar::has_delta_t() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HybridAStar::set_has_delta_t() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HybridAStar::clear_has_delta_t() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HybridAStar::clear_delta_t() {
  delta_t_ = 1;
  clear_has_delta_t();
}
inline float HybridAStar::delta_t() const {
  // @@protoc_insertion_point(field_get:plan.HybridAStar.delta_t)
  return delta_t_;
}
inline void HybridAStar::set_delta_t(float value) {
  set_has_delta_t();
  delta_t_ = value;
  // @@protoc_insertion_point(field_set:plan.HybridAStar.delta_t)
}

// optional double grid_a_star_xy_resolution = 15 [default = 0.1];
inline bool HybridAStar::has_grid_a_star_xy_resolution() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HybridAStar::set_has_grid_a_star_xy_resolution() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HybridAStar::clear_has_grid_a_star_xy_resolution() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HybridAStar::clear_grid_a_star_xy_resolution() {
  grid_a_star_xy_resolution_ = 0.1;
  clear_has_grid_a_star_xy_resolution();
}
inline double HybridAStar::grid_a_star_xy_resolution() const {
  // @@protoc_insertion_point(field_get:plan.HybridAStar.grid_a_star_xy_resolution)
  return grid_a_star_xy_resolution_;
}
inline void HybridAStar::set_grid_a_star_xy_resolution(double value) {
  set_has_grid_a_star_xy_resolution();
  grid_a_star_xy_resolution_ = value;
  // @@protoc_insertion_point(field_set:plan.HybridAStar.grid_a_star_xy_resolution)
}

// optional double node_radius = 16 [default = 0.5];
inline bool HybridAStar::has_node_radius() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HybridAStar::set_has_node_radius() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HybridAStar::clear_has_node_radius() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HybridAStar::clear_node_radius() {
  node_radius_ = 0.5;
  clear_has_node_radius();
}
inline double HybridAStar::node_radius() const {
  // @@protoc_insertion_point(field_get:plan.HybridAStar.node_radius)
  return node_radius_;
}
inline void HybridAStar::set_node_radius(double value) {
  set_has_node_radius();
  node_radius_ = value;
  // @@protoc_insertion_point(field_set:plan.HybridAStar.node_radius)
}

// optional double safe_distance = 17 [default = 0.2];
inline bool HybridAStar::has_safe_distance() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void HybridAStar::set_has_safe_distance() {
  _has_bits_[0] |= 0x00001000u;
}
inline void HybridAStar::clear_has_safe_distance() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void HybridAStar::clear_safe_distance() {
  safe_distance_ = 0.2;
  clear_has_safe_distance();
}
inline double HybridAStar::safe_distance() const {
  // @@protoc_insertion_point(field_get:plan.HybridAStar.safe_distance)
  return safe_distance_;
}
inline void HybridAStar::set_safe_distance(double value) {
  set_has_safe_distance();
  safe_distance_ = value;
  // @@protoc_insertion_point(field_set:plan.HybridAStar.safe_distance)
}

// -------------------------------------------------------------------

// VehicleParam

// optional double max_steer_angle = 1 [default = 0.67];
inline bool VehicleParam::has_max_steer_angle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleParam::set_has_max_steer_angle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleParam::clear_has_max_steer_angle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleParam::clear_max_steer_angle() {
  max_steer_angle_ = 0.67;
  clear_has_max_steer_angle();
}
inline double VehicleParam::max_steer_angle() const {
  // @@protoc_insertion_point(field_get:plan.VehicleParam.max_steer_angle)
  return max_steer_angle_;
}
inline void VehicleParam::set_max_steer_angle(double value) {
  set_has_max_steer_angle();
  max_steer_angle_ = value;
  // @@protoc_insertion_point(field_set:plan.VehicleParam.max_steer_angle)
}

// optional double wheel_base = 2 [default = 1.6];
inline bool VehicleParam::has_wheel_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleParam::set_has_wheel_base() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleParam::clear_has_wheel_base() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleParam::clear_wheel_base() {
  wheel_base_ = 1.6;
  clear_has_wheel_base();
}
inline double VehicleParam::wheel_base() const {
  // @@protoc_insertion_point(field_get:plan.VehicleParam.wheel_base)
  return wheel_base_;
}
inline void VehicleParam::set_wheel_base(double value) {
  set_has_wheel_base();
  wheel_base_ = value;
  // @@protoc_insertion_point(field_set:plan.VehicleParam.wheel_base)
}

// optional double ego_length = 3 [default = 2];
inline bool VehicleParam::has_ego_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleParam::set_has_ego_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleParam::clear_has_ego_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleParam::clear_ego_length() {
  ego_length_ = 2;
  clear_has_ego_length();
}
inline double VehicleParam::ego_length() const {
  // @@protoc_insertion_point(field_get:plan.VehicleParam.ego_length)
  return ego_length_;
}
inline void VehicleParam::set_ego_length(double value) {
  set_has_ego_length();
  ego_length_ = value;
  // @@protoc_insertion_point(field_set:plan.VehicleParam.ego_length)
}

// optional double ego_width = 4 [default = 1];
inline bool VehicleParam::has_ego_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleParam::set_has_ego_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleParam::clear_has_ego_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleParam::clear_ego_width() {
  ego_width_ = 1;
  clear_has_ego_width();
}
inline double VehicleParam::ego_width() const {
  // @@protoc_insertion_point(field_get:plan.VehicleParam.ego_width)
  return ego_width_;
}
inline void VehicleParam::set_ego_width(double value) {
  set_has_ego_width();
  ego_width_ = value;
  // @@protoc_insertion_point(field_set:plan.VehicleParam.ego_width)
}

// optional double steer_ratio = 5 [default = 1];
inline bool VehicleParam::has_steer_ratio() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleParam::set_has_steer_ratio() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleParam::clear_has_steer_ratio() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleParam::clear_steer_ratio() {
  steer_ratio_ = 1;
  clear_has_steer_ratio();
}
inline double VehicleParam::steer_ratio() const {
  // @@protoc_insertion_point(field_get:plan.VehicleParam.steer_ratio)
  return steer_ratio_;
}
inline void VehicleParam::set_steer_ratio(double value) {
  set_has_steer_ratio();
  steer_ratio_ = value;
  // @@protoc_insertion_point(field_set:plan.VehicleParam.steer_ratio)
}

// optional double back_edge_to_center = 6 [default = 0.38];
inline bool VehicleParam::has_back_edge_to_center() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleParam::set_has_back_edge_to_center() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleParam::clear_has_back_edge_to_center() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleParam::clear_back_edge_to_center() {
  back_edge_to_center_ = 0.38;
  clear_has_back_edge_to_center();
}
inline double VehicleParam::back_edge_to_center() const {
  // @@protoc_insertion_point(field_get:plan.VehicleParam.back_edge_to_center)
  return back_edge_to_center_;
}
inline void VehicleParam::set_back_edge_to_center(double value) {
  set_has_back_edge_to_center();
  back_edge_to_center_ = value;
  // @@protoc_insertion_point(field_set:plan.VehicleParam.back_edge_to_center)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace plan

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_planner_2fopen_5fspace_2eproto__INCLUDED
