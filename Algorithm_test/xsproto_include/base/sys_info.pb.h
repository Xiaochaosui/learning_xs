// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base/sys_info.proto

#ifndef PROTOBUF_base_2fsys_5finfo_2eproto__INCLUDED
#define PROTOBUF_base_2fsys_5finfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_base_2fsys_5finfo_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHwEnginesInfoImpl();
void InitDefaultsHwEnginesInfo();
void InitDefaultsTempInfoImpl();
void InitDefaultsTempInfo();
void InitDefaultsHardwareInfoImpl();
void InitDefaultsHardwareInfo();
void InitDefaultsLibInfoImpl();
void InitDefaultsLibInfo();
void InitDefaultsBoardInfoImpl();
void InitDefaultsBoardInfo();
void InitDefaultsSysInfoImpl();
void InitDefaultsSysInfo();
inline void InitDefaults() {
  InitDefaultsHwEnginesInfo();
  InitDefaultsTempInfo();
  InitDefaultsHardwareInfo();
  InitDefaultsLibInfo();
  InitDefaultsBoardInfo();
  InitDefaultsSysInfo();
}
}  // namespace protobuf_base_2fsys_5finfo_2eproto
namespace xsproto {
namespace base {
class BoardInfo;
class BoardInfoDefaultTypeInternal;
extern BoardInfoDefaultTypeInternal _BoardInfo_default_instance_;
class HardwareInfo;
class HardwareInfoDefaultTypeInternal;
extern HardwareInfoDefaultTypeInternal _HardwareInfo_default_instance_;
class HwEnginesInfo;
class HwEnginesInfoDefaultTypeInternal;
extern HwEnginesInfoDefaultTypeInternal _HwEnginesInfo_default_instance_;
class LibInfo;
class LibInfoDefaultTypeInternal;
extern LibInfoDefaultTypeInternal _LibInfo_default_instance_;
class SysInfo;
class SysInfoDefaultTypeInternal;
extern SysInfoDefaultTypeInternal _SysInfo_default_instance_;
class TempInfo;
class TempInfoDefaultTypeInternal;
extern TempInfoDefaultTypeInternal _TempInfo_default_instance_;
}  // namespace base
}  // namespace xsproto
namespace xsproto {
namespace base {

// ===================================================================

class HwEnginesInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.base.HwEnginesInfo) */ {
 public:
  HwEnginesInfo();
  virtual ~HwEnginesInfo();

  HwEnginesInfo(const HwEnginesInfo& from);

  inline HwEnginesInfo& operator=(const HwEnginesInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HwEnginesInfo(HwEnginesInfo&& from) noexcept
    : HwEnginesInfo() {
    *this = ::std::move(from);
  }

  inline HwEnginesInfo& operator=(HwEnginesInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HwEnginesInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HwEnginesInfo* internal_default_instance() {
    return reinterpret_cast<const HwEnginesInfo*>(
               &_HwEnginesInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(HwEnginesInfo* other);
  friend void swap(HwEnginesInfo& a, HwEnginesInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HwEnginesInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  HwEnginesInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HwEnginesInfo& from);
  void MergeFrom(const HwEnginesInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HwEnginesInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ape = 1;
  void clear_ape();
  static const int kApeFieldNumber = 1;
  ::google::protobuf::uint32 ape() const;
  void set_ape(::google::protobuf::uint32 value);

  // bool nvenc = 2;
  void clear_nvenc();
  static const int kNvencFieldNumber = 2;
  bool nvenc() const;
  void set_nvenc(bool value);

  // bool nvdec = 3;
  void clear_nvdec();
  static const int kNvdecFieldNumber = 3;
  bool nvdec() const;
  void set_nvdec(bool value);

  // bool nvjpg = 4;
  void clear_nvjpg();
  static const int kNvjpgFieldNumber = 4;
  bool nvjpg() const;
  void set_nvjpg(bool value);

  // @@protoc_insertion_point(class_scope:xsproto.base.HwEnginesInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 ape_;
  bool nvenc_;
  bool nvdec_;
  bool nvjpg_;
  mutable int _cached_size_;
  friend struct ::protobuf_base_2fsys_5finfo_2eproto::TableStruct;
  friend void ::protobuf_base_2fsys_5finfo_2eproto::InitDefaultsHwEnginesInfoImpl();
};
// -------------------------------------------------------------------

class TempInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.base.TempInfo) */ {
 public:
  TempInfo();
  virtual ~TempInfo();

  TempInfo(const TempInfo& from);

  inline TempInfo& operator=(const TempInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TempInfo(TempInfo&& from) noexcept
    : TempInfo() {
    *this = ::std::move(from);
  }

  inline TempInfo& operator=(TempInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TempInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TempInfo* internal_default_instance() {
    return reinterpret_cast<const TempInfo*>(
               &_TempInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(TempInfo* other);
  friend void swap(TempInfo& a, TempInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TempInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  TempInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TempInfo& from);
  void MergeFrom(const TempInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TempInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float ao = 1;
  void clear_ao();
  static const int kAoFieldNumber = 1;
  float ao() const;
  void set_ao(float value);

  // float aux = 2;
  void clear_aux();
  static const int kAuxFieldNumber = 2;
  float aux() const;
  void set_aux(float value);

  // float cpu = 3;
  void clear_cpu();
  static const int kCpuFieldNumber = 3;
  float cpu() const;
  void set_cpu(float value);

  // float gpu = 4;
  void clear_gpu();
  static const int kGpuFieldNumber = 4;
  float gpu() const;
  void set_gpu(float value);

  // float tboard = 5;
  void clear_tboard();
  static const int kTboardFieldNumber = 5;
  float tboard() const;
  void set_tboard(float value);

  // float tdiode = 6;
  void clear_tdiode();
  static const int kTdiodeFieldNumber = 6;
  float tdiode() const;
  void set_tdiode(float value);

  // float thermal = 7;
  void clear_thermal();
  static const int kThermalFieldNumber = 7;
  float thermal() const;
  void set_thermal(float value);

  // @@protoc_insertion_point(class_scope:xsproto.base.TempInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float ao_;
  float aux_;
  float cpu_;
  float gpu_;
  float tboard_;
  float tdiode_;
  float thermal_;
  mutable int _cached_size_;
  friend struct ::protobuf_base_2fsys_5finfo_2eproto::TableStruct;
  friend void ::protobuf_base_2fsys_5finfo_2eproto::InitDefaultsTempInfoImpl();
};
// -------------------------------------------------------------------

class HardwareInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.base.HardwareInfo) */ {
 public:
  HardwareInfo();
  virtual ~HardwareInfo();

  HardwareInfo(const HardwareInfo& from);

  inline HardwareInfo& operator=(const HardwareInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HardwareInfo(HardwareInfo&& from) noexcept
    : HardwareInfo() {
    *this = ::std::move(from);
  }

  inline HardwareInfo& operator=(HardwareInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HardwareInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HardwareInfo* internal_default_instance() {
    return reinterpret_cast<const HardwareInfo*>(
               &_HardwareInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(HardwareInfo* other);
  friend void swap(HardwareInfo& a, HardwareInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HardwareInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  HardwareInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HardwareInfo& from);
  void MergeFrom(const HardwareInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HardwareInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string codename = 2;
  void clear_codename();
  static const int kCodenameFieldNumber = 2;
  const ::std::string& codename() const;
  void set_codename(const ::std::string& value);
  #if LANG_CXX11
  void set_codename(::std::string&& value);
  #endif
  void set_codename(const char* value);
  void set_codename(const char* value, size_t size);
  ::std::string* mutable_codename();
  ::std::string* release_codename();
  void set_allocated_codename(::std::string* codename);

  // string soc = 3;
  void clear_soc();
  static const int kSocFieldNumber = 3;
  const ::std::string& soc() const;
  void set_soc(const ::std::string& value);
  #if LANG_CXX11
  void set_soc(::std::string&& value);
  #endif
  void set_soc(const char* value);
  void set_soc(const char* value, size_t size);
  ::std::string* mutable_soc();
  ::std::string* release_soc();
  void set_allocated_soc(::std::string* soc);

  // string mode = 5;
  void clear_mode();
  static const int kModeFieldNumber = 5;
  const ::std::string& mode() const;
  void set_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_mode(::std::string&& value);
  #endif
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  ::std::string* mutable_mode();
  ::std::string* release_mode();
  void set_allocated_mode(::std::string* mode);

  // string board = 6;
  void clear_board();
  static const int kBoardFieldNumber = 6;
  const ::std::string& board() const;
  void set_board(const ::std::string& value);
  #if LANG_CXX11
  void set_board(::std::string&& value);
  #endif
  void set_board(const char* value);
  void set_board(const char* value, size_t size);
  ::std::string* mutable_board();
  ::std::string* release_board();
  void set_allocated_board(::std::string* board);

  // string cuda_arch_bin = 7;
  void clear_cuda_arch_bin();
  static const int kCudaArchBinFieldNumber = 7;
  const ::std::string& cuda_arch_bin() const;
  void set_cuda_arch_bin(const ::std::string& value);
  #if LANG_CXX11
  void set_cuda_arch_bin(::std::string&& value);
  #endif
  void set_cuda_arch_bin(const char* value);
  void set_cuda_arch_bin(const char* value, size_t size);
  ::std::string* mutable_cuda_arch_bin();
  ::std::string* release_cuda_arch_bin();
  void set_allocated_cuda_arch_bin(::std::string* cuda_arch_bin);

  // string serial_number = 8;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 8;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // uint32 chip_id = 4;
  void clear_chip_id();
  static const int kChipIdFieldNumber = 4;
  ::google::protobuf::uint32 chip_id() const;
  void set_chip_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xsproto.base.HardwareInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr codename_;
  ::google::protobuf::internal::ArenaStringPtr soc_;
  ::google::protobuf::internal::ArenaStringPtr mode_;
  ::google::protobuf::internal::ArenaStringPtr board_;
  ::google::protobuf::internal::ArenaStringPtr cuda_arch_bin_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::uint32 chip_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_base_2fsys_5finfo_2eproto::TableStruct;
  friend void ::protobuf_base_2fsys_5finfo_2eproto::InitDefaultsHardwareInfoImpl();
};
// -------------------------------------------------------------------

class LibInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.base.LibInfo) */ {
 public:
  LibInfo();
  virtual ~LibInfo();

  LibInfo(const LibInfo& from);

  inline LibInfo& operator=(const LibInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LibInfo(LibInfo&& from) noexcept
    : LibInfo() {
    *this = ::std::move(from);
  }

  inline LibInfo& operator=(LibInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LibInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LibInfo* internal_default_instance() {
    return reinterpret_cast<const LibInfo*>(
               &_LibInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(LibInfo* other);
  friend void swap(LibInfo& a, LibInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LibInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  LibInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LibInfo& from);
  void MergeFrom(const LibInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LibInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cuda = 1;
  void clear_cuda();
  static const int kCudaFieldNumber = 1;
  const ::std::string& cuda() const;
  void set_cuda(const ::std::string& value);
  #if LANG_CXX11
  void set_cuda(::std::string&& value);
  #endif
  void set_cuda(const char* value);
  void set_cuda(const char* value, size_t size);
  ::std::string* mutable_cuda();
  ::std::string* release_cuda();
  void set_allocated_cuda(::std::string* cuda);

  // string cudnn = 2;
  void clear_cudnn();
  static const int kCudnnFieldNumber = 2;
  const ::std::string& cudnn() const;
  void set_cudnn(const ::std::string& value);
  #if LANG_CXX11
  void set_cudnn(::std::string&& value);
  #endif
  void set_cudnn(const char* value);
  void set_cudnn(const char* value, size_t size);
  ::std::string* mutable_cudnn();
  ::std::string* release_cudnn();
  void set_allocated_cudnn(::std::string* cudnn);

  // string tensor_rt = 3;
  void clear_tensor_rt();
  static const int kTensorRtFieldNumber = 3;
  const ::std::string& tensor_rt() const;
  void set_tensor_rt(const ::std::string& value);
  #if LANG_CXX11
  void set_tensor_rt(::std::string&& value);
  #endif
  void set_tensor_rt(const char* value);
  void set_tensor_rt(const char* value, size_t size);
  ::std::string* mutable_tensor_rt();
  ::std::string* release_tensor_rt();
  void set_allocated_tensor_rt(::std::string* tensor_rt);

  // string vision_works = 4;
  void clear_vision_works();
  static const int kVisionWorksFieldNumber = 4;
  const ::std::string& vision_works() const;
  void set_vision_works(const ::std::string& value);
  #if LANG_CXX11
  void set_vision_works(::std::string&& value);
  #endif
  void set_vision_works(const char* value);
  void set_vision_works(const char* value, size_t size);
  ::std::string* mutable_vision_works();
  ::std::string* release_vision_works();
  void set_allocated_vision_works(::std::string* vision_works);

  // string opencv = 5;
  void clear_opencv();
  static const int kOpencvFieldNumber = 5;
  const ::std::string& opencv() const;
  void set_opencv(const ::std::string& value);
  #if LANG_CXX11
  void set_opencv(::std::string&& value);
  #endif
  void set_opencv(const char* value);
  void set_opencv(const char* value, size_t size);
  ::std::string* mutable_opencv();
  ::std::string* release_opencv();
  void set_allocated_opencv(::std::string* opencv);

  // string opencv_cuda = 6;
  void clear_opencv_cuda();
  static const int kOpencvCudaFieldNumber = 6;
  const ::std::string& opencv_cuda() const;
  void set_opencv_cuda(const ::std::string& value);
  #if LANG_CXX11
  void set_opencv_cuda(::std::string&& value);
  #endif
  void set_opencv_cuda(const char* value);
  void set_opencv_cuda(const char* value, size_t size);
  ::std::string* mutable_opencv_cuda();
  ::std::string* release_opencv_cuda();
  void set_allocated_opencv_cuda(::std::string* opencv_cuda);

  // string vpi = 7;
  void clear_vpi();
  static const int kVpiFieldNumber = 7;
  const ::std::string& vpi() const;
  void set_vpi(const ::std::string& value);
  #if LANG_CXX11
  void set_vpi(::std::string&& value);
  #endif
  void set_vpi(const char* value);
  void set_vpi(const char* value, size_t size);
  ::std::string* mutable_vpi();
  ::std::string* release_vpi();
  void set_allocated_vpi(::std::string* vpi);

  // string vulkan = 8;
  void clear_vulkan();
  static const int kVulkanFieldNumber = 8;
  const ::std::string& vulkan() const;
  void set_vulkan(const ::std::string& value);
  #if LANG_CXX11
  void set_vulkan(::std::string&& value);
  #endif
  void set_vulkan(const char* value);
  void set_vulkan(const char* value, size_t size);
  ::std::string* mutable_vulkan();
  ::std::string* release_vulkan();
  void set_allocated_vulkan(::std::string* vulkan);

  // @@protoc_insertion_point(class_scope:xsproto.base.LibInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cuda_;
  ::google::protobuf::internal::ArenaStringPtr cudnn_;
  ::google::protobuf::internal::ArenaStringPtr tensor_rt_;
  ::google::protobuf::internal::ArenaStringPtr vision_works_;
  ::google::protobuf::internal::ArenaStringPtr opencv_;
  ::google::protobuf::internal::ArenaStringPtr opencv_cuda_;
  ::google::protobuf::internal::ArenaStringPtr vpi_;
  ::google::protobuf::internal::ArenaStringPtr vulkan_;
  mutable int _cached_size_;
  friend struct ::protobuf_base_2fsys_5finfo_2eproto::TableStruct;
  friend void ::protobuf_base_2fsys_5finfo_2eproto::InitDefaultsLibInfoImpl();
};
// -------------------------------------------------------------------

class BoardInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.base.BoardInfo) */ {
 public:
  BoardInfo();
  virtual ~BoardInfo();

  BoardInfo(const BoardInfo& from);

  inline BoardInfo& operator=(const BoardInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoardInfo(BoardInfo&& from) noexcept
    : BoardInfo() {
    *this = ::std::move(from);
  }

  inline BoardInfo& operator=(BoardInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BoardInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoardInfo* internal_default_instance() {
    return reinterpret_cast<const BoardInfo*>(
               &_BoardInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(BoardInfo* other);
  friend void swap(BoardInfo& a, BoardInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoardInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  BoardInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BoardInfo& from);
  void MergeFrom(const BoardInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BoardInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string machine_name = 1;
  void clear_machine_name();
  static const int kMachineNameFieldNumber = 1;
  const ::std::string& machine_name() const;
  void set_machine_name(const ::std::string& value);
  #if LANG_CXX11
  void set_machine_name(::std::string&& value);
  #endif
  void set_machine_name(const char* value);
  void set_machine_name(const char* value, size_t size);
  ::std::string* mutable_machine_name();
  ::std::string* release_machine_name();
  void set_allocated_machine_name(::std::string* machine_name);

  // string jetpack_ver = 2;
  void clear_jetpack_ver();
  static const int kJetpackVerFieldNumber = 2;
  const ::std::string& jetpack_ver() const;
  void set_jetpack_ver(const ::std::string& value);
  #if LANG_CXX11
  void set_jetpack_ver(::std::string&& value);
  #endif
  void set_jetpack_ver(const char* value);
  void set_jetpack_ver(const char* value, size_t size);
  ::std::string* mutable_jetpack_ver();
  ::std::string* release_jetpack_ver();
  void set_allocated_jetpack_ver(::std::string* jetpack_ver);

  // string l4t_ver = 3;
  void clear_l4t_ver();
  static const int kL4TVerFieldNumber = 3;
  const ::std::string& l4t_ver() const;
  void set_l4t_ver(const ::std::string& value);
  #if LANG_CXX11
  void set_l4t_ver(::std::string&& value);
  #endif
  void set_l4t_ver(const char* value);
  void set_l4t_ver(const char* value, size_t size);
  ::std::string* mutable_l4t_ver();
  ::std::string* release_l4t_ver();
  void set_allocated_l4t_ver(::std::string* l4t_ver);

  // .xsproto.base.HardwareInfo hardware_info = 4;
  bool has_hardware_info() const;
  void clear_hardware_info();
  static const int kHardwareInfoFieldNumber = 4;
  const ::xsproto::base::HardwareInfo& hardware_info() const;
  ::xsproto::base::HardwareInfo* release_hardware_info();
  ::xsproto::base::HardwareInfo* mutable_hardware_info();
  void set_allocated_hardware_info(::xsproto::base::HardwareInfo* hardware_info);

  // .xsproto.base.LibInfo lib_info = 5;
  bool has_lib_info() const;
  void clear_lib_info();
  static const int kLibInfoFieldNumber = 5;
  const ::xsproto::base::LibInfo& lib_info() const;
  ::xsproto::base::LibInfo* release_lib_info();
  ::xsproto::base::LibInfo* mutable_lib_info();
  void set_allocated_lib_info(::xsproto::base::LibInfo* lib_info);

  // @@protoc_insertion_point(class_scope:xsproto.base.BoardInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr machine_name_;
  ::google::protobuf::internal::ArenaStringPtr jetpack_ver_;
  ::google::protobuf::internal::ArenaStringPtr l4t_ver_;
  ::xsproto::base::HardwareInfo* hardware_info_;
  ::xsproto::base::LibInfo* lib_info_;
  mutable int _cached_size_;
  friend struct ::protobuf_base_2fsys_5finfo_2eproto::TableStruct;
  friend void ::protobuf_base_2fsys_5finfo_2eproto::InitDefaultsBoardInfoImpl();
};
// -------------------------------------------------------------------

class SysInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.base.SysInfo) */ {
 public:
  SysInfo();
  virtual ~SysInfo();

  SysInfo(const SysInfo& from);

  inline SysInfo& operator=(const SysInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SysInfo(SysInfo&& from) noexcept
    : SysInfo() {
    *this = ::std::move(from);
  }

  inline SysInfo& operator=(SysInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SysInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SysInfo* internal_default_instance() {
    return reinterpret_cast<const SysInfo*>(
               &_SysInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SysInfo* other);
  friend void swap(SysInfo& a, SysInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SysInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SysInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SysInfo& from);
  void MergeFrom(const SysInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SysInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 cpu_useds = 5;
  int cpu_useds_size() const;
  void clear_cpu_useds();
  static const int kCpuUsedsFieldNumber = 5;
  ::google::protobuf::uint32 cpu_useds(int index) const;
  void set_cpu_useds(int index, ::google::protobuf::uint32 value);
  void add_cpu_useds(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      cpu_useds() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_cpu_useds();

  // string ip_addr = 1;
  void clear_ip_addr();
  static const int kIpAddrFieldNumber = 1;
  const ::std::string& ip_addr() const;
  void set_ip_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_ip_addr(::std::string&& value);
  #endif
  void set_ip_addr(const char* value);
  void set_ip_addr(const char* value, size_t size);
  ::std::string* mutable_ip_addr();
  ::std::string* release_ip_addr();
  void set_allocated_ip_addr(::std::string* ip_addr);

  // string nvp_model = 4;
  void clear_nvp_model();
  static const int kNvpModelFieldNumber = 4;
  const ::std::string& nvp_model() const;
  void set_nvp_model(const ::std::string& value);
  #if LANG_CXX11
  void set_nvp_model(::std::string&& value);
  #endif
  void set_nvp_model(const char* value);
  void set_nvp_model(const char* value, size_t size);
  ::std::string* mutable_nvp_model();
  ::std::string* release_nvp_model();
  void set_allocated_nvp_model(::std::string* nvp_model);

  // .xsproto.base.HwEnginesInfo hwengines_info = 14;
  bool has_hwengines_info() const;
  void clear_hwengines_info();
  static const int kHwenginesInfoFieldNumber = 14;
  const ::xsproto::base::HwEnginesInfo& hwengines_info() const;
  ::xsproto::base::HwEnginesInfo* release_hwengines_info();
  ::xsproto::base::HwEnginesInfo* mutable_hwengines_info();
  void set_allocated_hwengines_info(::xsproto::base::HwEnginesInfo* hwengines_info);

  // .xsproto.base.TempInfo temp_info = 16;
  bool has_temp_info() const;
  void clear_temp_info();
  static const int kTempInfoFieldNumber = 16;
  const ::xsproto::base::TempInfo& temp_info() const;
  ::xsproto::base::TempInfo* release_temp_info();
  ::xsproto::base::TempInfo* mutable_temp_info();
  void set_allocated_temp_info(::xsproto::base::TempInfo* temp_info);

  // .xsproto.base.BoardInfo board_info = 19;
  bool has_board_info() const;
  void clear_board_info();
  static const int kBoardInfoFieldNumber = 19;
  const ::xsproto::base::BoardInfo& board_info() const;
  ::xsproto::base::BoardInfo* release_board_info();
  ::xsproto::base::BoardInfo* mutable_board_info();
  void set_allocated_board_info(::xsproto::base::BoardInfo* board_info);

  // uint32 uptime = 2;
  void clear_uptime();
  static const int kUptimeFieldNumber = 2;
  ::google::protobuf::uint32 uptime() const;
  void set_uptime(::google::protobuf::uint32 value);

  // bool jetson_clocks = 3;
  void clear_jetson_clocks();
  static const int kJetsonClocksFieldNumber = 3;
  bool jetson_clocks() const;
  void set_jetson_clocks(bool value);

  // uint32 gpu_used = 6;
  void clear_gpu_used();
  static const int kGpuUsedFieldNumber = 6;
  ::google::protobuf::uint32 gpu_used() const;
  void set_gpu_used(::google::protobuf::uint32 value);

  // uint32 mts_fg = 7;
  void clear_mts_fg();
  static const int kMtsFgFieldNumber = 7;
  ::google::protobuf::uint32 mts_fg() const;
  void set_mts_fg(::google::protobuf::uint32 value);

  // uint32 mts_bg = 8;
  void clear_mts_bg();
  static const int kMtsBgFieldNumber = 8;
  ::google::protobuf::uint32 mts_bg() const;
  void set_mts_bg(::google::protobuf::uint32 value);

  // uint32 ram_alr_used = 9;
  void clear_ram_alr_used();
  static const int kRamAlrUsedFieldNumber = 9;
  ::google::protobuf::uint32 ram_alr_used() const;
  void set_ram_alr_used(::google::protobuf::uint32 value);

  // uint32 ram_total = 10;
  void clear_ram_total();
  static const int kRamTotalFieldNumber = 10;
  ::google::protobuf::uint32 ram_total() const;
  void set_ram_total(::google::protobuf::uint32 value);

  // uint32 ram_used = 11;
  void clear_ram_used();
  static const int kRamUsedFieldNumber = 11;
  ::google::protobuf::uint32 ram_used() const;
  void set_ram_used(::google::protobuf::uint32 value);

  // uint32 emc = 12;
  void clear_emc();
  static const int kEmcFieldNumber = 12;
  ::google::protobuf::uint32 emc() const;
  void set_emc(::google::protobuf::uint32 value);

  // uint32 swap = 13;
  void clear_swap();
  static const int kSwapFieldNumber = 13;
  ::google::protobuf::uint32 swap() const;
  void set_swap(::google::protobuf::uint32 value);

  // float fan = 15;
  void clear_fan();
  static const int kFanFieldNumber = 15;
  float fan() const;
  void set_fan(float value);

  // uint32 cur_power = 17;
  void clear_cur_power();
  static const int kCurPowerFieldNumber = 17;
  ::google::protobuf::uint32 cur_power() const;
  void set_cur_power(::google::protobuf::uint32 value);

  // uint32 avg_power = 18;
  void clear_avg_power();
  static const int kAvgPowerFieldNumber = 18;
  ::google::protobuf::uint32 avg_power() const;
  void set_avg_power(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xsproto.base.SysInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > cpu_useds_;
  mutable int _cpu_useds_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_addr_;
  ::google::protobuf::internal::ArenaStringPtr nvp_model_;
  ::xsproto::base::HwEnginesInfo* hwengines_info_;
  ::xsproto::base::TempInfo* temp_info_;
  ::xsproto::base::BoardInfo* board_info_;
  ::google::protobuf::uint32 uptime_;
  bool jetson_clocks_;
  ::google::protobuf::uint32 gpu_used_;
  ::google::protobuf::uint32 mts_fg_;
  ::google::protobuf::uint32 mts_bg_;
  ::google::protobuf::uint32 ram_alr_used_;
  ::google::protobuf::uint32 ram_total_;
  ::google::protobuf::uint32 ram_used_;
  ::google::protobuf::uint32 emc_;
  ::google::protobuf::uint32 swap_;
  float fan_;
  ::google::protobuf::uint32 cur_power_;
  ::google::protobuf::uint32 avg_power_;
  mutable int _cached_size_;
  friend struct ::protobuf_base_2fsys_5finfo_2eproto::TableStruct;
  friend void ::protobuf_base_2fsys_5finfo_2eproto::InitDefaultsSysInfoImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HwEnginesInfo

// uint32 ape = 1;
inline void HwEnginesInfo::clear_ape() {
  ape_ = 0u;
}
inline ::google::protobuf::uint32 HwEnginesInfo::ape() const {
  // @@protoc_insertion_point(field_get:xsproto.base.HwEnginesInfo.ape)
  return ape_;
}
inline void HwEnginesInfo::set_ape(::google::protobuf::uint32 value) {
  
  ape_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.HwEnginesInfo.ape)
}

// bool nvenc = 2;
inline void HwEnginesInfo::clear_nvenc() {
  nvenc_ = false;
}
inline bool HwEnginesInfo::nvenc() const {
  // @@protoc_insertion_point(field_get:xsproto.base.HwEnginesInfo.nvenc)
  return nvenc_;
}
inline void HwEnginesInfo::set_nvenc(bool value) {
  
  nvenc_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.HwEnginesInfo.nvenc)
}

// bool nvdec = 3;
inline void HwEnginesInfo::clear_nvdec() {
  nvdec_ = false;
}
inline bool HwEnginesInfo::nvdec() const {
  // @@protoc_insertion_point(field_get:xsproto.base.HwEnginesInfo.nvdec)
  return nvdec_;
}
inline void HwEnginesInfo::set_nvdec(bool value) {
  
  nvdec_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.HwEnginesInfo.nvdec)
}

// bool nvjpg = 4;
inline void HwEnginesInfo::clear_nvjpg() {
  nvjpg_ = false;
}
inline bool HwEnginesInfo::nvjpg() const {
  // @@protoc_insertion_point(field_get:xsproto.base.HwEnginesInfo.nvjpg)
  return nvjpg_;
}
inline void HwEnginesInfo::set_nvjpg(bool value) {
  
  nvjpg_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.HwEnginesInfo.nvjpg)
}

// -------------------------------------------------------------------

// TempInfo

// float ao = 1;
inline void TempInfo::clear_ao() {
  ao_ = 0;
}
inline float TempInfo::ao() const {
  // @@protoc_insertion_point(field_get:xsproto.base.TempInfo.ao)
  return ao_;
}
inline void TempInfo::set_ao(float value) {
  
  ao_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.TempInfo.ao)
}

// float aux = 2;
inline void TempInfo::clear_aux() {
  aux_ = 0;
}
inline float TempInfo::aux() const {
  // @@protoc_insertion_point(field_get:xsproto.base.TempInfo.aux)
  return aux_;
}
inline void TempInfo::set_aux(float value) {
  
  aux_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.TempInfo.aux)
}

// float cpu = 3;
inline void TempInfo::clear_cpu() {
  cpu_ = 0;
}
inline float TempInfo::cpu() const {
  // @@protoc_insertion_point(field_get:xsproto.base.TempInfo.cpu)
  return cpu_;
}
inline void TempInfo::set_cpu(float value) {
  
  cpu_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.TempInfo.cpu)
}

// float gpu = 4;
inline void TempInfo::clear_gpu() {
  gpu_ = 0;
}
inline float TempInfo::gpu() const {
  // @@protoc_insertion_point(field_get:xsproto.base.TempInfo.gpu)
  return gpu_;
}
inline void TempInfo::set_gpu(float value) {
  
  gpu_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.TempInfo.gpu)
}

// float tboard = 5;
inline void TempInfo::clear_tboard() {
  tboard_ = 0;
}
inline float TempInfo::tboard() const {
  // @@protoc_insertion_point(field_get:xsproto.base.TempInfo.tboard)
  return tboard_;
}
inline void TempInfo::set_tboard(float value) {
  
  tboard_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.TempInfo.tboard)
}

// float tdiode = 6;
inline void TempInfo::clear_tdiode() {
  tdiode_ = 0;
}
inline float TempInfo::tdiode() const {
  // @@protoc_insertion_point(field_get:xsproto.base.TempInfo.tdiode)
  return tdiode_;
}
inline void TempInfo::set_tdiode(float value) {
  
  tdiode_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.TempInfo.tdiode)
}

// float thermal = 7;
inline void TempInfo::clear_thermal() {
  thermal_ = 0;
}
inline float TempInfo::thermal() const {
  // @@protoc_insertion_point(field_get:xsproto.base.TempInfo.thermal)
  return thermal_;
}
inline void TempInfo::set_thermal(float value) {
  
  thermal_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.TempInfo.thermal)
}

// -------------------------------------------------------------------

// HardwareInfo

// string type = 1;
inline void HardwareInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HardwareInfo::type() const {
  // @@protoc_insertion_point(field_get:xsproto.base.HardwareInfo.type)
  return type_.GetNoArena();
}
inline void HardwareInfo::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.HardwareInfo.type)
}
#if LANG_CXX11
inline void HardwareInfo::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.HardwareInfo.type)
}
#endif
inline void HardwareInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.HardwareInfo.type)
}
inline void HardwareInfo::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.HardwareInfo.type)
}
inline ::std::string* HardwareInfo::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.HardwareInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HardwareInfo::release_type() {
  // @@protoc_insertion_point(field_release:xsproto.base.HardwareInfo.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HardwareInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.HardwareInfo.type)
}

// string codename = 2;
inline void HardwareInfo::clear_codename() {
  codename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HardwareInfo::codename() const {
  // @@protoc_insertion_point(field_get:xsproto.base.HardwareInfo.codename)
  return codename_.GetNoArena();
}
inline void HardwareInfo::set_codename(const ::std::string& value) {
  
  codename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.HardwareInfo.codename)
}
#if LANG_CXX11
inline void HardwareInfo::set_codename(::std::string&& value) {
  
  codename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.HardwareInfo.codename)
}
#endif
inline void HardwareInfo::set_codename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  codename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.HardwareInfo.codename)
}
inline void HardwareInfo::set_codename(const char* value, size_t size) {
  
  codename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.HardwareInfo.codename)
}
inline ::std::string* HardwareInfo::mutable_codename() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.HardwareInfo.codename)
  return codename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HardwareInfo::release_codename() {
  // @@protoc_insertion_point(field_release:xsproto.base.HardwareInfo.codename)
  
  return codename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HardwareInfo::set_allocated_codename(::std::string* codename) {
  if (codename != NULL) {
    
  } else {
    
  }
  codename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codename);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.HardwareInfo.codename)
}

// string soc = 3;
inline void HardwareInfo::clear_soc() {
  soc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HardwareInfo::soc() const {
  // @@protoc_insertion_point(field_get:xsproto.base.HardwareInfo.soc)
  return soc_.GetNoArena();
}
inline void HardwareInfo::set_soc(const ::std::string& value) {
  
  soc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.HardwareInfo.soc)
}
#if LANG_CXX11
inline void HardwareInfo::set_soc(::std::string&& value) {
  
  soc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.HardwareInfo.soc)
}
#endif
inline void HardwareInfo::set_soc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  soc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.HardwareInfo.soc)
}
inline void HardwareInfo::set_soc(const char* value, size_t size) {
  
  soc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.HardwareInfo.soc)
}
inline ::std::string* HardwareInfo::mutable_soc() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.HardwareInfo.soc)
  return soc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HardwareInfo::release_soc() {
  // @@protoc_insertion_point(field_release:xsproto.base.HardwareInfo.soc)
  
  return soc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HardwareInfo::set_allocated_soc(::std::string* soc) {
  if (soc != NULL) {
    
  } else {
    
  }
  soc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), soc);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.HardwareInfo.soc)
}

// uint32 chip_id = 4;
inline void HardwareInfo::clear_chip_id() {
  chip_id_ = 0u;
}
inline ::google::protobuf::uint32 HardwareInfo::chip_id() const {
  // @@protoc_insertion_point(field_get:xsproto.base.HardwareInfo.chip_id)
  return chip_id_;
}
inline void HardwareInfo::set_chip_id(::google::protobuf::uint32 value) {
  
  chip_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.HardwareInfo.chip_id)
}

// string mode = 5;
inline void HardwareInfo::clear_mode() {
  mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HardwareInfo::mode() const {
  // @@protoc_insertion_point(field_get:xsproto.base.HardwareInfo.mode)
  return mode_.GetNoArena();
}
inline void HardwareInfo::set_mode(const ::std::string& value) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.HardwareInfo.mode)
}
#if LANG_CXX11
inline void HardwareInfo::set_mode(::std::string&& value) {
  
  mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.HardwareInfo.mode)
}
#endif
inline void HardwareInfo::set_mode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.HardwareInfo.mode)
}
inline void HardwareInfo::set_mode(const char* value, size_t size) {
  
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.HardwareInfo.mode)
}
inline ::std::string* HardwareInfo::mutable_mode() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.HardwareInfo.mode)
  return mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HardwareInfo::release_mode() {
  // @@protoc_insertion_point(field_release:xsproto.base.HardwareInfo.mode)
  
  return mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HardwareInfo::set_allocated_mode(::std::string* mode) {
  if (mode != NULL) {
    
  } else {
    
  }
  mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.HardwareInfo.mode)
}

// string board = 6;
inline void HardwareInfo::clear_board() {
  board_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HardwareInfo::board() const {
  // @@protoc_insertion_point(field_get:xsproto.base.HardwareInfo.board)
  return board_.GetNoArena();
}
inline void HardwareInfo::set_board(const ::std::string& value) {
  
  board_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.HardwareInfo.board)
}
#if LANG_CXX11
inline void HardwareInfo::set_board(::std::string&& value) {
  
  board_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.HardwareInfo.board)
}
#endif
inline void HardwareInfo::set_board(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  board_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.HardwareInfo.board)
}
inline void HardwareInfo::set_board(const char* value, size_t size) {
  
  board_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.HardwareInfo.board)
}
inline ::std::string* HardwareInfo::mutable_board() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.HardwareInfo.board)
  return board_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HardwareInfo::release_board() {
  // @@protoc_insertion_point(field_release:xsproto.base.HardwareInfo.board)
  
  return board_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HardwareInfo::set_allocated_board(::std::string* board) {
  if (board != NULL) {
    
  } else {
    
  }
  board_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), board);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.HardwareInfo.board)
}

// string cuda_arch_bin = 7;
inline void HardwareInfo::clear_cuda_arch_bin() {
  cuda_arch_bin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HardwareInfo::cuda_arch_bin() const {
  // @@protoc_insertion_point(field_get:xsproto.base.HardwareInfo.cuda_arch_bin)
  return cuda_arch_bin_.GetNoArena();
}
inline void HardwareInfo::set_cuda_arch_bin(const ::std::string& value) {
  
  cuda_arch_bin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.HardwareInfo.cuda_arch_bin)
}
#if LANG_CXX11
inline void HardwareInfo::set_cuda_arch_bin(::std::string&& value) {
  
  cuda_arch_bin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.HardwareInfo.cuda_arch_bin)
}
#endif
inline void HardwareInfo::set_cuda_arch_bin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cuda_arch_bin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.HardwareInfo.cuda_arch_bin)
}
inline void HardwareInfo::set_cuda_arch_bin(const char* value, size_t size) {
  
  cuda_arch_bin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.HardwareInfo.cuda_arch_bin)
}
inline ::std::string* HardwareInfo::mutable_cuda_arch_bin() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.HardwareInfo.cuda_arch_bin)
  return cuda_arch_bin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HardwareInfo::release_cuda_arch_bin() {
  // @@protoc_insertion_point(field_release:xsproto.base.HardwareInfo.cuda_arch_bin)
  
  return cuda_arch_bin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HardwareInfo::set_allocated_cuda_arch_bin(::std::string* cuda_arch_bin) {
  if (cuda_arch_bin != NULL) {
    
  } else {
    
  }
  cuda_arch_bin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cuda_arch_bin);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.HardwareInfo.cuda_arch_bin)
}

// string serial_number = 8;
inline void HardwareInfo::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HardwareInfo::serial_number() const {
  // @@protoc_insertion_point(field_get:xsproto.base.HardwareInfo.serial_number)
  return serial_number_.GetNoArena();
}
inline void HardwareInfo::set_serial_number(const ::std::string& value) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.HardwareInfo.serial_number)
}
#if LANG_CXX11
inline void HardwareInfo::set_serial_number(::std::string&& value) {
  
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.HardwareInfo.serial_number)
}
#endif
inline void HardwareInfo::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.HardwareInfo.serial_number)
}
inline void HardwareInfo::set_serial_number(const char* value, size_t size) {
  
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.HardwareInfo.serial_number)
}
inline ::std::string* HardwareInfo::mutable_serial_number() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.HardwareInfo.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HardwareInfo::release_serial_number() {
  // @@protoc_insertion_point(field_release:xsproto.base.HardwareInfo.serial_number)
  
  return serial_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HardwareInfo::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    
  } else {
    
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.HardwareInfo.serial_number)
}

// -------------------------------------------------------------------

// LibInfo

// string cuda = 1;
inline void LibInfo::clear_cuda() {
  cuda_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LibInfo::cuda() const {
  // @@protoc_insertion_point(field_get:xsproto.base.LibInfo.cuda)
  return cuda_.GetNoArena();
}
inline void LibInfo::set_cuda(const ::std::string& value) {
  
  cuda_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.LibInfo.cuda)
}
#if LANG_CXX11
inline void LibInfo::set_cuda(::std::string&& value) {
  
  cuda_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.LibInfo.cuda)
}
#endif
inline void LibInfo::set_cuda(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cuda_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.LibInfo.cuda)
}
inline void LibInfo::set_cuda(const char* value, size_t size) {
  
  cuda_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.LibInfo.cuda)
}
inline ::std::string* LibInfo::mutable_cuda() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.LibInfo.cuda)
  return cuda_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LibInfo::release_cuda() {
  // @@protoc_insertion_point(field_release:xsproto.base.LibInfo.cuda)
  
  return cuda_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LibInfo::set_allocated_cuda(::std::string* cuda) {
  if (cuda != NULL) {
    
  } else {
    
  }
  cuda_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cuda);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.LibInfo.cuda)
}

// string cudnn = 2;
inline void LibInfo::clear_cudnn() {
  cudnn_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LibInfo::cudnn() const {
  // @@protoc_insertion_point(field_get:xsproto.base.LibInfo.cudnn)
  return cudnn_.GetNoArena();
}
inline void LibInfo::set_cudnn(const ::std::string& value) {
  
  cudnn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.LibInfo.cudnn)
}
#if LANG_CXX11
inline void LibInfo::set_cudnn(::std::string&& value) {
  
  cudnn_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.LibInfo.cudnn)
}
#endif
inline void LibInfo::set_cudnn(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cudnn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.LibInfo.cudnn)
}
inline void LibInfo::set_cudnn(const char* value, size_t size) {
  
  cudnn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.LibInfo.cudnn)
}
inline ::std::string* LibInfo::mutable_cudnn() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.LibInfo.cudnn)
  return cudnn_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LibInfo::release_cudnn() {
  // @@protoc_insertion_point(field_release:xsproto.base.LibInfo.cudnn)
  
  return cudnn_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LibInfo::set_allocated_cudnn(::std::string* cudnn) {
  if (cudnn != NULL) {
    
  } else {
    
  }
  cudnn_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cudnn);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.LibInfo.cudnn)
}

// string tensor_rt = 3;
inline void LibInfo::clear_tensor_rt() {
  tensor_rt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LibInfo::tensor_rt() const {
  // @@protoc_insertion_point(field_get:xsproto.base.LibInfo.tensor_rt)
  return tensor_rt_.GetNoArena();
}
inline void LibInfo::set_tensor_rt(const ::std::string& value) {
  
  tensor_rt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.LibInfo.tensor_rt)
}
#if LANG_CXX11
inline void LibInfo::set_tensor_rt(::std::string&& value) {
  
  tensor_rt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.LibInfo.tensor_rt)
}
#endif
inline void LibInfo::set_tensor_rt(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tensor_rt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.LibInfo.tensor_rt)
}
inline void LibInfo::set_tensor_rt(const char* value, size_t size) {
  
  tensor_rt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.LibInfo.tensor_rt)
}
inline ::std::string* LibInfo::mutable_tensor_rt() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.LibInfo.tensor_rt)
  return tensor_rt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LibInfo::release_tensor_rt() {
  // @@protoc_insertion_point(field_release:xsproto.base.LibInfo.tensor_rt)
  
  return tensor_rt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LibInfo::set_allocated_tensor_rt(::std::string* tensor_rt) {
  if (tensor_rt != NULL) {
    
  } else {
    
  }
  tensor_rt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tensor_rt);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.LibInfo.tensor_rt)
}

// string vision_works = 4;
inline void LibInfo::clear_vision_works() {
  vision_works_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LibInfo::vision_works() const {
  // @@protoc_insertion_point(field_get:xsproto.base.LibInfo.vision_works)
  return vision_works_.GetNoArena();
}
inline void LibInfo::set_vision_works(const ::std::string& value) {
  
  vision_works_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.LibInfo.vision_works)
}
#if LANG_CXX11
inline void LibInfo::set_vision_works(::std::string&& value) {
  
  vision_works_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.LibInfo.vision_works)
}
#endif
inline void LibInfo::set_vision_works(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vision_works_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.LibInfo.vision_works)
}
inline void LibInfo::set_vision_works(const char* value, size_t size) {
  
  vision_works_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.LibInfo.vision_works)
}
inline ::std::string* LibInfo::mutable_vision_works() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.LibInfo.vision_works)
  return vision_works_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LibInfo::release_vision_works() {
  // @@protoc_insertion_point(field_release:xsproto.base.LibInfo.vision_works)
  
  return vision_works_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LibInfo::set_allocated_vision_works(::std::string* vision_works) {
  if (vision_works != NULL) {
    
  } else {
    
  }
  vision_works_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vision_works);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.LibInfo.vision_works)
}

// string opencv = 5;
inline void LibInfo::clear_opencv() {
  opencv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LibInfo::opencv() const {
  // @@protoc_insertion_point(field_get:xsproto.base.LibInfo.opencv)
  return opencv_.GetNoArena();
}
inline void LibInfo::set_opencv(const ::std::string& value) {
  
  opencv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.LibInfo.opencv)
}
#if LANG_CXX11
inline void LibInfo::set_opencv(::std::string&& value) {
  
  opencv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.LibInfo.opencv)
}
#endif
inline void LibInfo::set_opencv(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  opencv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.LibInfo.opencv)
}
inline void LibInfo::set_opencv(const char* value, size_t size) {
  
  opencv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.LibInfo.opencv)
}
inline ::std::string* LibInfo::mutable_opencv() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.LibInfo.opencv)
  return opencv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LibInfo::release_opencv() {
  // @@protoc_insertion_point(field_release:xsproto.base.LibInfo.opencv)
  
  return opencv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LibInfo::set_allocated_opencv(::std::string* opencv) {
  if (opencv != NULL) {
    
  } else {
    
  }
  opencv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), opencv);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.LibInfo.opencv)
}

// string opencv_cuda = 6;
inline void LibInfo::clear_opencv_cuda() {
  opencv_cuda_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LibInfo::opencv_cuda() const {
  // @@protoc_insertion_point(field_get:xsproto.base.LibInfo.opencv_cuda)
  return opencv_cuda_.GetNoArena();
}
inline void LibInfo::set_opencv_cuda(const ::std::string& value) {
  
  opencv_cuda_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.LibInfo.opencv_cuda)
}
#if LANG_CXX11
inline void LibInfo::set_opencv_cuda(::std::string&& value) {
  
  opencv_cuda_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.LibInfo.opencv_cuda)
}
#endif
inline void LibInfo::set_opencv_cuda(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  opencv_cuda_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.LibInfo.opencv_cuda)
}
inline void LibInfo::set_opencv_cuda(const char* value, size_t size) {
  
  opencv_cuda_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.LibInfo.opencv_cuda)
}
inline ::std::string* LibInfo::mutable_opencv_cuda() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.LibInfo.opencv_cuda)
  return opencv_cuda_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LibInfo::release_opencv_cuda() {
  // @@protoc_insertion_point(field_release:xsproto.base.LibInfo.opencv_cuda)
  
  return opencv_cuda_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LibInfo::set_allocated_opencv_cuda(::std::string* opencv_cuda) {
  if (opencv_cuda != NULL) {
    
  } else {
    
  }
  opencv_cuda_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), opencv_cuda);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.LibInfo.opencv_cuda)
}

// string vpi = 7;
inline void LibInfo::clear_vpi() {
  vpi_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LibInfo::vpi() const {
  // @@protoc_insertion_point(field_get:xsproto.base.LibInfo.vpi)
  return vpi_.GetNoArena();
}
inline void LibInfo::set_vpi(const ::std::string& value) {
  
  vpi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.LibInfo.vpi)
}
#if LANG_CXX11
inline void LibInfo::set_vpi(::std::string&& value) {
  
  vpi_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.LibInfo.vpi)
}
#endif
inline void LibInfo::set_vpi(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vpi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.LibInfo.vpi)
}
inline void LibInfo::set_vpi(const char* value, size_t size) {
  
  vpi_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.LibInfo.vpi)
}
inline ::std::string* LibInfo::mutable_vpi() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.LibInfo.vpi)
  return vpi_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LibInfo::release_vpi() {
  // @@protoc_insertion_point(field_release:xsproto.base.LibInfo.vpi)
  
  return vpi_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LibInfo::set_allocated_vpi(::std::string* vpi) {
  if (vpi != NULL) {
    
  } else {
    
  }
  vpi_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vpi);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.LibInfo.vpi)
}

// string vulkan = 8;
inline void LibInfo::clear_vulkan() {
  vulkan_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LibInfo::vulkan() const {
  // @@protoc_insertion_point(field_get:xsproto.base.LibInfo.vulkan)
  return vulkan_.GetNoArena();
}
inline void LibInfo::set_vulkan(const ::std::string& value) {
  
  vulkan_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.LibInfo.vulkan)
}
#if LANG_CXX11
inline void LibInfo::set_vulkan(::std::string&& value) {
  
  vulkan_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.LibInfo.vulkan)
}
#endif
inline void LibInfo::set_vulkan(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vulkan_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.LibInfo.vulkan)
}
inline void LibInfo::set_vulkan(const char* value, size_t size) {
  
  vulkan_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.LibInfo.vulkan)
}
inline ::std::string* LibInfo::mutable_vulkan() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.LibInfo.vulkan)
  return vulkan_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LibInfo::release_vulkan() {
  // @@protoc_insertion_point(field_release:xsproto.base.LibInfo.vulkan)
  
  return vulkan_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LibInfo::set_allocated_vulkan(::std::string* vulkan) {
  if (vulkan != NULL) {
    
  } else {
    
  }
  vulkan_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vulkan);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.LibInfo.vulkan)
}

// -------------------------------------------------------------------

// BoardInfo

// string machine_name = 1;
inline void BoardInfo::clear_machine_name() {
  machine_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BoardInfo::machine_name() const {
  // @@protoc_insertion_point(field_get:xsproto.base.BoardInfo.machine_name)
  return machine_name_.GetNoArena();
}
inline void BoardInfo::set_machine_name(const ::std::string& value) {
  
  machine_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.BoardInfo.machine_name)
}
#if LANG_CXX11
inline void BoardInfo::set_machine_name(::std::string&& value) {
  
  machine_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.BoardInfo.machine_name)
}
#endif
inline void BoardInfo::set_machine_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  machine_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.BoardInfo.machine_name)
}
inline void BoardInfo::set_machine_name(const char* value, size_t size) {
  
  machine_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.BoardInfo.machine_name)
}
inline ::std::string* BoardInfo::mutable_machine_name() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.BoardInfo.machine_name)
  return machine_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BoardInfo::release_machine_name() {
  // @@protoc_insertion_point(field_release:xsproto.base.BoardInfo.machine_name)
  
  return machine_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BoardInfo::set_allocated_machine_name(::std::string* machine_name) {
  if (machine_name != NULL) {
    
  } else {
    
  }
  machine_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine_name);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.BoardInfo.machine_name)
}

// string jetpack_ver = 2;
inline void BoardInfo::clear_jetpack_ver() {
  jetpack_ver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BoardInfo::jetpack_ver() const {
  // @@protoc_insertion_point(field_get:xsproto.base.BoardInfo.jetpack_ver)
  return jetpack_ver_.GetNoArena();
}
inline void BoardInfo::set_jetpack_ver(const ::std::string& value) {
  
  jetpack_ver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.BoardInfo.jetpack_ver)
}
#if LANG_CXX11
inline void BoardInfo::set_jetpack_ver(::std::string&& value) {
  
  jetpack_ver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.BoardInfo.jetpack_ver)
}
#endif
inline void BoardInfo::set_jetpack_ver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  jetpack_ver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.BoardInfo.jetpack_ver)
}
inline void BoardInfo::set_jetpack_ver(const char* value, size_t size) {
  
  jetpack_ver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.BoardInfo.jetpack_ver)
}
inline ::std::string* BoardInfo::mutable_jetpack_ver() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.BoardInfo.jetpack_ver)
  return jetpack_ver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BoardInfo::release_jetpack_ver() {
  // @@protoc_insertion_point(field_release:xsproto.base.BoardInfo.jetpack_ver)
  
  return jetpack_ver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BoardInfo::set_allocated_jetpack_ver(::std::string* jetpack_ver) {
  if (jetpack_ver != NULL) {
    
  } else {
    
  }
  jetpack_ver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jetpack_ver);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.BoardInfo.jetpack_ver)
}

// string l4t_ver = 3;
inline void BoardInfo::clear_l4t_ver() {
  l4t_ver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BoardInfo::l4t_ver() const {
  // @@protoc_insertion_point(field_get:xsproto.base.BoardInfo.l4t_ver)
  return l4t_ver_.GetNoArena();
}
inline void BoardInfo::set_l4t_ver(const ::std::string& value) {
  
  l4t_ver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.BoardInfo.l4t_ver)
}
#if LANG_CXX11
inline void BoardInfo::set_l4t_ver(::std::string&& value) {
  
  l4t_ver_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.BoardInfo.l4t_ver)
}
#endif
inline void BoardInfo::set_l4t_ver(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  l4t_ver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.BoardInfo.l4t_ver)
}
inline void BoardInfo::set_l4t_ver(const char* value, size_t size) {
  
  l4t_ver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.BoardInfo.l4t_ver)
}
inline ::std::string* BoardInfo::mutable_l4t_ver() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.BoardInfo.l4t_ver)
  return l4t_ver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BoardInfo::release_l4t_ver() {
  // @@protoc_insertion_point(field_release:xsproto.base.BoardInfo.l4t_ver)
  
  return l4t_ver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BoardInfo::set_allocated_l4t_ver(::std::string* l4t_ver) {
  if (l4t_ver != NULL) {
    
  } else {
    
  }
  l4t_ver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), l4t_ver);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.BoardInfo.l4t_ver)
}

// .xsproto.base.HardwareInfo hardware_info = 4;
inline bool BoardInfo::has_hardware_info() const {
  return this != internal_default_instance() && hardware_info_ != NULL;
}
inline void BoardInfo::clear_hardware_info() {
  if (GetArenaNoVirtual() == NULL && hardware_info_ != NULL) {
    delete hardware_info_;
  }
  hardware_info_ = NULL;
}
inline const ::xsproto::base::HardwareInfo& BoardInfo::hardware_info() const {
  const ::xsproto::base::HardwareInfo* p = hardware_info_;
  // @@protoc_insertion_point(field_get:xsproto.base.BoardInfo.hardware_info)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::base::HardwareInfo*>(
      &::xsproto::base::_HardwareInfo_default_instance_);
}
inline ::xsproto::base::HardwareInfo* BoardInfo::release_hardware_info() {
  // @@protoc_insertion_point(field_release:xsproto.base.BoardInfo.hardware_info)
  
  ::xsproto::base::HardwareInfo* temp = hardware_info_;
  hardware_info_ = NULL;
  return temp;
}
inline ::xsproto::base::HardwareInfo* BoardInfo::mutable_hardware_info() {
  
  if (hardware_info_ == NULL) {
    hardware_info_ = new ::xsproto::base::HardwareInfo;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.base.BoardInfo.hardware_info)
  return hardware_info_;
}
inline void BoardInfo::set_allocated_hardware_info(::xsproto::base::HardwareInfo* hardware_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hardware_info_;
  }
  if (hardware_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hardware_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hardware_info, submessage_arena);
    }
    
  } else {
    
  }
  hardware_info_ = hardware_info;
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.BoardInfo.hardware_info)
}

// .xsproto.base.LibInfo lib_info = 5;
inline bool BoardInfo::has_lib_info() const {
  return this != internal_default_instance() && lib_info_ != NULL;
}
inline void BoardInfo::clear_lib_info() {
  if (GetArenaNoVirtual() == NULL && lib_info_ != NULL) {
    delete lib_info_;
  }
  lib_info_ = NULL;
}
inline const ::xsproto::base::LibInfo& BoardInfo::lib_info() const {
  const ::xsproto::base::LibInfo* p = lib_info_;
  // @@protoc_insertion_point(field_get:xsproto.base.BoardInfo.lib_info)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::base::LibInfo*>(
      &::xsproto::base::_LibInfo_default_instance_);
}
inline ::xsproto::base::LibInfo* BoardInfo::release_lib_info() {
  // @@protoc_insertion_point(field_release:xsproto.base.BoardInfo.lib_info)
  
  ::xsproto::base::LibInfo* temp = lib_info_;
  lib_info_ = NULL;
  return temp;
}
inline ::xsproto::base::LibInfo* BoardInfo::mutable_lib_info() {
  
  if (lib_info_ == NULL) {
    lib_info_ = new ::xsproto::base::LibInfo;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.base.BoardInfo.lib_info)
  return lib_info_;
}
inline void BoardInfo::set_allocated_lib_info(::xsproto::base::LibInfo* lib_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lib_info_;
  }
  if (lib_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lib_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lib_info, submessage_arena);
    }
    
  } else {
    
  }
  lib_info_ = lib_info;
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.BoardInfo.lib_info)
}

// -------------------------------------------------------------------

// SysInfo

// string ip_addr = 1;
inline void SysInfo::clear_ip_addr() {
  ip_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SysInfo::ip_addr() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.ip_addr)
  return ip_addr_.GetNoArena();
}
inline void SysInfo::set_ip_addr(const ::std::string& value) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.ip_addr)
}
#if LANG_CXX11
inline void SysInfo::set_ip_addr(::std::string&& value) {
  
  ip_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.SysInfo.ip_addr)
}
#endif
inline void SysInfo::set_ip_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.SysInfo.ip_addr)
}
inline void SysInfo::set_ip_addr(const char* value, size_t size) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.SysInfo.ip_addr)
}
inline ::std::string* SysInfo::mutable_ip_addr() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.SysInfo.ip_addr)
  return ip_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SysInfo::release_ip_addr() {
  // @@protoc_insertion_point(field_release:xsproto.base.SysInfo.ip_addr)
  
  return ip_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SysInfo::set_allocated_ip_addr(::std::string* ip_addr) {
  if (ip_addr != NULL) {
    
  } else {
    
  }
  ip_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_addr);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.SysInfo.ip_addr)
}

// uint32 uptime = 2;
inline void SysInfo::clear_uptime() {
  uptime_ = 0u;
}
inline ::google::protobuf::uint32 SysInfo::uptime() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.uptime)
  return uptime_;
}
inline void SysInfo::set_uptime(::google::protobuf::uint32 value) {
  
  uptime_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.uptime)
}

// bool jetson_clocks = 3;
inline void SysInfo::clear_jetson_clocks() {
  jetson_clocks_ = false;
}
inline bool SysInfo::jetson_clocks() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.jetson_clocks)
  return jetson_clocks_;
}
inline void SysInfo::set_jetson_clocks(bool value) {
  
  jetson_clocks_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.jetson_clocks)
}

// string nvp_model = 4;
inline void SysInfo::clear_nvp_model() {
  nvp_model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SysInfo::nvp_model() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.nvp_model)
  return nvp_model_.GetNoArena();
}
inline void SysInfo::set_nvp_model(const ::std::string& value) {
  
  nvp_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.nvp_model)
}
#if LANG_CXX11
inline void SysInfo::set_nvp_model(::std::string&& value) {
  
  nvp_model_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.base.SysInfo.nvp_model)
}
#endif
inline void SysInfo::set_nvp_model(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nvp_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.base.SysInfo.nvp_model)
}
inline void SysInfo::set_nvp_model(const char* value, size_t size) {
  
  nvp_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.base.SysInfo.nvp_model)
}
inline ::std::string* SysInfo::mutable_nvp_model() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.base.SysInfo.nvp_model)
  return nvp_model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SysInfo::release_nvp_model() {
  // @@protoc_insertion_point(field_release:xsproto.base.SysInfo.nvp_model)
  
  return nvp_model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SysInfo::set_allocated_nvp_model(::std::string* nvp_model) {
  if (nvp_model != NULL) {
    
  } else {
    
  }
  nvp_model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nvp_model);
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.SysInfo.nvp_model)
}

// repeated uint32 cpu_useds = 5;
inline int SysInfo::cpu_useds_size() const {
  return cpu_useds_.size();
}
inline void SysInfo::clear_cpu_useds() {
  cpu_useds_.Clear();
}
inline ::google::protobuf::uint32 SysInfo::cpu_useds(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.cpu_useds)
  return cpu_useds_.Get(index);
}
inline void SysInfo::set_cpu_useds(int index, ::google::protobuf::uint32 value) {
  cpu_useds_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.cpu_useds)
}
inline void SysInfo::add_cpu_useds(::google::protobuf::uint32 value) {
  cpu_useds_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.base.SysInfo.cpu_useds)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SysInfo::cpu_useds() const {
  // @@protoc_insertion_point(field_list:xsproto.base.SysInfo.cpu_useds)
  return cpu_useds_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SysInfo::mutable_cpu_useds() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.base.SysInfo.cpu_useds)
  return &cpu_useds_;
}

// uint32 gpu_used = 6;
inline void SysInfo::clear_gpu_used() {
  gpu_used_ = 0u;
}
inline ::google::protobuf::uint32 SysInfo::gpu_used() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.gpu_used)
  return gpu_used_;
}
inline void SysInfo::set_gpu_used(::google::protobuf::uint32 value) {
  
  gpu_used_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.gpu_used)
}

// uint32 mts_fg = 7;
inline void SysInfo::clear_mts_fg() {
  mts_fg_ = 0u;
}
inline ::google::protobuf::uint32 SysInfo::mts_fg() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.mts_fg)
  return mts_fg_;
}
inline void SysInfo::set_mts_fg(::google::protobuf::uint32 value) {
  
  mts_fg_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.mts_fg)
}

// uint32 mts_bg = 8;
inline void SysInfo::clear_mts_bg() {
  mts_bg_ = 0u;
}
inline ::google::protobuf::uint32 SysInfo::mts_bg() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.mts_bg)
  return mts_bg_;
}
inline void SysInfo::set_mts_bg(::google::protobuf::uint32 value) {
  
  mts_bg_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.mts_bg)
}

// uint32 ram_alr_used = 9;
inline void SysInfo::clear_ram_alr_used() {
  ram_alr_used_ = 0u;
}
inline ::google::protobuf::uint32 SysInfo::ram_alr_used() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.ram_alr_used)
  return ram_alr_used_;
}
inline void SysInfo::set_ram_alr_used(::google::protobuf::uint32 value) {
  
  ram_alr_used_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.ram_alr_used)
}

// uint32 ram_total = 10;
inline void SysInfo::clear_ram_total() {
  ram_total_ = 0u;
}
inline ::google::protobuf::uint32 SysInfo::ram_total() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.ram_total)
  return ram_total_;
}
inline void SysInfo::set_ram_total(::google::protobuf::uint32 value) {
  
  ram_total_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.ram_total)
}

// uint32 ram_used = 11;
inline void SysInfo::clear_ram_used() {
  ram_used_ = 0u;
}
inline ::google::protobuf::uint32 SysInfo::ram_used() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.ram_used)
  return ram_used_;
}
inline void SysInfo::set_ram_used(::google::protobuf::uint32 value) {
  
  ram_used_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.ram_used)
}

// uint32 emc = 12;
inline void SysInfo::clear_emc() {
  emc_ = 0u;
}
inline ::google::protobuf::uint32 SysInfo::emc() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.emc)
  return emc_;
}
inline void SysInfo::set_emc(::google::protobuf::uint32 value) {
  
  emc_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.emc)
}

// uint32 swap = 13;
inline void SysInfo::clear_swap() {
  swap_ = 0u;
}
inline ::google::protobuf::uint32 SysInfo::swap() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.swap)
  return swap_;
}
inline void SysInfo::set_swap(::google::protobuf::uint32 value) {
  
  swap_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.swap)
}

// .xsproto.base.HwEnginesInfo hwengines_info = 14;
inline bool SysInfo::has_hwengines_info() const {
  return this != internal_default_instance() && hwengines_info_ != NULL;
}
inline void SysInfo::clear_hwengines_info() {
  if (GetArenaNoVirtual() == NULL && hwengines_info_ != NULL) {
    delete hwengines_info_;
  }
  hwengines_info_ = NULL;
}
inline const ::xsproto::base::HwEnginesInfo& SysInfo::hwengines_info() const {
  const ::xsproto::base::HwEnginesInfo* p = hwengines_info_;
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.hwengines_info)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::base::HwEnginesInfo*>(
      &::xsproto::base::_HwEnginesInfo_default_instance_);
}
inline ::xsproto::base::HwEnginesInfo* SysInfo::release_hwengines_info() {
  // @@protoc_insertion_point(field_release:xsproto.base.SysInfo.hwengines_info)
  
  ::xsproto::base::HwEnginesInfo* temp = hwengines_info_;
  hwengines_info_ = NULL;
  return temp;
}
inline ::xsproto::base::HwEnginesInfo* SysInfo::mutable_hwengines_info() {
  
  if (hwengines_info_ == NULL) {
    hwengines_info_ = new ::xsproto::base::HwEnginesInfo;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.base.SysInfo.hwengines_info)
  return hwengines_info_;
}
inline void SysInfo::set_allocated_hwengines_info(::xsproto::base::HwEnginesInfo* hwengines_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hwengines_info_;
  }
  if (hwengines_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hwengines_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hwengines_info, submessage_arena);
    }
    
  } else {
    
  }
  hwengines_info_ = hwengines_info;
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.SysInfo.hwengines_info)
}

// float fan = 15;
inline void SysInfo::clear_fan() {
  fan_ = 0;
}
inline float SysInfo::fan() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.fan)
  return fan_;
}
inline void SysInfo::set_fan(float value) {
  
  fan_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.fan)
}

// .xsproto.base.TempInfo temp_info = 16;
inline bool SysInfo::has_temp_info() const {
  return this != internal_default_instance() && temp_info_ != NULL;
}
inline void SysInfo::clear_temp_info() {
  if (GetArenaNoVirtual() == NULL && temp_info_ != NULL) {
    delete temp_info_;
  }
  temp_info_ = NULL;
}
inline const ::xsproto::base::TempInfo& SysInfo::temp_info() const {
  const ::xsproto::base::TempInfo* p = temp_info_;
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.temp_info)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::base::TempInfo*>(
      &::xsproto::base::_TempInfo_default_instance_);
}
inline ::xsproto::base::TempInfo* SysInfo::release_temp_info() {
  // @@protoc_insertion_point(field_release:xsproto.base.SysInfo.temp_info)
  
  ::xsproto::base::TempInfo* temp = temp_info_;
  temp_info_ = NULL;
  return temp;
}
inline ::xsproto::base::TempInfo* SysInfo::mutable_temp_info() {
  
  if (temp_info_ == NULL) {
    temp_info_ = new ::xsproto::base::TempInfo;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.base.SysInfo.temp_info)
  return temp_info_;
}
inline void SysInfo::set_allocated_temp_info(::xsproto::base::TempInfo* temp_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete temp_info_;
  }
  if (temp_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      temp_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, temp_info, submessage_arena);
    }
    
  } else {
    
  }
  temp_info_ = temp_info;
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.SysInfo.temp_info)
}

// uint32 cur_power = 17;
inline void SysInfo::clear_cur_power() {
  cur_power_ = 0u;
}
inline ::google::protobuf::uint32 SysInfo::cur_power() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.cur_power)
  return cur_power_;
}
inline void SysInfo::set_cur_power(::google::protobuf::uint32 value) {
  
  cur_power_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.cur_power)
}

// uint32 avg_power = 18;
inline void SysInfo::clear_avg_power() {
  avg_power_ = 0u;
}
inline ::google::protobuf::uint32 SysInfo::avg_power() const {
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.avg_power)
  return avg_power_;
}
inline void SysInfo::set_avg_power(::google::protobuf::uint32 value) {
  
  avg_power_ = value;
  // @@protoc_insertion_point(field_set:xsproto.base.SysInfo.avg_power)
}

// .xsproto.base.BoardInfo board_info = 19;
inline bool SysInfo::has_board_info() const {
  return this != internal_default_instance() && board_info_ != NULL;
}
inline void SysInfo::clear_board_info() {
  if (GetArenaNoVirtual() == NULL && board_info_ != NULL) {
    delete board_info_;
  }
  board_info_ = NULL;
}
inline const ::xsproto::base::BoardInfo& SysInfo::board_info() const {
  const ::xsproto::base::BoardInfo* p = board_info_;
  // @@protoc_insertion_point(field_get:xsproto.base.SysInfo.board_info)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::base::BoardInfo*>(
      &::xsproto::base::_BoardInfo_default_instance_);
}
inline ::xsproto::base::BoardInfo* SysInfo::release_board_info() {
  // @@protoc_insertion_point(field_release:xsproto.base.SysInfo.board_info)
  
  ::xsproto::base::BoardInfo* temp = board_info_;
  board_info_ = NULL;
  return temp;
}
inline ::xsproto::base::BoardInfo* SysInfo::mutable_board_info() {
  
  if (board_info_ == NULL) {
    board_info_ = new ::xsproto::base::BoardInfo;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.base.SysInfo.board_info)
  return board_info_;
}
inline void SysInfo::set_allocated_board_info(::xsproto::base::BoardInfo* board_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete board_info_;
  }
  if (board_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      board_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, board_info, submessage_arena);
    }
    
  } else {
    
  }
  board_info_ = board_info;
  // @@protoc_insertion_point(field_set_allocated:xsproto.base.SysInfo.board_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace base
}  // namespace xsproto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_base_2fsys_5finfo_2eproto__INCLUDED
