// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: business/route_record_response.proto

#ifndef PROTOBUF_business_2froute_5frecord_5fresponse_2eproto__INCLUDED
#define PROTOBUF_business_2froute_5frecord_5fresponse_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "base/header.pb.h"
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)

namespace protobuf_business_2froute_5frecord_5fresponse_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRouteRecordResponseImpl();
void InitDefaultsRouteRecordResponse();
void InitDefaultsRecordPoint_AttributeImpl();
void InitDefaultsRecordPoint_Attribute();
void InitDefaultsRecordPoint_PointImpl();
void InitDefaultsRecordPoint_Point();
void InitDefaultsRecordPointImpl();
void InitDefaultsRecordPoint();
void InitDefaultsRecordCurrentImpl();
void InitDefaultsRecordCurrent();
inline void InitDefaults() {
  InitDefaultsRouteRecordResponse();
  InitDefaultsRecordPoint_Attribute();
  InitDefaultsRecordPoint_Point();
  InitDefaultsRecordPoint();
  InitDefaultsRecordCurrent();
}
}  // namespace protobuf_business_2froute_5frecord_5fresponse_2eproto
namespace xsproto {
namespace communication {
class RecordCurrent;
class RecordCurrentDefaultTypeInternal;
extern RecordCurrentDefaultTypeInternal _RecordCurrent_default_instance_;
class RecordPoint;
class RecordPointDefaultTypeInternal;
extern RecordPointDefaultTypeInternal _RecordPoint_default_instance_;
class RecordPoint_Attribute;
class RecordPoint_AttributeDefaultTypeInternal;
extern RecordPoint_AttributeDefaultTypeInternal _RecordPoint_Attribute_default_instance_;
class RecordPoint_Point;
class RecordPoint_PointDefaultTypeInternal;
extern RecordPoint_PointDefaultTypeInternal _RecordPoint_Point_default_instance_;
class RouteRecordResponse;
class RouteRecordResponseDefaultTypeInternal;
extern RouteRecordResponseDefaultTypeInternal _RouteRecordResponse_default_instance_;
}  // namespace communication
}  // namespace xsproto
namespace xsproto {
namespace communication {

enum RecordCurrent_RouteRecordStatus {
  RecordCurrent_RouteRecordStatus_NORMAL = 0,
  RecordCurrent_RouteRecordStatus_START = 1,
  RecordCurrent_RouteRecordStatus_STOP = 2,
  RecordCurrent_RouteRecordStatus_PAUSE = 3,
  RecordCurrent_RouteRecordStatus_RESUME = 4,
  RecordCurrent_RouteRecordStatus_RecordCurrent_RouteRecordStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RecordCurrent_RouteRecordStatus_RecordCurrent_RouteRecordStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RecordCurrent_RouteRecordStatus_IsValid(int value);
const RecordCurrent_RouteRecordStatus RecordCurrent_RouteRecordStatus_RouteRecordStatus_MIN = RecordCurrent_RouteRecordStatus_NORMAL;
const RecordCurrent_RouteRecordStatus RecordCurrent_RouteRecordStatus_RouteRecordStatus_MAX = RecordCurrent_RouteRecordStatus_RESUME;
const int RecordCurrent_RouteRecordStatus_RouteRecordStatus_ARRAYSIZE = RecordCurrent_RouteRecordStatus_RouteRecordStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecordCurrent_RouteRecordStatus_descriptor();
inline const ::std::string& RecordCurrent_RouteRecordStatus_Name(RecordCurrent_RouteRecordStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecordCurrent_RouteRecordStatus_descriptor(), value);
}
inline bool RecordCurrent_RouteRecordStatus_Parse(
    const ::std::string& name, RecordCurrent_RouteRecordStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecordCurrent_RouteRecordStatus>(
    RecordCurrent_RouteRecordStatus_descriptor(), name, value);
}
// ===================================================================

class RouteRecordResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.communication.RouteRecordResponse) */ {
 public:
  RouteRecordResponse();
  virtual ~RouteRecordResponse();

  RouteRecordResponse(const RouteRecordResponse& from);

  inline RouteRecordResponse& operator=(const RouteRecordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteRecordResponse(RouteRecordResponse&& from) noexcept
    : RouteRecordResponse() {
    *this = ::std::move(from);
  }

  inline RouteRecordResponse& operator=(RouteRecordResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteRecordResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteRecordResponse* internal_default_instance() {
    return reinterpret_cast<const RouteRecordResponse*>(
               &_RouteRecordResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RouteRecordResponse* other);
  friend void swap(RouteRecordResponse& a, RouteRecordResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteRecordResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteRecordResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteRecordResponse& from);
  void MergeFrom(const RouteRecordResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteRecordResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error_msg = 6;
  void clear_error_msg();
  static const int kErrorMsgFieldNumber = 6;
  const ::std::string& error_msg() const;
  void set_error_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_error_msg(::std::string&& value);
  #endif
  void set_error_msg(const char* value);
  void set_error_msg(const char* value, size_t size);
  ::std::string* mutable_error_msg();
  ::std::string* release_error_msg();
  void set_allocated_error_msg(::std::string* error_msg);

  // .xsproto.base.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xsproto::base::Header& header() const;
  ::xsproto::base::Header* release_header();
  ::xsproto::base::Header* mutable_header();
  void set_allocated_header(::xsproto::base::Header* header);

  // .google.protobuf.Any msg_content = 7;
  bool has_msg_content() const;
  void clear_msg_content();
  static const int kMsgContentFieldNumber = 7;
  const ::google::protobuf::Any& msg_content() const;
  ::google::protobuf::Any* release_msg_content();
  ::google::protobuf::Any* mutable_msg_content();
  void set_allocated_msg_content(::google::protobuf::Any* msg_content);

  // int64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int32 seq_num = 3;
  void clear_seq_num();
  static const int kSeqNumFieldNumber = 3;
  ::google::protobuf::int32 seq_num() const;
  void set_seq_num(::google::protobuf::int32 value);

  // int32 msg_code = 4;
  void clear_msg_code();
  static const int kMsgCodeFieldNumber = 4;
  ::google::protobuf::int32 msg_code() const;
  void set_msg_code(::google::protobuf::int32 value);

  // int32 result = 5;
  void clear_result();
  static const int kResultFieldNumber = 5;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.communication.RouteRecordResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_msg_;
  ::xsproto::base::Header* header_;
  ::google::protobuf::Any* msg_content_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 seq_num_;
  ::google::protobuf::int32 msg_code_;
  ::google::protobuf::int32 result_;
  mutable int _cached_size_;
  friend struct ::protobuf_business_2froute_5frecord_5fresponse_2eproto::TableStruct;
  friend void ::protobuf_business_2froute_5frecord_5fresponse_2eproto::InitDefaultsRouteRecordResponseImpl();
};
// -------------------------------------------------------------------

class RecordPoint_Attribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.communication.RecordPoint.Attribute) */ {
 public:
  RecordPoint_Attribute();
  virtual ~RecordPoint_Attribute();

  RecordPoint_Attribute(const RecordPoint_Attribute& from);

  inline RecordPoint_Attribute& operator=(const RecordPoint_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecordPoint_Attribute(RecordPoint_Attribute&& from) noexcept
    : RecordPoint_Attribute() {
    *this = ::std::move(from);
  }

  inline RecordPoint_Attribute& operator=(RecordPoint_Attribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordPoint_Attribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordPoint_Attribute* internal_default_instance() {
    return reinterpret_cast<const RecordPoint_Attribute*>(
               &_RecordPoint_Attribute_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RecordPoint_Attribute* other);
  friend void swap(RecordPoint_Attribute& a, RecordPoint_Attribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecordPoint_Attribute* New() const PROTOBUF_FINAL { return New(NULL); }

  RecordPoint_Attribute* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RecordPoint_Attribute& from);
  void MergeFrom(const RecordPoint_Attribute& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RecordPoint_Attribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:xsproto.communication.RecordPoint.Attribute)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct ::protobuf_business_2froute_5frecord_5fresponse_2eproto::TableStruct;
  friend void ::protobuf_business_2froute_5frecord_5fresponse_2eproto::InitDefaultsRecordPoint_AttributeImpl();
};
// -------------------------------------------------------------------

class RecordPoint_Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.communication.RecordPoint.Point) */ {
 public:
  RecordPoint_Point();
  virtual ~RecordPoint_Point();

  RecordPoint_Point(const RecordPoint_Point& from);

  inline RecordPoint_Point& operator=(const RecordPoint_Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecordPoint_Point(RecordPoint_Point&& from) noexcept
    : RecordPoint_Point() {
    *this = ::std::move(from);
  }

  inline RecordPoint_Point& operator=(RecordPoint_Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordPoint_Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordPoint_Point* internal_default_instance() {
    return reinterpret_cast<const RecordPoint_Point*>(
               &_RecordPoint_Point_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RecordPoint_Point* other);
  friend void swap(RecordPoint_Point& a, RecordPoint_Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecordPoint_Point* New() const PROTOBUF_FINAL { return New(NULL); }

  RecordPoint_Point* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RecordPoint_Point& from);
  void MergeFrom(const RecordPoint_Point& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RecordPoint_Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.communication.RecordPoint.Attribute attr = 9;
  int attr_size() const;
  void clear_attr();
  static const int kAttrFieldNumber = 9;
  const ::xsproto::communication::RecordPoint_Attribute& attr(int index) const;
  ::xsproto::communication::RecordPoint_Attribute* mutable_attr(int index);
  ::xsproto::communication::RecordPoint_Attribute* add_attr();
  ::google::protobuf::RepeatedPtrField< ::xsproto::communication::RecordPoint_Attribute >*
      mutable_attr();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::communication::RecordPoint_Attribute >&
      attr() const;

  // double global_x = 1;
  void clear_global_x();
  static const int kGlobalXFieldNumber = 1;
  double global_x() const;
  void set_global_x(double value);

  // double global_y = 2;
  void clear_global_y();
  static const int kGlobalYFieldNumber = 2;
  double global_y() const;
  void set_global_y(double value);

  // double azimuth = 3;
  void clear_azimuth();
  static const int kAzimuthFieldNumber = 3;
  double azimuth() const;
  void set_azimuth(double value);

  // double longitude = 4;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 4;
  double longitude() const;
  void set_longitude(double value);

  // double latitude = 5;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 5;
  double latitude() const;
  void set_latitude(double value);

  // double altitude = 6;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 6;
  double altitude() const;
  void set_altitude(double value);

  // double roll = 7;
  void clear_roll();
  static const int kRollFieldNumber = 7;
  double roll() const;
  void set_roll(double value);

  // double pitch = 8;
  void clear_pitch();
  static const int kPitchFieldNumber = 8;
  double pitch() const;
  void set_pitch(double value);

  // @@protoc_insertion_point(class_scope:xsproto.communication.RecordPoint.Point)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::communication::RecordPoint_Attribute > attr_;
  double global_x_;
  double global_y_;
  double azimuth_;
  double longitude_;
  double latitude_;
  double altitude_;
  double roll_;
  double pitch_;
  mutable int _cached_size_;
  friend struct ::protobuf_business_2froute_5frecord_5fresponse_2eproto::TableStruct;
  friend void ::protobuf_business_2froute_5frecord_5fresponse_2eproto::InitDefaultsRecordPoint_PointImpl();
};
// -------------------------------------------------------------------

class RecordPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.communication.RecordPoint) */ {
 public:
  RecordPoint();
  virtual ~RecordPoint();

  RecordPoint(const RecordPoint& from);

  inline RecordPoint& operator=(const RecordPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecordPoint(RecordPoint&& from) noexcept
    : RecordPoint() {
    *this = ::std::move(from);
  }

  inline RecordPoint& operator=(RecordPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordPoint* internal_default_instance() {
    return reinterpret_cast<const RecordPoint*>(
               &_RecordPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RecordPoint* other);
  friend void swap(RecordPoint& a, RecordPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecordPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  RecordPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RecordPoint& from);
  void MergeFrom(const RecordPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RecordPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RecordPoint_Attribute Attribute;
  typedef RecordPoint_Point Point;

  // accessors -------------------------------------------------------

  // .xsproto.communication.RecordPoint.Point point = 2;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 2;
  const ::xsproto::communication::RecordPoint_Point& point() const;
  ::xsproto::communication::RecordPoint_Point* release_point();
  ::xsproto::communication::RecordPoint_Point* mutable_point();
  void set_allocated_point(::xsproto::communication::RecordPoint_Point* point);

  // int32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.communication.RecordPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xsproto::communication::RecordPoint_Point* point_;
  ::google::protobuf::int32 index_;
  mutable int _cached_size_;
  friend struct ::protobuf_business_2froute_5frecord_5fresponse_2eproto::TableStruct;
  friend void ::protobuf_business_2froute_5frecord_5fresponse_2eproto::InitDefaultsRecordPointImpl();
};
// -------------------------------------------------------------------

class RecordCurrent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.communication.RecordCurrent) */ {
 public:
  RecordCurrent();
  virtual ~RecordCurrent();

  RecordCurrent(const RecordCurrent& from);

  inline RecordCurrent& operator=(const RecordCurrent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecordCurrent(RecordCurrent&& from) noexcept
    : RecordCurrent() {
    *this = ::std::move(from);
  }

  inline RecordCurrent& operator=(RecordCurrent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordCurrent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordCurrent* internal_default_instance() {
    return reinterpret_cast<const RecordCurrent*>(
               &_RecordCurrent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RecordCurrent* other);
  friend void swap(RecordCurrent& a, RecordCurrent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecordCurrent* New() const PROTOBUF_FINAL { return New(NULL); }

  RecordCurrent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RecordCurrent& from);
  void MergeFrom(const RecordCurrent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RecordCurrent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RecordCurrent_RouteRecordStatus RouteRecordStatus;
  static const RouteRecordStatus NORMAL =
    RecordCurrent_RouteRecordStatus_NORMAL;
  static const RouteRecordStatus START =
    RecordCurrent_RouteRecordStatus_START;
  static const RouteRecordStatus STOP =
    RecordCurrent_RouteRecordStatus_STOP;
  static const RouteRecordStatus PAUSE =
    RecordCurrent_RouteRecordStatus_PAUSE;
  static const RouteRecordStatus RESUME =
    RecordCurrent_RouteRecordStatus_RESUME;
  static inline bool RouteRecordStatus_IsValid(int value) {
    return RecordCurrent_RouteRecordStatus_IsValid(value);
  }
  static const RouteRecordStatus RouteRecordStatus_MIN =
    RecordCurrent_RouteRecordStatus_RouteRecordStatus_MIN;
  static const RouteRecordStatus RouteRecordStatus_MAX =
    RecordCurrent_RouteRecordStatus_RouteRecordStatus_MAX;
  static const int RouteRecordStatus_ARRAYSIZE =
    RecordCurrent_RouteRecordStatus_RouteRecordStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RouteRecordStatus_descriptor() {
    return RecordCurrent_RouteRecordStatus_descriptor();
  }
  static inline const ::std::string& RouteRecordStatus_Name(RouteRecordStatus value) {
    return RecordCurrent_RouteRecordStatus_Name(value);
  }
  static inline bool RouteRecordStatus_Parse(const ::std::string& name,
      RouteRecordStatus* value) {
    return RecordCurrent_RouteRecordStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int64 time = 1;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // .xsproto.communication.RecordCurrent.RouteRecordStatus status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::xsproto::communication::RecordCurrent_RouteRecordStatus status() const;
  void set_status(::xsproto::communication::RecordCurrent_RouteRecordStatus value);

  // @@protoc_insertion_point(class_scope:xsproto.communication.RecordCurrent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 time_;
  int status_;
  mutable int _cached_size_;
  friend struct ::protobuf_business_2froute_5frecord_5fresponse_2eproto::TableStruct;
  friend void ::protobuf_business_2froute_5frecord_5fresponse_2eproto::InitDefaultsRecordCurrentImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RouteRecordResponse

// .xsproto.base.Header header = 1;
inline bool RouteRecordResponse::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::xsproto::base::Header& RouteRecordResponse::header() const {
  const ::xsproto::base::Header* p = header_;
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordResponse.header)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::base::Header*>(
      &::xsproto::base::_Header_default_instance_);
}
inline ::xsproto::base::Header* RouteRecordResponse::release_header() {
  // @@protoc_insertion_point(field_release:xsproto.communication.RouteRecordResponse.header)
  
  ::xsproto::base::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::xsproto::base::Header* RouteRecordResponse::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::xsproto::base::Header;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.communication.RouteRecordResponse.header)
  return header_;
}
inline void RouteRecordResponse::set_allocated_header(::xsproto::base::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xsproto.communication.RouteRecordResponse.header)
}

// int64 timestamp = 2;
inline void RouteRecordResponse::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RouteRecordResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordResponse.timestamp)
  return timestamp_;
}
inline void RouteRecordResponse::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RouteRecordResponse.timestamp)
}

// int32 seq_num = 3;
inline void RouteRecordResponse::clear_seq_num() {
  seq_num_ = 0;
}
inline ::google::protobuf::int32 RouteRecordResponse::seq_num() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordResponse.seq_num)
  return seq_num_;
}
inline void RouteRecordResponse::set_seq_num(::google::protobuf::int32 value) {
  
  seq_num_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RouteRecordResponse.seq_num)
}

// int32 msg_code = 4;
inline void RouteRecordResponse::clear_msg_code() {
  msg_code_ = 0;
}
inline ::google::protobuf::int32 RouteRecordResponse::msg_code() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordResponse.msg_code)
  return msg_code_;
}
inline void RouteRecordResponse::set_msg_code(::google::protobuf::int32 value) {
  
  msg_code_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RouteRecordResponse.msg_code)
}

// int32 result = 5;
inline void RouteRecordResponse::clear_result() {
  result_ = 0;
}
inline ::google::protobuf::int32 RouteRecordResponse::result() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordResponse.result)
  return result_;
}
inline void RouteRecordResponse::set_result(::google::protobuf::int32 value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RouteRecordResponse.result)
}

// string error_msg = 6;
inline void RouteRecordResponse::clear_error_msg() {
  error_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RouteRecordResponse::error_msg() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordResponse.error_msg)
  return error_msg_.GetNoArena();
}
inline void RouteRecordResponse::set_error_msg(const ::std::string& value) {
  
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.communication.RouteRecordResponse.error_msg)
}
#if LANG_CXX11
inline void RouteRecordResponse::set_error_msg(::std::string&& value) {
  
  error_msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.communication.RouteRecordResponse.error_msg)
}
#endif
inline void RouteRecordResponse::set_error_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.communication.RouteRecordResponse.error_msg)
}
inline void RouteRecordResponse::set_error_msg(const char* value, size_t size) {
  
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.communication.RouteRecordResponse.error_msg)
}
inline ::std::string* RouteRecordResponse::mutable_error_msg() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.communication.RouteRecordResponse.error_msg)
  return error_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteRecordResponse::release_error_msg() {
  // @@protoc_insertion_point(field_release:xsproto.communication.RouteRecordResponse.error_msg)
  
  return error_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteRecordResponse::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg != NULL) {
    
  } else {
    
  }
  error_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_msg);
  // @@protoc_insertion_point(field_set_allocated:xsproto.communication.RouteRecordResponse.error_msg)
}

// .google.protobuf.Any msg_content = 7;
inline bool RouteRecordResponse::has_msg_content() const {
  return this != internal_default_instance() && msg_content_ != NULL;
}
inline const ::google::protobuf::Any& RouteRecordResponse::msg_content() const {
  const ::google::protobuf::Any* p = msg_content_;
  // @@protoc_insertion_point(field_get:xsproto.communication.RouteRecordResponse.msg_content)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* RouteRecordResponse::release_msg_content() {
  // @@protoc_insertion_point(field_release:xsproto.communication.RouteRecordResponse.msg_content)
  
  ::google::protobuf::Any* temp = msg_content_;
  msg_content_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* RouteRecordResponse::mutable_msg_content() {
  
  if (msg_content_ == NULL) {
    msg_content_ = new ::google::protobuf::Any;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.communication.RouteRecordResponse.msg_content)
  return msg_content_;
}
inline void RouteRecordResponse::set_allocated_msg_content(::google::protobuf::Any* msg_content) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(msg_content_);
  }
  if (msg_content) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg_content = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg_content, submessage_arena);
    }
    
  } else {
    
  }
  msg_content_ = msg_content;
  // @@protoc_insertion_point(field_set_allocated:xsproto.communication.RouteRecordResponse.msg_content)
}

// -------------------------------------------------------------------

// RecordPoint_Attribute

// string key = 1;
inline void RecordPoint_Attribute::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecordPoint_Attribute::key() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordPoint.Attribute.key)
  return key_.GetNoArena();
}
inline void RecordPoint_Attribute::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordPoint.Attribute.key)
}
#if LANG_CXX11
inline void RecordPoint_Attribute::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.communication.RecordPoint.Attribute.key)
}
#endif
inline void RecordPoint_Attribute::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.communication.RecordPoint.Attribute.key)
}
inline void RecordPoint_Attribute::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.communication.RecordPoint.Attribute.key)
}
inline ::std::string* RecordPoint_Attribute::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.communication.RecordPoint.Attribute.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecordPoint_Attribute::release_key() {
  // @@protoc_insertion_point(field_release:xsproto.communication.RecordPoint.Attribute.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecordPoint_Attribute::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:xsproto.communication.RecordPoint.Attribute.key)
}

// string value = 2;
inline void RecordPoint_Attribute::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RecordPoint_Attribute::value() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordPoint.Attribute.value)
  return value_.GetNoArena();
}
inline void RecordPoint_Attribute::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordPoint.Attribute.value)
}
#if LANG_CXX11
inline void RecordPoint_Attribute::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.communication.RecordPoint.Attribute.value)
}
#endif
inline void RecordPoint_Attribute::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.communication.RecordPoint.Attribute.value)
}
inline void RecordPoint_Attribute::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.communication.RecordPoint.Attribute.value)
}
inline ::std::string* RecordPoint_Attribute::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.communication.RecordPoint.Attribute.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecordPoint_Attribute::release_value() {
  // @@protoc_insertion_point(field_release:xsproto.communication.RecordPoint.Attribute.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecordPoint_Attribute::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:xsproto.communication.RecordPoint.Attribute.value)
}

// -------------------------------------------------------------------

// RecordPoint_Point

// double global_x = 1;
inline void RecordPoint_Point::clear_global_x() {
  global_x_ = 0;
}
inline double RecordPoint_Point::global_x() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordPoint.Point.global_x)
  return global_x_;
}
inline void RecordPoint_Point::set_global_x(double value) {
  
  global_x_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordPoint.Point.global_x)
}

// double global_y = 2;
inline void RecordPoint_Point::clear_global_y() {
  global_y_ = 0;
}
inline double RecordPoint_Point::global_y() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordPoint.Point.global_y)
  return global_y_;
}
inline void RecordPoint_Point::set_global_y(double value) {
  
  global_y_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordPoint.Point.global_y)
}

// double azimuth = 3;
inline void RecordPoint_Point::clear_azimuth() {
  azimuth_ = 0;
}
inline double RecordPoint_Point::azimuth() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordPoint.Point.azimuth)
  return azimuth_;
}
inline void RecordPoint_Point::set_azimuth(double value) {
  
  azimuth_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordPoint.Point.azimuth)
}

// double longitude = 4;
inline void RecordPoint_Point::clear_longitude() {
  longitude_ = 0;
}
inline double RecordPoint_Point::longitude() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordPoint.Point.longitude)
  return longitude_;
}
inline void RecordPoint_Point::set_longitude(double value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordPoint.Point.longitude)
}

// double latitude = 5;
inline void RecordPoint_Point::clear_latitude() {
  latitude_ = 0;
}
inline double RecordPoint_Point::latitude() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordPoint.Point.latitude)
  return latitude_;
}
inline void RecordPoint_Point::set_latitude(double value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordPoint.Point.latitude)
}

// double altitude = 6;
inline void RecordPoint_Point::clear_altitude() {
  altitude_ = 0;
}
inline double RecordPoint_Point::altitude() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordPoint.Point.altitude)
  return altitude_;
}
inline void RecordPoint_Point::set_altitude(double value) {
  
  altitude_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordPoint.Point.altitude)
}

// double roll = 7;
inline void RecordPoint_Point::clear_roll() {
  roll_ = 0;
}
inline double RecordPoint_Point::roll() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordPoint.Point.roll)
  return roll_;
}
inline void RecordPoint_Point::set_roll(double value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordPoint.Point.roll)
}

// double pitch = 8;
inline void RecordPoint_Point::clear_pitch() {
  pitch_ = 0;
}
inline double RecordPoint_Point::pitch() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordPoint.Point.pitch)
  return pitch_;
}
inline void RecordPoint_Point::set_pitch(double value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordPoint.Point.pitch)
}

// repeated .xsproto.communication.RecordPoint.Attribute attr = 9;
inline int RecordPoint_Point::attr_size() const {
  return attr_.size();
}
inline void RecordPoint_Point::clear_attr() {
  attr_.Clear();
}
inline const ::xsproto::communication::RecordPoint_Attribute& RecordPoint_Point::attr(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordPoint.Point.attr)
  return attr_.Get(index);
}
inline ::xsproto::communication::RecordPoint_Attribute* RecordPoint_Point::mutable_attr(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.communication.RecordPoint.Point.attr)
  return attr_.Mutable(index);
}
inline ::xsproto::communication::RecordPoint_Attribute* RecordPoint_Point::add_attr() {
  // @@protoc_insertion_point(field_add:xsproto.communication.RecordPoint.Point.attr)
  return attr_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::communication::RecordPoint_Attribute >*
RecordPoint_Point::mutable_attr() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.communication.RecordPoint.Point.attr)
  return &attr_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::communication::RecordPoint_Attribute >&
RecordPoint_Point::attr() const {
  // @@protoc_insertion_point(field_list:xsproto.communication.RecordPoint.Point.attr)
  return attr_;
}

// -------------------------------------------------------------------

// RecordPoint

// int32 index = 1;
inline void RecordPoint::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 RecordPoint::index() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordPoint.index)
  return index_;
}
inline void RecordPoint::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordPoint.index)
}

// .xsproto.communication.RecordPoint.Point point = 2;
inline bool RecordPoint::has_point() const {
  return this != internal_default_instance() && point_ != NULL;
}
inline void RecordPoint::clear_point() {
  if (GetArenaNoVirtual() == NULL && point_ != NULL) {
    delete point_;
  }
  point_ = NULL;
}
inline const ::xsproto::communication::RecordPoint_Point& RecordPoint::point() const {
  const ::xsproto::communication::RecordPoint_Point* p = point_;
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordPoint.point)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::communication::RecordPoint_Point*>(
      &::xsproto::communication::_RecordPoint_Point_default_instance_);
}
inline ::xsproto::communication::RecordPoint_Point* RecordPoint::release_point() {
  // @@protoc_insertion_point(field_release:xsproto.communication.RecordPoint.point)
  
  ::xsproto::communication::RecordPoint_Point* temp = point_;
  point_ = NULL;
  return temp;
}
inline ::xsproto::communication::RecordPoint_Point* RecordPoint::mutable_point() {
  
  if (point_ == NULL) {
    point_ = new ::xsproto::communication::RecordPoint_Point;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.communication.RecordPoint.point)
  return point_;
}
inline void RecordPoint::set_allocated_point(::xsproto::communication::RecordPoint_Point* point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete point_;
  }
  if (point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:xsproto.communication.RecordPoint.point)
}

// -------------------------------------------------------------------

// RecordCurrent

// int64 time = 1;
inline void RecordCurrent::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RecordCurrent::time() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordCurrent.time)
  return time_;
}
inline void RecordCurrent::set_time(::google::protobuf::int64 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordCurrent.time)
}

// .xsproto.communication.RecordCurrent.RouteRecordStatus status = 2;
inline void RecordCurrent::clear_status() {
  status_ = 0;
}
inline ::xsproto::communication::RecordCurrent_RouteRecordStatus RecordCurrent::status() const {
  // @@protoc_insertion_point(field_get:xsproto.communication.RecordCurrent.status)
  return static_cast< ::xsproto::communication::RecordCurrent_RouteRecordStatus >(status_);
}
inline void RecordCurrent::set_status(::xsproto::communication::RecordCurrent_RouteRecordStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:xsproto.communication.RecordCurrent.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace communication
}  // namespace xsproto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::xsproto::communication::RecordCurrent_RouteRecordStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::communication::RecordCurrent_RouteRecordStatus>() {
  return ::xsproto::communication::RecordCurrent_RouteRecordStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_business_2froute_5frecord_5fresponse_2eproto__INCLUDED
