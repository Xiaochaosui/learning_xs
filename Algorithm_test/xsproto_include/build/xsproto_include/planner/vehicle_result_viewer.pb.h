// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planner/vehicle_result_viewer.proto

#ifndef PROTOBUF_planner_2fvehicle_5fresult_5fviewer_2eproto__INCLUDED
#define PROTOBUF_planner_2fvehicle_5fresult_5fviewer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "base/header.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_planner_2fvehicle_5fresult_5fviewer_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsVehicleResultViewerImpl();
void InitDefaultsVehicleResultViewer();
void InitDefaultsOcvMatInfoImpl();
void InitDefaultsOcvMatInfo();
inline void InitDefaults() {
  InitDefaultsVehicleResultViewer();
  InitDefaultsOcvMatInfo();
}
}  // namespace protobuf_planner_2fvehicle_5fresult_5fviewer_2eproto
namespace xsproto {
namespace planner {
class OcvMatInfo;
class OcvMatInfoDefaultTypeInternal;
extern OcvMatInfoDefaultTypeInternal _OcvMatInfo_default_instance_;
class VehicleResultViewer;
class VehicleResultViewerDefaultTypeInternal;
extern VehicleResultViewerDefaultTypeInternal _VehicleResultViewer_default_instance_;
}  // namespace planner
}  // namespace xsproto
namespace xsproto {
namespace planner {

enum ChannelType {
  CHANNEL_UNKNOWN = 0,
  CHANNEL_RGB = 1,
  CHANNEL_GRAY = 2,
  ChannelType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ChannelType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ChannelType_IsValid(int value);
const ChannelType ChannelType_MIN = CHANNEL_UNKNOWN;
const ChannelType ChannelType_MAX = CHANNEL_GRAY;
const int ChannelType_ARRAYSIZE = ChannelType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChannelType_descriptor();
inline const ::std::string& ChannelType_Name(ChannelType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChannelType_descriptor(), value);
}
inline bool ChannelType_Parse(
    const ::std::string& name, ChannelType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChannelType>(
    ChannelType_descriptor(), name, value);
}
// ===================================================================

class VehicleResultViewer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.planner.VehicleResultViewer) */ {
 public:
  VehicleResultViewer();
  virtual ~VehicleResultViewer();

  VehicleResultViewer(const VehicleResultViewer& from);

  inline VehicleResultViewer& operator=(const VehicleResultViewer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleResultViewer(VehicleResultViewer&& from) noexcept
    : VehicleResultViewer() {
    *this = ::std::move(from);
  }

  inline VehicleResultViewer& operator=(VehicleResultViewer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleResultViewer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleResultViewer* internal_default_instance() {
    return reinterpret_cast<const VehicleResultViewer*>(
               &_VehicleResultViewer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(VehicleResultViewer* other);
  friend void swap(VehicleResultViewer& a, VehicleResultViewer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleResultViewer* New() const PROTOBUF_FINAL { return New(NULL); }

  VehicleResultViewer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VehicleResultViewer& from);
  void MergeFrom(const VehicleResultViewer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VehicleResultViewer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xsproto.base.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xsproto::base::Header& header() const;
  ::xsproto::base::Header* release_header();
  ::xsproto::base::Header* mutable_header();
  void set_allocated_header(::xsproto::base::Header* header);

  // int32 img_width = 2;
  void clear_img_width();
  static const int kImgWidthFieldNumber = 2;
  ::google::protobuf::int32 img_width() const;
  void set_img_width(::google::protobuf::int32 value);

  // int32 img_height = 3;
  void clear_img_height();
  static const int kImgHeightFieldNumber = 3;
  ::google::protobuf::int32 img_height() const;
  void set_img_height(::google::protobuf::int32 value);

  // .xsproto.planner.ChannelType pixel_channel = 4;
  void clear_pixel_channel();
  static const int kPixelChannelFieldNumber = 4;
  ::xsproto::planner::ChannelType pixel_channel() const;
  void set_pixel_channel(::xsproto::planner::ChannelType value);

  // uint32 img_data_rgb = 5;
  void clear_img_data_rgb();
  static const int kImgDataRgbFieldNumber = 5;
  ::google::protobuf::uint32 img_data_rgb() const;
  void set_img_data_rgb(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xsproto.planner.VehicleResultViewer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xsproto::base::Header* header_;
  ::google::protobuf::int32 img_width_;
  ::google::protobuf::int32 img_height_;
  int pixel_channel_;
  ::google::protobuf::uint32 img_data_rgb_;
  mutable int _cached_size_;
  friend struct ::protobuf_planner_2fvehicle_5fresult_5fviewer_2eproto::TableStruct;
  friend void ::protobuf_planner_2fvehicle_5fresult_5fviewer_2eproto::InitDefaultsVehicleResultViewerImpl();
};
// -------------------------------------------------------------------

class OcvMatInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.planner.OcvMatInfo) */ {
 public:
  OcvMatInfo();
  virtual ~OcvMatInfo();

  OcvMatInfo(const OcvMatInfo& from);

  inline OcvMatInfo& operator=(const OcvMatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OcvMatInfo(OcvMatInfo&& from) noexcept
    : OcvMatInfo() {
    *this = ::std::move(from);
  }

  inline OcvMatInfo& operator=(OcvMatInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OcvMatInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OcvMatInfo* internal_default_instance() {
    return reinterpret_cast<const OcvMatInfo*>(
               &_OcvMatInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(OcvMatInfo* other);
  friend void swap(OcvMatInfo& a, OcvMatInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OcvMatInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  OcvMatInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OcvMatInfo& from);
  void MergeFrom(const OcvMatInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OcvMatInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 5;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // int32 rows = 1;
  void clear_rows();
  static const int kRowsFieldNumber = 1;
  ::google::protobuf::int32 rows() const;
  void set_rows(::google::protobuf::int32 value);

  // int32 cols = 2;
  void clear_cols();
  static const int kColsFieldNumber = 2;
  ::google::protobuf::int32 cols() const;
  void set_cols(::google::protobuf::int32 value);

  // int32 type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // int32 size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.planner.OcvMatInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 rows_;
  ::google::protobuf::int32 cols_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 size_;
  mutable int _cached_size_;
  friend struct ::protobuf_planner_2fvehicle_5fresult_5fviewer_2eproto::TableStruct;
  friend void ::protobuf_planner_2fvehicle_5fresult_5fviewer_2eproto::InitDefaultsOcvMatInfoImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VehicleResultViewer

// .xsproto.base.Header header = 1;
inline bool VehicleResultViewer::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::xsproto::base::Header& VehicleResultViewer::header() const {
  const ::xsproto::base::Header* p = header_;
  // @@protoc_insertion_point(field_get:xsproto.planner.VehicleResultViewer.header)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::base::Header*>(
      &::xsproto::base::_Header_default_instance_);
}
inline ::xsproto::base::Header* VehicleResultViewer::release_header() {
  // @@protoc_insertion_point(field_release:xsproto.planner.VehicleResultViewer.header)
  
  ::xsproto::base::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::xsproto::base::Header* VehicleResultViewer::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::xsproto::base::Header;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.planner.VehicleResultViewer.header)
  return header_;
}
inline void VehicleResultViewer::set_allocated_header(::xsproto::base::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xsproto.planner.VehicleResultViewer.header)
}

// int32 img_width = 2;
inline void VehicleResultViewer::clear_img_width() {
  img_width_ = 0;
}
inline ::google::protobuf::int32 VehicleResultViewer::img_width() const {
  // @@protoc_insertion_point(field_get:xsproto.planner.VehicleResultViewer.img_width)
  return img_width_;
}
inline void VehicleResultViewer::set_img_width(::google::protobuf::int32 value) {
  
  img_width_ = value;
  // @@protoc_insertion_point(field_set:xsproto.planner.VehicleResultViewer.img_width)
}

// int32 img_height = 3;
inline void VehicleResultViewer::clear_img_height() {
  img_height_ = 0;
}
inline ::google::protobuf::int32 VehicleResultViewer::img_height() const {
  // @@protoc_insertion_point(field_get:xsproto.planner.VehicleResultViewer.img_height)
  return img_height_;
}
inline void VehicleResultViewer::set_img_height(::google::protobuf::int32 value) {
  
  img_height_ = value;
  // @@protoc_insertion_point(field_set:xsproto.planner.VehicleResultViewer.img_height)
}

// .xsproto.planner.ChannelType pixel_channel = 4;
inline void VehicleResultViewer::clear_pixel_channel() {
  pixel_channel_ = 0;
}
inline ::xsproto::planner::ChannelType VehicleResultViewer::pixel_channel() const {
  // @@protoc_insertion_point(field_get:xsproto.planner.VehicleResultViewer.pixel_channel)
  return static_cast< ::xsproto::planner::ChannelType >(pixel_channel_);
}
inline void VehicleResultViewer::set_pixel_channel(::xsproto::planner::ChannelType value) {
  
  pixel_channel_ = value;
  // @@protoc_insertion_point(field_set:xsproto.planner.VehicleResultViewer.pixel_channel)
}

// uint32 img_data_rgb = 5;
inline void VehicleResultViewer::clear_img_data_rgb() {
  img_data_rgb_ = 0u;
}
inline ::google::protobuf::uint32 VehicleResultViewer::img_data_rgb() const {
  // @@protoc_insertion_point(field_get:xsproto.planner.VehicleResultViewer.img_data_rgb)
  return img_data_rgb_;
}
inline void VehicleResultViewer::set_img_data_rgb(::google::protobuf::uint32 value) {
  
  img_data_rgb_ = value;
  // @@protoc_insertion_point(field_set:xsproto.planner.VehicleResultViewer.img_data_rgb)
}

// -------------------------------------------------------------------

// OcvMatInfo

// int32 rows = 1;
inline void OcvMatInfo::clear_rows() {
  rows_ = 0;
}
inline ::google::protobuf::int32 OcvMatInfo::rows() const {
  // @@protoc_insertion_point(field_get:xsproto.planner.OcvMatInfo.rows)
  return rows_;
}
inline void OcvMatInfo::set_rows(::google::protobuf::int32 value) {
  
  rows_ = value;
  // @@protoc_insertion_point(field_set:xsproto.planner.OcvMatInfo.rows)
}

// int32 cols = 2;
inline void OcvMatInfo::clear_cols() {
  cols_ = 0;
}
inline ::google::protobuf::int32 OcvMatInfo::cols() const {
  // @@protoc_insertion_point(field_get:xsproto.planner.OcvMatInfo.cols)
  return cols_;
}
inline void OcvMatInfo::set_cols(::google::protobuf::int32 value) {
  
  cols_ = value;
  // @@protoc_insertion_point(field_set:xsproto.planner.OcvMatInfo.cols)
}

// int32 type = 3;
inline void OcvMatInfo::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 OcvMatInfo::type() const {
  // @@protoc_insertion_point(field_get:xsproto.planner.OcvMatInfo.type)
  return type_;
}
inline void OcvMatInfo::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.planner.OcvMatInfo.type)
}

// int32 size = 4;
inline void OcvMatInfo::clear_size() {
  size_ = 0;
}
inline ::google::protobuf::int32 OcvMatInfo::size() const {
  // @@protoc_insertion_point(field_get:xsproto.planner.OcvMatInfo.size)
  return size_;
}
inline void OcvMatInfo::set_size(::google::protobuf::int32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:xsproto.planner.OcvMatInfo.size)
}

// bytes data = 5;
inline void OcvMatInfo::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OcvMatInfo::data() const {
  // @@protoc_insertion_point(field_get:xsproto.planner.OcvMatInfo.data)
  return data_.GetNoArena();
}
inline void OcvMatInfo::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.planner.OcvMatInfo.data)
}
#if LANG_CXX11
inline void OcvMatInfo::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.planner.OcvMatInfo.data)
}
#endif
inline void OcvMatInfo::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.planner.OcvMatInfo.data)
}
inline void OcvMatInfo::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.planner.OcvMatInfo.data)
}
inline ::std::string* OcvMatInfo::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.planner.OcvMatInfo.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OcvMatInfo::release_data() {
  // @@protoc_insertion_point(field_release:xsproto.planner.OcvMatInfo.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OcvMatInfo::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:xsproto.planner.OcvMatInfo.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planner
}  // namespace xsproto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::xsproto::planner::ChannelType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::planner::ChannelType>() {
  return ::xsproto::planner::ChannelType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_planner_2fvehicle_5fresult_5fviewer_2eproto__INCLUDED
