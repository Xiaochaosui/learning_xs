// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hdmap/local_hdmap_ex.proto

#ifndef PROTOBUF_hdmap_2flocal_5fhdmap_5fex_2eproto__INCLUDED
#define PROTOBUF_hdmap_2flocal_5fhdmap_5fex_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "globalpath/task_list.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[24];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsPointImpl();
void InitDefaultsPoint();
void InitDefaultsLinestringImpl();
void InitDefaultsLinestring();
void InitDefaultsLaneImpl();
void InitDefaultsLane();
void InitDefaultsRoadSectionImpl();
void InitDefaultsRoadSection();
void InitDefaultsRoadImpl();
void InitDefaultsRoad();
void InitDefaultsObserveLaneImpl();
void InitDefaultsObserveLane();
void InitDefaultsObserveAreaImpl();
void InitDefaultsObserveArea();
void InitDefaultsTrafficLightGroupImpl();
void InitDefaultsTrafficLightGroup();
void InitDefaultsTrafficLightPoleImpl();
void InitDefaultsTrafficLightPole();
void InitDefaultsIntersectedLaneImpl();
void InitDefaultsIntersectedLane();
void InitDefaultsLaneInJunctionImpl();
void InitDefaultsLaneInJunction();
void InitDefaultsJunctionImpl();
void InitDefaultsJunction();
void InitDefaultsAreaGapImpl();
void InitDefaultsAreaGap();
void InitDefaultsAreaImpl();
void InitDefaultsArea();
void InitDefaultsObstacleImpl();
void InitDefaultsObstacle();
void InitDefaultsPedestrianCrossingImpl();
void InitDefaultsPedestrianCrossing();
void InitDefaultsParkingSpaceImpl();
void InitDefaultsParkingSpace();
void InitDefaultsConcavityImpl();
void InitDefaultsConcavity();
void InitDefaultsAlleyImpl();
void InitDefaultsAlley();
void InitDefaultsPassableAreaImpl();
void InitDefaultsPassableArea();
void InitDefaultsNoObstacleAreaImpl();
void InitDefaultsNoObstacleArea();
void InitDefaultsWaitAreaImpl();
void InitDefaultsWaitArea();
void InitDefaultsStoplineImpl();
void InitDefaultsStopline();
void InitDefaultsLocalHDMapExImpl();
void InitDefaultsLocalHDMapEx();
inline void InitDefaults() {
  InitDefaultsPoint();
  InitDefaultsLinestring();
  InitDefaultsLane();
  InitDefaultsRoadSection();
  InitDefaultsRoad();
  InitDefaultsObserveLane();
  InitDefaultsObserveArea();
  InitDefaultsTrafficLightGroup();
  InitDefaultsTrafficLightPole();
  InitDefaultsIntersectedLane();
  InitDefaultsLaneInJunction();
  InitDefaultsJunction();
  InitDefaultsAreaGap();
  InitDefaultsArea();
  InitDefaultsObstacle();
  InitDefaultsPedestrianCrossing();
  InitDefaultsParkingSpace();
  InitDefaultsConcavity();
  InitDefaultsAlley();
  InitDefaultsPassableArea();
  InitDefaultsNoObstacleArea();
  InitDefaultsWaitArea();
  InitDefaultsStopline();
  InitDefaultsLocalHDMapEx();
}
}  // namespace protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto
namespace xsproto {
namespace hdmap {
class Alley;
class AlleyDefaultTypeInternal;
extern AlleyDefaultTypeInternal _Alley_default_instance_;
class Area;
class AreaDefaultTypeInternal;
extern AreaDefaultTypeInternal _Area_default_instance_;
class AreaGap;
class AreaGapDefaultTypeInternal;
extern AreaGapDefaultTypeInternal _AreaGap_default_instance_;
class Concavity;
class ConcavityDefaultTypeInternal;
extern ConcavityDefaultTypeInternal _Concavity_default_instance_;
class IntersectedLane;
class IntersectedLaneDefaultTypeInternal;
extern IntersectedLaneDefaultTypeInternal _IntersectedLane_default_instance_;
class Junction;
class JunctionDefaultTypeInternal;
extern JunctionDefaultTypeInternal _Junction_default_instance_;
class Lane;
class LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class LaneInJunction;
class LaneInJunctionDefaultTypeInternal;
extern LaneInJunctionDefaultTypeInternal _LaneInJunction_default_instance_;
class Linestring;
class LinestringDefaultTypeInternal;
extern LinestringDefaultTypeInternal _Linestring_default_instance_;
class LocalHDMapEx;
class LocalHDMapExDefaultTypeInternal;
extern LocalHDMapExDefaultTypeInternal _LocalHDMapEx_default_instance_;
class NoObstacleArea;
class NoObstacleAreaDefaultTypeInternal;
extern NoObstacleAreaDefaultTypeInternal _NoObstacleArea_default_instance_;
class ObserveArea;
class ObserveAreaDefaultTypeInternal;
extern ObserveAreaDefaultTypeInternal _ObserveArea_default_instance_;
class ObserveLane;
class ObserveLaneDefaultTypeInternal;
extern ObserveLaneDefaultTypeInternal _ObserveLane_default_instance_;
class Obstacle;
class ObstacleDefaultTypeInternal;
extern ObstacleDefaultTypeInternal _Obstacle_default_instance_;
class ParkingSpace;
class ParkingSpaceDefaultTypeInternal;
extern ParkingSpaceDefaultTypeInternal _ParkingSpace_default_instance_;
class PassableArea;
class PassableAreaDefaultTypeInternal;
extern PassableAreaDefaultTypeInternal _PassableArea_default_instance_;
class PedestrianCrossing;
class PedestrianCrossingDefaultTypeInternal;
extern PedestrianCrossingDefaultTypeInternal _PedestrianCrossing_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Road;
class RoadDefaultTypeInternal;
extern RoadDefaultTypeInternal _Road_default_instance_;
class RoadSection;
class RoadSectionDefaultTypeInternal;
extern RoadSectionDefaultTypeInternal _RoadSection_default_instance_;
class Stopline;
class StoplineDefaultTypeInternal;
extern StoplineDefaultTypeInternal _Stopline_default_instance_;
class TrafficLightGroup;
class TrafficLightGroupDefaultTypeInternal;
extern TrafficLightGroupDefaultTypeInternal _TrafficLightGroup_default_instance_;
class TrafficLightPole;
class TrafficLightPoleDefaultTypeInternal;
extern TrafficLightPoleDefaultTypeInternal _TrafficLightPole_default_instance_;
class WaitArea;
class WaitAreaDefaultTypeInternal;
extern WaitAreaDefaultTypeInternal _WaitArea_default_instance_;
}  // namespace hdmap
}  // namespace xsproto
namespace xsproto {
namespace hdmap {

enum Lane_LaneChangeType {
  Lane_LaneChangeType_LCT_FORBID = 0,
  Lane_LaneChangeType_LCT_ALLOW = 1,
  Lane_LaneChangeType_LCT_TMP_ALLOW = 2,
  Lane_LaneChangeType_Lane_LaneChangeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Lane_LaneChangeType_Lane_LaneChangeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Lane_LaneChangeType_IsValid(int value);
const Lane_LaneChangeType Lane_LaneChangeType_LaneChangeType_MIN = Lane_LaneChangeType_LCT_FORBID;
const Lane_LaneChangeType Lane_LaneChangeType_LaneChangeType_MAX = Lane_LaneChangeType_LCT_TMP_ALLOW;
const int Lane_LaneChangeType_LaneChangeType_ARRAYSIZE = Lane_LaneChangeType_LaneChangeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Lane_LaneChangeType_descriptor();
inline const ::std::string& Lane_LaneChangeType_Name(Lane_LaneChangeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Lane_LaneChangeType_descriptor(), value);
}
inline bool Lane_LaneChangeType_Parse(
    const ::std::string& name, Lane_LaneChangeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Lane_LaneChangeType>(
    Lane_LaneChangeType_descriptor(), name, value);
}
enum AreaGap_GapType {
  AreaGap_GapType_GT_ENTRANCE = 0,
  AreaGap_GapType_GT_EXIT = 1,
  AreaGap_GapType_GT_BOTH = 2,
  AreaGap_GapType_AreaGap_GapType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AreaGap_GapType_AreaGap_GapType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AreaGap_GapType_IsValid(int value);
const AreaGap_GapType AreaGap_GapType_GapType_MIN = AreaGap_GapType_GT_ENTRANCE;
const AreaGap_GapType AreaGap_GapType_GapType_MAX = AreaGap_GapType_GT_BOTH;
const int AreaGap_GapType_GapType_ARRAYSIZE = AreaGap_GapType_GapType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AreaGap_GapType_descriptor();
inline const ::std::string& AreaGap_GapType_Name(AreaGap_GapType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AreaGap_GapType_descriptor(), value);
}
inline bool AreaGap_GapType_Parse(
    const ::std::string& name, AreaGap_GapType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AreaGap_GapType>(
    AreaGap_GapType_descriptor(), name, value);
}
enum PassRule {
  RED_PASS = 0,
  GREEN_PASS = 1,
  PassRule_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PassRule_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PassRule_IsValid(int value);
const PassRule PassRule_MIN = RED_PASS;
const PassRule PassRule_MAX = GREEN_PASS;
const int PassRule_ARRAYSIZE = PassRule_MAX + 1;

const ::google::protobuf::EnumDescriptor* PassRule_descriptor();
inline const ::std::string& PassRule_Name(PassRule value) {
  return ::google::protobuf::internal::NameOfEnum(
    PassRule_descriptor(), value);
}
inline bool PassRule_Parse(
    const ::std::string& name, PassRule* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PassRule>(
    PassRule_descriptor(), name, value);
}
enum PassDirection {
  PD_LEFT = 0,
  PD_RIGHT = 1,
  PD_FORWARD = 2,
  PD_UTURN = 3,
  PassDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PassDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PassDirection_IsValid(int value);
const PassDirection PassDirection_MIN = PD_LEFT;
const PassDirection PassDirection_MAX = PD_UTURN;
const int PassDirection_ARRAYSIZE = PassDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* PassDirection_descriptor();
inline const ::std::string& PassDirection_Name(PassDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    PassDirection_descriptor(), value);
}
inline bool PassDirection_Parse(
    const ::std::string& name, PassDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PassDirection>(
    PassDirection_descriptor(), name, value);
}
// ===================================================================

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const PROTOBUF_FINAL { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // int64 id = 4;
  void clear_id();
  static const int kIdFieldNumber = 4;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.Point)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double z_;
  ::google::protobuf::int64 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsPointImpl();
};
// -------------------------------------------------------------------

class Linestring : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.Linestring) */ {
 public:
  Linestring();
  virtual ~Linestring();

  Linestring(const Linestring& from);

  inline Linestring& operator=(const Linestring& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Linestring(Linestring&& from) noexcept
    : Linestring() {
    *this = ::std::move(from);
  }

  inline Linestring& operator=(Linestring&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Linestring& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Linestring* internal_default_instance() {
    return reinterpret_cast<const Linestring*>(
               &_Linestring_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Linestring* other);
  friend void swap(Linestring& a, Linestring& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Linestring* New() const PROTOBUF_FINAL { return New(NULL); }

  Linestring* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Linestring& from);
  void MergeFrom(const Linestring& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Linestring* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.hdmap.Point points = 2;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 2;
  const ::xsproto::hdmap::Point& points(int index) const;
  ::xsproto::hdmap::Point* mutable_points(int index);
  ::xsproto::hdmap::Point* add_points();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Point >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Point >&
      points() const;

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.Linestring)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Point > points_;
  ::google::protobuf::int64 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsLinestringImpl();
};
// -------------------------------------------------------------------

class Lane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.Lane) */ {
 public:
  Lane();
  virtual ~Lane();

  Lane(const Lane& from);

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(Lane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Lane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Lane* other);
  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Lane* New() const PROTOBUF_FINAL { return New(NULL); }

  Lane* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Lane& from);
  void MergeFrom(const Lane& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Lane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Lane_LaneChangeType LaneChangeType;
  static const LaneChangeType LCT_FORBID =
    Lane_LaneChangeType_LCT_FORBID;
  static const LaneChangeType LCT_ALLOW =
    Lane_LaneChangeType_LCT_ALLOW;
  static const LaneChangeType LCT_TMP_ALLOW =
    Lane_LaneChangeType_LCT_TMP_ALLOW;
  static inline bool LaneChangeType_IsValid(int value) {
    return Lane_LaneChangeType_IsValid(value);
  }
  static const LaneChangeType LaneChangeType_MIN =
    Lane_LaneChangeType_LaneChangeType_MIN;
  static const LaneChangeType LaneChangeType_MAX =
    Lane_LaneChangeType_LaneChangeType_MAX;
  static const int LaneChangeType_ARRAYSIZE =
    Lane_LaneChangeType_LaneChangeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneChangeType_descriptor() {
    return Lane_LaneChangeType_descriptor();
  }
  static inline const ::std::string& LaneChangeType_Name(LaneChangeType value) {
    return Lane_LaneChangeType_Name(value);
  }
  static inline bool LaneChangeType_Parse(const ::std::string& name,
      LaneChangeType* value) {
    return Lane_LaneChangeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int64 pre_lane_id = 8;
  int pre_lane_id_size() const;
  void clear_pre_lane_id();
  static const int kPreLaneIdFieldNumber = 8;
  ::google::protobuf::int64 pre_lane_id(int index) const;
  void set_pre_lane_id(int index, ::google::protobuf::int64 value);
  void add_pre_lane_id(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      pre_lane_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_pre_lane_id();

  // repeated int64 post_lane_id = 9;
  int post_lane_id_size() const;
  void clear_post_lane_id();
  static const int kPostLaneIdFieldNumber = 9;
  ::google::protobuf::int64 post_lane_id(int index) const;
  void set_post_lane_id(int index, ::google::protobuf::int64 value);
  void add_post_lane_id(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      post_lane_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_post_lane_id();

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 left_boundary_id = 2;
  void clear_left_boundary_id();
  static const int kLeftBoundaryIdFieldNumber = 2;
  ::google::protobuf::int64 left_boundary_id() const;
  void set_left_boundary_id(::google::protobuf::int64 value);

  // int64 right_boundary_id = 3;
  void clear_right_boundary_id();
  static const int kRightBoundaryIdFieldNumber = 3;
  ::google::protobuf::int64 right_boundary_id() const;
  void set_right_boundary_id(::google::protobuf::int64 value);

  // int64 center_line_id = 4;
  void clear_center_line_id();
  static const int kCenterLineIdFieldNumber = 4;
  ::google::protobuf::int64 center_line_id() const;
  void set_center_line_id(::google::protobuf::int64 value);

  // int64 left_lane_id = 6;
  void clear_left_lane_id();
  static const int kLeftLaneIdFieldNumber = 6;
  ::google::protobuf::int64 left_lane_id() const;
  void set_left_lane_id(::google::protobuf::int64 value);

  // int64 right_lane_id = 7;
  void clear_right_lane_id();
  static const int kRightLaneIdFieldNumber = 7;
  ::google::protobuf::int64 right_lane_id() const;
  void set_right_lane_id(::google::protobuf::int64 value);

  // int32 index = 5;
  void clear_index();
  static const int kIndexFieldNumber = 5;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // .xsproto.hdmap.Lane.LaneChangeType left_lane_change = 10;
  void clear_left_lane_change();
  static const int kLeftLaneChangeFieldNumber = 10;
  ::xsproto::hdmap::Lane_LaneChangeType left_lane_change() const;
  void set_left_lane_change(::xsproto::hdmap::Lane_LaneChangeType value);

  // .xsproto.hdmap.Lane.LaneChangeType right_lane_change = 11;
  void clear_right_lane_change();
  static const int kRightLaneChangeFieldNumber = 11;
  ::xsproto::hdmap::Lane_LaneChangeType right_lane_change() const;
  void set_right_lane_change(::xsproto::hdmap::Lane_LaneChangeType value);

  // int32 participant_mask = 12;
  void clear_participant_mask();
  static const int kParticipantMaskFieldNumber = 12;
  ::google::protobuf::int32 participant_mask() const;
  void set_participant_mask(::google::protobuf::int32 value);

  // double max_speed_limit = 13;
  void clear_max_speed_limit();
  static const int kMaxSpeedLimitFieldNumber = 13;
  double max_speed_limit() const;
  void set_max_speed_limit(double value);

  // double min_speed_limit = 14;
  void clear_min_speed_limit();
  static const int kMinSpeedLimitFieldNumber = 14;
  double min_speed_limit() const;
  void set_min_speed_limit(double value);

  // int32 direction = 15;
  void clear_direction();
  static const int kDirectionFieldNumber = 15;
  ::google::protobuf::int32 direction() const;
  void set_direction(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.Lane)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > pre_lane_id_;
  mutable int _pre_lane_id_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > post_lane_id_;
  mutable int _post_lane_id_cached_byte_size_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 left_boundary_id_;
  ::google::protobuf::int64 right_boundary_id_;
  ::google::protobuf::int64 center_line_id_;
  ::google::protobuf::int64 left_lane_id_;
  ::google::protobuf::int64 right_lane_id_;
  ::google::protobuf::int32 index_;
  int left_lane_change_;
  int right_lane_change_;
  ::google::protobuf::int32 participant_mask_;
  double max_speed_limit_;
  double min_speed_limit_;
  ::google::protobuf::int32 direction_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsLaneImpl();
};
// -------------------------------------------------------------------

class RoadSection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.RoadSection) */ {
 public:
  RoadSection();
  virtual ~RoadSection();

  RoadSection(const RoadSection& from);

  inline RoadSection& operator=(const RoadSection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadSection(RoadSection&& from) noexcept
    : RoadSection() {
    *this = ::std::move(from);
  }

  inline RoadSection& operator=(RoadSection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadSection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadSection* internal_default_instance() {
    return reinterpret_cast<const RoadSection*>(
               &_RoadSection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RoadSection* other);
  friend void swap(RoadSection& a, RoadSection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadSection* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadSection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadSection& from);
  void MergeFrom(const RoadSection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadSection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 lanes = 5;
  int lanes_size() const;
  void clear_lanes();
  static const int kLanesFieldNumber = 5;
  ::google::protobuf::int64 lanes(int index) const;
  void set_lanes(int index, ::google::protobuf::int64 value);
  void add_lanes(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      lanes() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_lanes();

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 pre_section_id = 3;
  void clear_pre_section_id();
  static const int kPreSectionIdFieldNumber = 3;
  ::google::protobuf::int64 pre_section_id() const;
  void set_pre_section_id(::google::protobuf::int64 value);

  // int64 post_section_id = 4;
  void clear_post_section_id();
  static const int kPostSectionIdFieldNumber = 4;
  ::google::protobuf::int64 post_section_id() const;
  void set_post_section_id(::google::protobuf::int64 value);

  // int32 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.RoadSection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > lanes_;
  mutable int _lanes_cached_byte_size_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 pre_section_id_;
  ::google::protobuf::int64 post_section_id_;
  ::google::protobuf::int32 index_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsRoadSectionImpl();
};
// -------------------------------------------------------------------

class Road : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.Road) */ {
 public:
  Road();
  virtual ~Road();

  Road(const Road& from);

  inline Road& operator=(const Road& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Road(Road&& from) noexcept
    : Road() {
    *this = ::std::move(from);
  }

  inline Road& operator=(Road&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Road& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Road* internal_default_instance() {
    return reinterpret_cast<const Road*>(
               &_Road_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Road* other);
  friend void swap(Road& a, Road& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Road* New() const PROTOBUF_FINAL { return New(NULL); }

  Road* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Road& from);
  void MergeFrom(const Road& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Road* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 pre_road_id = 2;
  int pre_road_id_size() const;
  void clear_pre_road_id();
  static const int kPreRoadIdFieldNumber = 2;
  ::google::protobuf::int64 pre_road_id(int index) const;
  void set_pre_road_id(int index, ::google::protobuf::int64 value);
  void add_pre_road_id(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      pre_road_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_pre_road_id();

  // repeated int64 post_road_id = 3;
  int post_road_id_size() const;
  void clear_post_road_id();
  static const int kPostRoadIdFieldNumber = 3;
  ::google::protobuf::int64 post_road_id(int index) const;
  void set_post_road_id(int index, ::google::protobuf::int64 value);
  void add_post_road_id(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      post_road_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_post_road_id();

  // repeated .xsproto.hdmap.RoadSection road_sections = 4;
  int road_sections_size() const;
  void clear_road_sections();
  static const int kRoadSectionsFieldNumber = 4;
  const ::xsproto::hdmap::RoadSection& road_sections(int index) const;
  ::xsproto::hdmap::RoadSection* mutable_road_sections(int index);
  ::xsproto::hdmap::RoadSection* add_road_sections();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::RoadSection >*
      mutable_road_sections();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::RoadSection >&
      road_sections() const;

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 junction_id = 5;
  void clear_junction_id();
  static const int kJunctionIdFieldNumber = 5;
  ::google::protobuf::int64 junction_id() const;
  void set_junction_id(::google::protobuf::int64 value);

  // double length = 6;
  void clear_length();
  static const int kLengthFieldNumber = 6;
  double length() const;
  void set_length(double value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.Road)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > pre_road_id_;
  mutable int _pre_road_id_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > post_road_id_;
  mutable int _post_road_id_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::RoadSection > road_sections_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 junction_id_;
  double length_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsRoadImpl();
};
// -------------------------------------------------------------------

class ObserveLane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.ObserveLane) */ {
 public:
  ObserveLane();
  virtual ~ObserveLane();

  ObserveLane(const ObserveLane& from);

  inline ObserveLane& operator=(const ObserveLane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObserveLane(ObserveLane&& from) noexcept
    : ObserveLane() {
    *this = ::std::move(from);
  }

  inline ObserveLane& operator=(ObserveLane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObserveLane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObserveLane* internal_default_instance() {
    return reinterpret_cast<const ObserveLane*>(
               &_ObserveLane_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ObserveLane* other);
  friend void swap(ObserveLane& a, ObserveLane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObserveLane* New() const PROTOBUF_FINAL { return New(NULL); }

  ObserveLane* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObserveLane& from);
  void MergeFrom(const ObserveLane& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObserveLane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 lane_id = 1;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 1;
  ::google::protobuf::int64 lane_id() const;
  void set_lane_id(::google::protobuf::int64 value);

  // .xsproto.hdmap.PassDirection pass_direction = 2;
  void clear_pass_direction();
  static const int kPassDirectionFieldNumber = 2;
  ::xsproto::hdmap::PassDirection pass_direction() const;
  void set_pass_direction(::xsproto::hdmap::PassDirection value);

  // .xsproto.hdmap.PassRule pass_rule = 3;
  void clear_pass_rule();
  static const int kPassRuleFieldNumber = 3;
  ::xsproto::hdmap::PassRule pass_rule() const;
  void set_pass_rule(::xsproto::hdmap::PassRule value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.ObserveLane)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 lane_id_;
  int pass_direction_;
  int pass_rule_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsObserveLaneImpl();
};
// -------------------------------------------------------------------

class ObserveArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.ObserveArea) */ {
 public:
  ObserveArea();
  virtual ~ObserveArea();

  ObserveArea(const ObserveArea& from);

  inline ObserveArea& operator=(const ObserveArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObserveArea(ObserveArea&& from) noexcept
    : ObserveArea() {
    *this = ::std::move(from);
  }

  inline ObserveArea& operator=(ObserveArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObserveArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObserveArea* internal_default_instance() {
    return reinterpret_cast<const ObserveArea*>(
               &_ObserveArea_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ObserveArea* other);
  friend void swap(ObserveArea& a, ObserveArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObserveArea* New() const PROTOBUF_FINAL { return New(NULL); }

  ObserveArea* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObserveArea& from);
  void MergeFrom(const ObserveArea& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObserveArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 area_id = 1;
  void clear_area_id();
  static const int kAreaIdFieldNumber = 1;
  ::google::protobuf::int64 area_id() const;
  void set_area_id(::google::protobuf::int64 value);

  // .xsproto.hdmap.PassDirection enter_pass_direction = 2;
  void clear_enter_pass_direction();
  static const int kEnterPassDirectionFieldNumber = 2;
  ::xsproto::hdmap::PassDirection enter_pass_direction() const;
  void set_enter_pass_direction(::xsproto::hdmap::PassDirection value);

  // .xsproto.hdmap.PassRule enter_pass_rule = 3;
  void clear_enter_pass_rule();
  static const int kEnterPassRuleFieldNumber = 3;
  ::xsproto::hdmap::PassRule enter_pass_rule() const;
  void set_enter_pass_rule(::xsproto::hdmap::PassRule value);

  // .xsproto.hdmap.PassDirection exit_pass_direction = 4;
  void clear_exit_pass_direction();
  static const int kExitPassDirectionFieldNumber = 4;
  ::xsproto::hdmap::PassDirection exit_pass_direction() const;
  void set_exit_pass_direction(::xsproto::hdmap::PassDirection value);

  // .xsproto.hdmap.PassRule exit_pass_rule = 5;
  void clear_exit_pass_rule();
  static const int kExitPassRuleFieldNumber = 5;
  ::xsproto::hdmap::PassRule exit_pass_rule() const;
  void set_exit_pass_rule(::xsproto::hdmap::PassRule value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.ObserveArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 area_id_;
  int enter_pass_direction_;
  int enter_pass_rule_;
  int exit_pass_direction_;
  int exit_pass_rule_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsObserveAreaImpl();
};
// -------------------------------------------------------------------

class TrafficLightGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.TrafficLightGroup) */ {
 public:
  TrafficLightGroup();
  virtual ~TrafficLightGroup();

  TrafficLightGroup(const TrafficLightGroup& from);

  inline TrafficLightGroup& operator=(const TrafficLightGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightGroup(TrafficLightGroup&& from) noexcept
    : TrafficLightGroup() {
    *this = ::std::move(from);
  }

  inline TrafficLightGroup& operator=(TrafficLightGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightGroup* internal_default_instance() {
    return reinterpret_cast<const TrafficLightGroup*>(
               &_TrafficLightGroup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(TrafficLightGroup* other);
  friend void swap(TrafficLightGroup& a, TrafficLightGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightGroup* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightGroup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightGroup& from);
  void MergeFrom(const TrafficLightGroup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.hdmap.ObserveLane observe_lane = 2;
  int observe_lane_size() const;
  void clear_observe_lane();
  static const int kObserveLaneFieldNumber = 2;
  const ::xsproto::hdmap::ObserveLane& observe_lane(int index) const;
  ::xsproto::hdmap::ObserveLane* mutable_observe_lane(int index);
  ::xsproto::hdmap::ObserveLane* add_observe_lane();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ObserveLane >*
      mutable_observe_lane();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ObserveLane >&
      observe_lane() const;

  // repeated .xsproto.hdmap.ObserveArea observe_area = 3;
  int observe_area_size() const;
  void clear_observe_area();
  static const int kObserveAreaFieldNumber = 3;
  const ::xsproto::hdmap::ObserveArea& observe_area(int index) const;
  ::xsproto::hdmap::ObserveArea* mutable_observe_area(int index);
  ::xsproto::hdmap::ObserveArea* add_observe_area();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ObserveArea >*
      mutable_observe_area();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ObserveArea >&
      observe_area() const;

  // .xsproto.hdmap.Point position = 9;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 9;
  const ::xsproto::hdmap::Point& position() const;
  ::xsproto::hdmap::Point* release_position();
  ::xsproto::hdmap::Point* mutable_position();
  void set_allocated_position(::xsproto::hdmap::Point* position);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int32 has_left = 4;
  void clear_has_left();
  static const int kHasLeftFieldNumber = 4;
  ::google::protobuf::int32 has_left() const;
  void set_has_left(::google::protobuf::int32 value);

  // int32 has_right = 5;
  void clear_has_right();
  static const int kHasRightFieldNumber = 5;
  ::google::protobuf::int32 has_right() const;
  void set_has_right(::google::protobuf::int32 value);

  // int32 has_forward = 6;
  void clear_has_forward();
  static const int kHasForwardFieldNumber = 6;
  ::google::protobuf::int32 has_forward() const;
  void set_has_forward(::google::protobuf::int32 value);

  // int32 has_uturn = 7;
  void clear_has_uturn();
  static const int kHasUturnFieldNumber = 7;
  ::google::protobuf::int32 has_uturn() const;
  void set_has_uturn(::google::protobuf::int32 value);

  // int32 is_circle = 8;
  void clear_is_circle();
  static const int kIsCircleFieldNumber = 8;
  ::google::protobuf::int32 is_circle() const;
  void set_is_circle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.TrafficLightGroup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ObserveLane > observe_lane_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ObserveArea > observe_area_;
  ::xsproto::hdmap::Point* position_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 has_left_;
  ::google::protobuf::int32 has_right_;
  ::google::protobuf::int32 has_forward_;
  ::google::protobuf::int32 has_uturn_;
  ::google::protobuf::int32 is_circle_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsTrafficLightGroupImpl();
};
// -------------------------------------------------------------------

class TrafficLightPole : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.TrafficLightPole) */ {
 public:
  TrafficLightPole();
  virtual ~TrafficLightPole();

  TrafficLightPole(const TrafficLightPole& from);

  inline TrafficLightPole& operator=(const TrafficLightPole& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightPole(TrafficLightPole&& from) noexcept
    : TrafficLightPole() {
    *this = ::std::move(from);
  }

  inline TrafficLightPole& operator=(TrafficLightPole&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightPole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightPole* internal_default_instance() {
    return reinterpret_cast<const TrafficLightPole*>(
               &_TrafficLightPole_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(TrafficLightPole* other);
  friend void swap(TrafficLightPole& a, TrafficLightPole& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightPole* New() const PROTOBUF_FINAL { return New(NULL); }

  TrafficLightPole* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrafficLightPole& from);
  void MergeFrom(const TrafficLightPole& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrafficLightPole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.hdmap.TrafficLightGroup traffic_lights = 2;
  int traffic_lights_size() const;
  void clear_traffic_lights();
  static const int kTrafficLightsFieldNumber = 2;
  const ::xsproto::hdmap::TrafficLightGroup& traffic_lights(int index) const;
  ::xsproto::hdmap::TrafficLightGroup* mutable_traffic_lights(int index);
  ::xsproto::hdmap::TrafficLightGroup* add_traffic_lights();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::TrafficLightGroup >*
      mutable_traffic_lights();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::TrafficLightGroup >&
      traffic_lights() const;

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.TrafficLightPole)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::TrafficLightGroup > traffic_lights_;
  ::google::protobuf::int64 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsTrafficLightPoleImpl();
};
// -------------------------------------------------------------------

class IntersectedLane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.IntersectedLane) */ {
 public:
  IntersectedLane();
  virtual ~IntersectedLane();

  IntersectedLane(const IntersectedLane& from);

  inline IntersectedLane& operator=(const IntersectedLane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IntersectedLane(IntersectedLane&& from) noexcept
    : IntersectedLane() {
    *this = ::std::move(from);
  }

  inline IntersectedLane& operator=(IntersectedLane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IntersectedLane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntersectedLane* internal_default_instance() {
    return reinterpret_cast<const IntersectedLane*>(
               &_IntersectedLane_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(IntersectedLane* other);
  friend void swap(IntersectedLane& a, IntersectedLane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntersectedLane* New() const PROTOBUF_FINAL { return New(NULL); }

  IntersectedLane* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IntersectedLane& from);
  void MergeFrom(const IntersectedLane& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IntersectedLane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 lane_id = 1;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 1;
  ::google::protobuf::int64 lane_id() const;
  void set_lane_id(::google::protobuf::int64 value);

  // bool yield = 2;
  void clear_yield();
  static const int kYieldFieldNumber = 2;
  bool yield() const;
  void set_yield(bool value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.IntersectedLane)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 lane_id_;
  bool yield_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsIntersectedLaneImpl();
};
// -------------------------------------------------------------------

class LaneInJunction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.LaneInJunction) */ {
 public:
  LaneInJunction();
  virtual ~LaneInJunction();

  LaneInJunction(const LaneInJunction& from);

  inline LaneInJunction& operator=(const LaneInJunction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneInJunction(LaneInJunction&& from) noexcept
    : LaneInJunction() {
    *this = ::std::move(from);
  }

  inline LaneInJunction& operator=(LaneInJunction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneInJunction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneInJunction* internal_default_instance() {
    return reinterpret_cast<const LaneInJunction*>(
               &_LaneInJunction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(LaneInJunction* other);
  friend void swap(LaneInJunction& a, LaneInJunction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneInJunction* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneInJunction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneInJunction& from);
  void MergeFrom(const LaneInJunction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneInJunction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.hdmap.IntersectedLane interseced_lanes = 2;
  int interseced_lanes_size() const;
  void clear_interseced_lanes();
  static const int kIntersecedLanesFieldNumber = 2;
  const ::xsproto::hdmap::IntersectedLane& interseced_lanes(int index) const;
  ::xsproto::hdmap::IntersectedLane* mutable_interseced_lanes(int index);
  ::xsproto::hdmap::IntersectedLane* add_interseced_lanes();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::IntersectedLane >*
      mutable_interseced_lanes();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::IntersectedLane >&
      interseced_lanes() const;

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.LaneInJunction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::IntersectedLane > interseced_lanes_;
  ::google::protobuf::int64 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsLaneInJunctionImpl();
};
// -------------------------------------------------------------------

class Junction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.Junction) */ {
 public:
  Junction();
  virtual ~Junction();

  Junction(const Junction& from);

  inline Junction& operator=(const Junction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Junction(Junction&& from) noexcept
    : Junction() {
    *this = ::std::move(from);
  }

  inline Junction& operator=(Junction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Junction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Junction* internal_default_instance() {
    return reinterpret_cast<const Junction*>(
               &_Junction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Junction* other);
  friend void swap(Junction& a, Junction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Junction* New() const PROTOBUF_FINAL { return New(NULL); }

  Junction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Junction& from);
  void MergeFrom(const Junction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Junction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.hdmap.LaneInJunction lanes = 2;
  int lanes_size() const;
  void clear_lanes();
  static const int kLanesFieldNumber = 2;
  const ::xsproto::hdmap::LaneInJunction& lanes(int index) const;
  ::xsproto::hdmap::LaneInJunction* mutable_lanes(int index);
  ::xsproto::hdmap::LaneInJunction* add_lanes();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::LaneInJunction >*
      mutable_lanes();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::LaneInJunction >&
      lanes() const;

  // repeated int64 traffic_light_poles = 3;
  int traffic_light_poles_size() const;
  void clear_traffic_light_poles();
  static const int kTrafficLightPolesFieldNumber = 3;
  ::google::protobuf::int64 traffic_light_poles(int index) const;
  void set_traffic_light_poles(int index, ::google::protobuf::int64 value);
  void add_traffic_light_poles(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      traffic_light_poles() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_traffic_light_poles();

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.Junction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::LaneInJunction > lanes_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > traffic_light_poles_;
  mutable int _traffic_light_poles_cached_byte_size_;
  ::google::protobuf::int64 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsJunctionImpl();
};
// -------------------------------------------------------------------

class AreaGap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.AreaGap) */ {
 public:
  AreaGap();
  virtual ~AreaGap();

  AreaGap(const AreaGap& from);

  inline AreaGap& operator=(const AreaGap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AreaGap(AreaGap&& from) noexcept
    : AreaGap() {
    *this = ::std::move(from);
  }

  inline AreaGap& operator=(AreaGap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AreaGap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AreaGap* internal_default_instance() {
    return reinterpret_cast<const AreaGap*>(
               &_AreaGap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(AreaGap* other);
  friend void swap(AreaGap& a, AreaGap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AreaGap* New() const PROTOBUF_FINAL { return New(NULL); }

  AreaGap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AreaGap& from);
  void MergeFrom(const AreaGap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AreaGap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AreaGap_GapType GapType;
  static const GapType GT_ENTRANCE =
    AreaGap_GapType_GT_ENTRANCE;
  static const GapType GT_EXIT =
    AreaGap_GapType_GT_EXIT;
  static const GapType GT_BOTH =
    AreaGap_GapType_GT_BOTH;
  static inline bool GapType_IsValid(int value) {
    return AreaGap_GapType_IsValid(value);
  }
  static const GapType GapType_MIN =
    AreaGap_GapType_GapType_MIN;
  static const GapType GapType_MAX =
    AreaGap_GapType_GapType_MAX;
  static const int GapType_ARRAYSIZE =
    AreaGap_GapType_GapType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GapType_descriptor() {
    return AreaGap_GapType_descriptor();
  }
  static inline const ::std::string& GapType_Name(GapType value) {
    return AreaGap_GapType_Name(value);
  }
  static inline bool GapType_Parse(const ::std::string& name,
      GapType* value) {
    return AreaGap_GapType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int64 linestring_id = 2;
  void clear_linestring_id();
  static const int kLinestringIdFieldNumber = 2;
  ::google::protobuf::int64 linestring_id() const;
  void set_linestring_id(::google::protobuf::int64 value);

  // .xsproto.hdmap.AreaGap.GapType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::xsproto::hdmap::AreaGap_GapType type() const;
  void set_type(::xsproto::hdmap::AreaGap_GapType value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.AreaGap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 linestring_id_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsAreaGapImpl();
};
// -------------------------------------------------------------------

class Area : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.Area) */ {
 public:
  Area();
  virtual ~Area();

  Area(const Area& from);

  inline Area& operator=(const Area& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Area(Area&& from) noexcept
    : Area() {
    *this = ::std::move(from);
  }

  inline Area& operator=(Area&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Area& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Area* internal_default_instance() {
    return reinterpret_cast<const Area*>(
               &_Area_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Area* other);
  friend void swap(Area& a, Area& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Area* New() const PROTOBUF_FINAL { return New(NULL); }

  Area* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Area& from);
  void MergeFrom(const Area& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Area* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 linestrings = 2;
  int linestrings_size() const;
  void clear_linestrings();
  static const int kLinestringsFieldNumber = 2;
  ::google::protobuf::int64 linestrings(int index) const;
  void set_linestrings(int index, ::google::protobuf::int64 value);
  void add_linestrings(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      linestrings() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_linestrings();

  // repeated .xsproto.hdmap.AreaGap gaps = 4;
  int gaps_size() const;
  void clear_gaps();
  static const int kGapsFieldNumber = 4;
  const ::xsproto::hdmap::AreaGap& gaps(int index) const;
  ::xsproto::hdmap::AreaGap* mutable_gaps(int index);
  ::xsproto::hdmap::AreaGap* add_gaps();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >*
      mutable_gaps();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >&
      gaps() const;

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int32 shape = 3;
  void clear_shape();
  static const int kShapeFieldNumber = 3;
  ::google::protobuf::int32 shape() const;
  void set_shape(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.Area)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > linestrings_;
  mutable int _linestrings_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap > gaps_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 shape_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsAreaImpl();
};
// -------------------------------------------------------------------

class Obstacle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.Obstacle) */ {
 public:
  Obstacle();
  virtual ~Obstacle();

  Obstacle(const Obstacle& from);

  inline Obstacle& operator=(const Obstacle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Obstacle(Obstacle&& from) noexcept
    : Obstacle() {
    *this = ::std::move(from);
  }

  inline Obstacle& operator=(Obstacle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Obstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Obstacle* internal_default_instance() {
    return reinterpret_cast<const Obstacle*>(
               &_Obstacle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Obstacle* other);
  friend void swap(Obstacle& a, Obstacle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Obstacle* New() const PROTOBUF_FINAL { return New(NULL); }

  Obstacle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Obstacle& from);
  void MergeFrom(const Obstacle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Obstacle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 area_id = 3;
  void clear_area_id();
  static const int kAreaIdFieldNumber = 3;
  ::google::protobuf::int64 area_id() const;
  void set_area_id(::google::protobuf::int64 value);

  // int32 type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.Obstacle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 area_id_;
  ::google::protobuf::int32 type_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsObstacleImpl();
};
// -------------------------------------------------------------------

class PedestrianCrossing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.PedestrianCrossing) */ {
 public:
  PedestrianCrossing();
  virtual ~PedestrianCrossing();

  PedestrianCrossing(const PedestrianCrossing& from);

  inline PedestrianCrossing& operator=(const PedestrianCrossing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PedestrianCrossing(PedestrianCrossing&& from) noexcept
    : PedestrianCrossing() {
    *this = ::std::move(from);
  }

  inline PedestrianCrossing& operator=(PedestrianCrossing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PedestrianCrossing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PedestrianCrossing* internal_default_instance() {
    return reinterpret_cast<const PedestrianCrossing*>(
               &_PedestrianCrossing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(PedestrianCrossing* other);
  friend void swap(PedestrianCrossing& a, PedestrianCrossing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PedestrianCrossing* New() const PROTOBUF_FINAL { return New(NULL); }

  PedestrianCrossing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PedestrianCrossing& from);
  void MergeFrom(const PedestrianCrossing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PedestrianCrossing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.hdmap.AreaGap gaps = 2;
  int gaps_size() const;
  void clear_gaps();
  static const int kGapsFieldNumber = 2;
  const ::xsproto::hdmap::AreaGap& gaps(int index) const;
  ::xsproto::hdmap::AreaGap* mutable_gaps(int index);
  ::xsproto::hdmap::AreaGap* add_gaps();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >*
      mutable_gaps();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >&
      gaps() const;

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 area_id = 3;
  void clear_area_id();
  static const int kAreaIdFieldNumber = 3;
  ::google::protobuf::int64 area_id() const;
  void set_area_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.PedestrianCrossing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap > gaps_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 area_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsPedestrianCrossingImpl();
};
// -------------------------------------------------------------------

class ParkingSpace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.ParkingSpace) */ {
 public:
  ParkingSpace();
  virtual ~ParkingSpace();

  ParkingSpace(const ParkingSpace& from);

  inline ParkingSpace& operator=(const ParkingSpace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParkingSpace(ParkingSpace&& from) noexcept
    : ParkingSpace() {
    *this = ::std::move(from);
  }

  inline ParkingSpace& operator=(ParkingSpace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSpace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParkingSpace* internal_default_instance() {
    return reinterpret_cast<const ParkingSpace*>(
               &_ParkingSpace_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(ParkingSpace* other);
  friend void swap(ParkingSpace& a, ParkingSpace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParkingSpace* New() const PROTOBUF_FINAL { return New(NULL); }

  ParkingSpace* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParkingSpace& from);
  void MergeFrom(const ParkingSpace& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParkingSpace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.hdmap.AreaGap gaps = 3;
  int gaps_size() const;
  void clear_gaps();
  static const int kGapsFieldNumber = 3;
  const ::xsproto::hdmap::AreaGap& gaps(int index) const;
  ::xsproto::hdmap::AreaGap* mutable_gaps(int index);
  ::xsproto::hdmap::AreaGap* add_gaps();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >*
      mutable_gaps();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >&
      gaps() const;

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 on_road = 2;
  void clear_on_road();
  static const int kOnRoadFieldNumber = 2;
  ::google::protobuf::int64 on_road() const;
  void set_on_road(::google::protobuf::int64 value);

  // int64 area_id = 4;
  void clear_area_id();
  static const int kAreaIdFieldNumber = 4;
  ::google::protobuf::int64 area_id() const;
  void set_area_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.ParkingSpace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap > gaps_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 on_road_;
  ::google::protobuf::int64 area_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsParkingSpaceImpl();
};
// -------------------------------------------------------------------

class Concavity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.Concavity) */ {
 public:
  Concavity();
  virtual ~Concavity();

  Concavity(const Concavity& from);

  inline Concavity& operator=(const Concavity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Concavity(Concavity&& from) noexcept
    : Concavity() {
    *this = ::std::move(from);
  }

  inline Concavity& operator=(Concavity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Concavity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Concavity* internal_default_instance() {
    return reinterpret_cast<const Concavity*>(
               &_Concavity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(Concavity* other);
  friend void swap(Concavity& a, Concavity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Concavity* New() const PROTOBUF_FINAL { return New(NULL); }

  Concavity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Concavity& from);
  void MergeFrom(const Concavity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Concavity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 area_id = 2;
  void clear_area_id();
  static const int kAreaIdFieldNumber = 2;
  ::google::protobuf::int64 area_id() const;
  void set_area_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.Concavity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 area_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsConcavityImpl();
};
// -------------------------------------------------------------------

class Alley : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.Alley) */ {
 public:
  Alley();
  virtual ~Alley();

  Alley(const Alley& from);

  inline Alley& operator=(const Alley& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Alley(Alley&& from) noexcept
    : Alley() {
    *this = ::std::move(from);
  }

  inline Alley& operator=(Alley&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Alley& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Alley* internal_default_instance() {
    return reinterpret_cast<const Alley*>(
               &_Alley_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(Alley* other);
  friend void swap(Alley& a, Alley& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Alley* New() const PROTOBUF_FINAL { return New(NULL); }

  Alley* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Alley& from);
  void MergeFrom(const Alley& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Alley* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 area_id = 2;
  void clear_area_id();
  static const int kAreaIdFieldNumber = 2;
  ::google::protobuf::int64 area_id() const;
  void set_area_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.Alley)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 area_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsAlleyImpl();
};
// -------------------------------------------------------------------

class PassableArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.PassableArea) */ {
 public:
  PassableArea();
  virtual ~PassableArea();

  PassableArea(const PassableArea& from);

  inline PassableArea& operator=(const PassableArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PassableArea(PassableArea&& from) noexcept
    : PassableArea() {
    *this = ::std::move(from);
  }

  inline PassableArea& operator=(PassableArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PassableArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PassableArea* internal_default_instance() {
    return reinterpret_cast<const PassableArea*>(
               &_PassableArea_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(PassableArea* other);
  friend void swap(PassableArea& a, PassableArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PassableArea* New() const PROTOBUF_FINAL { return New(NULL); }

  PassableArea* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PassableArea& from);
  void MergeFrom(const PassableArea& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PassableArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 area_id = 2;
  void clear_area_id();
  static const int kAreaIdFieldNumber = 2;
  ::google::protobuf::int64 area_id() const;
  void set_area_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.PassableArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 area_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsPassableAreaImpl();
};
// -------------------------------------------------------------------

class NoObstacleArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.NoObstacleArea) */ {
 public:
  NoObstacleArea();
  virtual ~NoObstacleArea();

  NoObstacleArea(const NoObstacleArea& from);

  inline NoObstacleArea& operator=(const NoObstacleArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NoObstacleArea(NoObstacleArea&& from) noexcept
    : NoObstacleArea() {
    *this = ::std::move(from);
  }

  inline NoObstacleArea& operator=(NoObstacleArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NoObstacleArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NoObstacleArea* internal_default_instance() {
    return reinterpret_cast<const NoObstacleArea*>(
               &_NoObstacleArea_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(NoObstacleArea* other);
  friend void swap(NoObstacleArea& a, NoObstacleArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NoObstacleArea* New() const PROTOBUF_FINAL { return New(NULL); }

  NoObstacleArea* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NoObstacleArea& from);
  void MergeFrom(const NoObstacleArea& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NoObstacleArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 area_id = 2;
  void clear_area_id();
  static const int kAreaIdFieldNumber = 2;
  ::google::protobuf::int64 area_id() const;
  void set_area_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.NoObstacleArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 area_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsNoObstacleAreaImpl();
};
// -------------------------------------------------------------------

class WaitArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.WaitArea) */ {
 public:
  WaitArea();
  virtual ~WaitArea();

  WaitArea(const WaitArea& from);

  inline WaitArea& operator=(const WaitArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitArea(WaitArea&& from) noexcept
    : WaitArea() {
    *this = ::std::move(from);
  }

  inline WaitArea& operator=(WaitArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitArea* internal_default_instance() {
    return reinterpret_cast<const WaitArea*>(
               &_WaitArea_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(WaitArea* other);
  friend void swap(WaitArea& a, WaitArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitArea* New() const PROTOBUF_FINAL { return New(NULL); }

  WaitArea* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WaitArea& from);
  void MergeFrom(const WaitArea& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WaitArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.hdmap.AreaGap gaps = 2;
  int gaps_size() const;
  void clear_gaps();
  static const int kGapsFieldNumber = 2;
  const ::xsproto::hdmap::AreaGap& gaps(int index) const;
  ::xsproto::hdmap::AreaGap* mutable_gaps(int index);
  ::xsproto::hdmap::AreaGap* add_gaps();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >*
      mutable_gaps();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >&
      gaps() const;

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 area_id = 3;
  void clear_area_id();
  static const int kAreaIdFieldNumber = 3;
  ::google::protobuf::int64 area_id() const;
  void set_area_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.WaitArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap > gaps_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 area_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsWaitAreaImpl();
};
// -------------------------------------------------------------------

class Stopline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.Stopline) */ {
 public:
  Stopline();
  virtual ~Stopline();

  Stopline(const Stopline& from);

  inline Stopline& operator=(const Stopline& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Stopline(Stopline&& from) noexcept
    : Stopline() {
    *this = ::std::move(from);
  }

  inline Stopline& operator=(Stopline&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stopline& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Stopline* internal_default_instance() {
    return reinterpret_cast<const Stopline*>(
               &_Stopline_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Stopline* other);
  friend void swap(Stopline& a, Stopline& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Stopline* New() const PROTOBUF_FINAL { return New(NULL); }

  Stopline* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Stopline& from);
  void MergeFrom(const Stopline& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Stopline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int64 area_id = 2;
  void clear_area_id();
  static const int kAreaIdFieldNumber = 2;
  ::google::protobuf::int64 area_id() const;
  void set_area_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.Stopline)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 area_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsStoplineImpl();
};
// -------------------------------------------------------------------

class LocalHDMapEx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.LocalHDMapEx) */ {
 public:
  LocalHDMapEx();
  virtual ~LocalHDMapEx();

  LocalHDMapEx(const LocalHDMapEx& from);

  inline LocalHDMapEx& operator=(const LocalHDMapEx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocalHDMapEx(LocalHDMapEx&& from) noexcept
    : LocalHDMapEx() {
    *this = ::std::move(from);
  }

  inline LocalHDMapEx& operator=(LocalHDMapEx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalHDMapEx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalHDMapEx* internal_default_instance() {
    return reinterpret_cast<const LocalHDMapEx*>(
               &_LocalHDMapEx_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(LocalHDMapEx* other);
  friend void swap(LocalHDMapEx& a, LocalHDMapEx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocalHDMapEx* New() const PROTOBUF_FINAL { return New(NULL); }

  LocalHDMapEx* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LocalHDMapEx& from);
  void MergeFrom(const LocalHDMapEx& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LocalHDMapEx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 passed_road_ids = 3;
  int passed_road_ids_size() const;
  void clear_passed_road_ids();
  static const int kPassedRoadIdsFieldNumber = 3;
  ::google::protobuf::int64 passed_road_ids(int index) const;
  void set_passed_road_ids(int index, ::google::protobuf::int64 value);
  void add_passed_road_ids(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      passed_road_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_passed_road_ids();

  // repeated int64 next_road_ids = 4;
  int next_road_ids_size() const;
  void clear_next_road_ids();
  static const int kNextRoadIdsFieldNumber = 4;
  ::google::protobuf::int64 next_road_ids(int index) const;
  void set_next_road_ids(int index, ::google::protobuf::int64 value);
  void add_next_road_ids(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      next_road_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_next_road_ids();

  // repeated .xsproto.hdmap.Linestring linestrings = 6;
  int linestrings_size() const;
  void clear_linestrings();
  static const int kLinestringsFieldNumber = 6;
  const ::xsproto::hdmap::Linestring& linestrings(int index) const;
  ::xsproto::hdmap::Linestring* mutable_linestrings(int index);
  ::xsproto::hdmap::Linestring* add_linestrings();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Linestring >*
      mutable_linestrings();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Linestring >&
      linestrings() const;

  // repeated .xsproto.hdmap.Lane lanes = 7;
  int lanes_size() const;
  void clear_lanes();
  static const int kLanesFieldNumber = 7;
  const ::xsproto::hdmap::Lane& lanes(int index) const;
  ::xsproto::hdmap::Lane* mutable_lanes(int index);
  ::xsproto::hdmap::Lane* add_lanes();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Lane >*
      mutable_lanes();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Lane >&
      lanes() const;

  // repeated .xsproto.hdmap.Road roads = 8;
  int roads_size() const;
  void clear_roads();
  static const int kRoadsFieldNumber = 8;
  const ::xsproto::hdmap::Road& roads(int index) const;
  ::xsproto::hdmap::Road* mutable_roads(int index);
  ::xsproto::hdmap::Road* add_roads();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Road >*
      mutable_roads();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Road >&
      roads() const;

  // repeated .xsproto.hdmap.Area areas = 9;
  int areas_size() const;
  void clear_areas();
  static const int kAreasFieldNumber = 9;
  const ::xsproto::hdmap::Area& areas(int index) const;
  ::xsproto::hdmap::Area* mutable_areas(int index);
  ::xsproto::hdmap::Area* add_areas();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Area >*
      mutable_areas();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Area >&
      areas() const;

  // repeated .xsproto.hdmap.Stopline stoplines = 10;
  int stoplines_size() const;
  void clear_stoplines();
  static const int kStoplinesFieldNumber = 10;
  const ::xsproto::hdmap::Stopline& stoplines(int index) const;
  ::xsproto::hdmap::Stopline* mutable_stoplines(int index);
  ::xsproto::hdmap::Stopline* add_stoplines();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Stopline >*
      mutable_stoplines();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Stopline >&
      stoplines() const;

  // repeated .xsproto.hdmap.Junction junctions = 11;
  int junctions_size() const;
  void clear_junctions();
  static const int kJunctionsFieldNumber = 11;
  const ::xsproto::hdmap::Junction& junctions(int index) const;
  ::xsproto::hdmap::Junction* mutable_junctions(int index);
  ::xsproto::hdmap::Junction* add_junctions();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Junction >*
      mutable_junctions();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Junction >&
      junctions() const;

  // repeated .xsproto.hdmap.Obstacle obstacles = 12;
  int obstacles_size() const;
  void clear_obstacles();
  static const int kObstaclesFieldNumber = 12;
  const ::xsproto::hdmap::Obstacle& obstacles(int index) const;
  ::xsproto::hdmap::Obstacle* mutable_obstacles(int index);
  ::xsproto::hdmap::Obstacle* add_obstacles();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Obstacle >*
      mutable_obstacles();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Obstacle >&
      obstacles() const;

  // repeated .xsproto.hdmap.ParkingSpace parking_spaces = 13;
  int parking_spaces_size() const;
  void clear_parking_spaces();
  static const int kParkingSpacesFieldNumber = 13;
  const ::xsproto::hdmap::ParkingSpace& parking_spaces(int index) const;
  ::xsproto::hdmap::ParkingSpace* mutable_parking_spaces(int index);
  ::xsproto::hdmap::ParkingSpace* add_parking_spaces();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ParkingSpace >*
      mutable_parking_spaces();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ParkingSpace >&
      parking_spaces() const;

  // repeated .xsproto.hdmap.Concavity concavities = 14;
  int concavities_size() const;
  void clear_concavities();
  static const int kConcavitiesFieldNumber = 14;
  const ::xsproto::hdmap::Concavity& concavities(int index) const;
  ::xsproto::hdmap::Concavity* mutable_concavities(int index);
  ::xsproto::hdmap::Concavity* add_concavities();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Concavity >*
      mutable_concavities();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Concavity >&
      concavities() const;

  // repeated .xsproto.hdmap.Alley alleys = 15;
  int alleys_size() const;
  void clear_alleys();
  static const int kAlleysFieldNumber = 15;
  const ::xsproto::hdmap::Alley& alleys(int index) const;
  ::xsproto::hdmap::Alley* mutable_alleys(int index);
  ::xsproto::hdmap::Alley* add_alleys();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Alley >*
      mutable_alleys();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Alley >&
      alleys() const;

  // repeated .xsproto.hdmap.PassableArea passable_areas = 16;
  int passable_areas_size() const;
  void clear_passable_areas();
  static const int kPassableAreasFieldNumber = 16;
  const ::xsproto::hdmap::PassableArea& passable_areas(int index) const;
  ::xsproto::hdmap::PassableArea* mutable_passable_areas(int index);
  ::xsproto::hdmap::PassableArea* add_passable_areas();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::PassableArea >*
      mutable_passable_areas();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::PassableArea >&
      passable_areas() const;

  // repeated .xsproto.hdmap.NoObstacleArea no_obstacle_areas = 17;
  int no_obstacle_areas_size() const;
  void clear_no_obstacle_areas();
  static const int kNoObstacleAreasFieldNumber = 17;
  const ::xsproto::hdmap::NoObstacleArea& no_obstacle_areas(int index) const;
  ::xsproto::hdmap::NoObstacleArea* mutable_no_obstacle_areas(int index);
  ::xsproto::hdmap::NoObstacleArea* add_no_obstacle_areas();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::NoObstacleArea >*
      mutable_no_obstacle_areas();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::NoObstacleArea >&
      no_obstacle_areas() const;

  // repeated .xsproto.hdmap.PedestrianCrossing pedestrian_crossing_areas = 18;
  int pedestrian_crossing_areas_size() const;
  void clear_pedestrian_crossing_areas();
  static const int kPedestrianCrossingAreasFieldNumber = 18;
  const ::xsproto::hdmap::PedestrianCrossing& pedestrian_crossing_areas(int index) const;
  ::xsproto::hdmap::PedestrianCrossing* mutable_pedestrian_crossing_areas(int index);
  ::xsproto::hdmap::PedestrianCrossing* add_pedestrian_crossing_areas();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::PedestrianCrossing >*
      mutable_pedestrian_crossing_areas();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::PedestrianCrossing >&
      pedestrian_crossing_areas() const;

  // repeated .xsproto.hdmap.TrafficLightPole trafficlight_poles = 19;
  int trafficlight_poles_size() const;
  void clear_trafficlight_poles();
  static const int kTrafficlightPolesFieldNumber = 19;
  const ::xsproto::hdmap::TrafficLightPole& trafficlight_poles(int index) const;
  ::xsproto::hdmap::TrafficLightPole* mutable_trafficlight_poles(int index);
  ::xsproto::hdmap::TrafficLightPole* add_trafficlight_poles();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::TrafficLightPole >*
      mutable_trafficlight_poles();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::TrafficLightPole >&
      trafficlight_poles() const;

  // .xsproto.globalpath.TaskList task_point_list = 5;
  bool has_task_point_list() const;
  void clear_task_point_list();
  static const int kTaskPointListFieldNumber = 5;
  const ::xsproto::globalpath::TaskList& task_point_list() const;
  ::xsproto::globalpath::TaskList* release_task_point_list();
  ::xsproto::globalpath::TaskList* mutable_task_point_list();
  void set_allocated_task_point_list(::xsproto::globalpath::TaskList* task_point_list);

  // int64 current_road_id = 1;
  void clear_current_road_id();
  static const int kCurrentRoadIdFieldNumber = 1;
  ::google::protobuf::int64 current_road_id() const;
  void set_current_road_id(::google::protobuf::int64 value);

  // int64 current_section_id = 2;
  void clear_current_section_id();
  static const int kCurrentSectionIdFieldNumber = 2;
  ::google::protobuf::int64 current_section_id() const;
  void set_current_section_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.LocalHDMapEx)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > passed_road_ids_;
  mutable int _passed_road_ids_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > next_road_ids_;
  mutable int _next_road_ids_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Linestring > linestrings_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Lane > lanes_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Road > roads_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Area > areas_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Stopline > stoplines_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Junction > junctions_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Obstacle > obstacles_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ParkingSpace > parking_spaces_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Concavity > concavities_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Alley > alleys_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::PassableArea > passable_areas_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::NoObstacleArea > no_obstacle_areas_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::PedestrianCrossing > pedestrian_crossing_areas_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::TrafficLightPole > trafficlight_poles_;
  ::xsproto::globalpath::TaskList* task_point_list_;
  ::google::protobuf::int64 current_road_id_;
  ::google::protobuf::int64 current_section_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_5fex_2eproto::InitDefaultsLocalHDMapExImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point

// double x = 1;
inline void Point::clear_x() {
  x_ = 0;
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Point.x)
  return x_;
}
inline void Point::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Point.x)
}

// double y = 2;
inline void Point::clear_y() {
  y_ = 0;
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Point.y)
  return y_;
}
inline void Point::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Point.y)
}

// double z = 3;
inline void Point::clear_z() {
  z_ = 0;
}
inline double Point::z() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Point.z)
  return z_;
}
inline void Point::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Point.z)
}

// int64 id = 4;
inline void Point::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Point::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Point.id)
  return id_;
}
inline void Point::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Point.id)
}

// -------------------------------------------------------------------

// Linestring

// int64 id = 1;
inline void Linestring::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Linestring::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Linestring.id)
  return id_;
}
inline void Linestring::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Linestring.id)
}

// repeated .xsproto.hdmap.Point points = 2;
inline int Linestring::points_size() const {
  return points_.size();
}
inline void Linestring::clear_points() {
  points_.Clear();
}
inline const ::xsproto::hdmap::Point& Linestring::points(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Linestring.points)
  return points_.Get(index);
}
inline ::xsproto::hdmap::Point* Linestring::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.Linestring.points)
  return points_.Mutable(index);
}
inline ::xsproto::hdmap::Point* Linestring::add_points() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.Linestring.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Point >*
Linestring::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.Linestring.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Point >&
Linestring::points() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.Linestring.points)
  return points_;
}

// -------------------------------------------------------------------

// Lane

// int64 id = 1;
inline void Lane::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Lane::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.id)
  return id_;
}
inline void Lane::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.id)
}

// int64 left_boundary_id = 2;
inline void Lane::clear_left_boundary_id() {
  left_boundary_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Lane::left_boundary_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.left_boundary_id)
  return left_boundary_id_;
}
inline void Lane::set_left_boundary_id(::google::protobuf::int64 value) {
  
  left_boundary_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.left_boundary_id)
}

// int64 right_boundary_id = 3;
inline void Lane::clear_right_boundary_id() {
  right_boundary_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Lane::right_boundary_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.right_boundary_id)
  return right_boundary_id_;
}
inline void Lane::set_right_boundary_id(::google::protobuf::int64 value) {
  
  right_boundary_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.right_boundary_id)
}

// int64 center_line_id = 4;
inline void Lane::clear_center_line_id() {
  center_line_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Lane::center_line_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.center_line_id)
  return center_line_id_;
}
inline void Lane::set_center_line_id(::google::protobuf::int64 value) {
  
  center_line_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.center_line_id)
}

// int32 index = 5;
inline void Lane::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 Lane::index() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.index)
  return index_;
}
inline void Lane::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.index)
}

// int64 left_lane_id = 6;
inline void Lane::clear_left_lane_id() {
  left_lane_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Lane::left_lane_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.left_lane_id)
  return left_lane_id_;
}
inline void Lane::set_left_lane_id(::google::protobuf::int64 value) {
  
  left_lane_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.left_lane_id)
}

// int64 right_lane_id = 7;
inline void Lane::clear_right_lane_id() {
  right_lane_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Lane::right_lane_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.right_lane_id)
  return right_lane_id_;
}
inline void Lane::set_right_lane_id(::google::protobuf::int64 value) {
  
  right_lane_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.right_lane_id)
}

// repeated int64 pre_lane_id = 8;
inline int Lane::pre_lane_id_size() const {
  return pre_lane_id_.size();
}
inline void Lane::clear_pre_lane_id() {
  pre_lane_id_.Clear();
}
inline ::google::protobuf::int64 Lane::pre_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.pre_lane_id)
  return pre_lane_id_.Get(index);
}
inline void Lane::set_pre_lane_id(int index, ::google::protobuf::int64 value) {
  pre_lane_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.pre_lane_id)
}
inline void Lane::add_pre_lane_id(::google::protobuf::int64 value) {
  pre_lane_id_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.Lane.pre_lane_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Lane::pre_lane_id() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.Lane.pre_lane_id)
  return pre_lane_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Lane::mutable_pre_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.Lane.pre_lane_id)
  return &pre_lane_id_;
}

// repeated int64 post_lane_id = 9;
inline int Lane::post_lane_id_size() const {
  return post_lane_id_.size();
}
inline void Lane::clear_post_lane_id() {
  post_lane_id_.Clear();
}
inline ::google::protobuf::int64 Lane::post_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.post_lane_id)
  return post_lane_id_.Get(index);
}
inline void Lane::set_post_lane_id(int index, ::google::protobuf::int64 value) {
  post_lane_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.post_lane_id)
}
inline void Lane::add_post_lane_id(::google::protobuf::int64 value) {
  post_lane_id_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.Lane.post_lane_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Lane::post_lane_id() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.Lane.post_lane_id)
  return post_lane_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Lane::mutable_post_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.Lane.post_lane_id)
  return &post_lane_id_;
}

// .xsproto.hdmap.Lane.LaneChangeType left_lane_change = 10;
inline void Lane::clear_left_lane_change() {
  left_lane_change_ = 0;
}
inline ::xsproto::hdmap::Lane_LaneChangeType Lane::left_lane_change() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.left_lane_change)
  return static_cast< ::xsproto::hdmap::Lane_LaneChangeType >(left_lane_change_);
}
inline void Lane::set_left_lane_change(::xsproto::hdmap::Lane_LaneChangeType value) {
  
  left_lane_change_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.left_lane_change)
}

// .xsproto.hdmap.Lane.LaneChangeType right_lane_change = 11;
inline void Lane::clear_right_lane_change() {
  right_lane_change_ = 0;
}
inline ::xsproto::hdmap::Lane_LaneChangeType Lane::right_lane_change() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.right_lane_change)
  return static_cast< ::xsproto::hdmap::Lane_LaneChangeType >(right_lane_change_);
}
inline void Lane::set_right_lane_change(::xsproto::hdmap::Lane_LaneChangeType value) {
  
  right_lane_change_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.right_lane_change)
}

// int32 participant_mask = 12;
inline void Lane::clear_participant_mask() {
  participant_mask_ = 0;
}
inline ::google::protobuf::int32 Lane::participant_mask() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.participant_mask)
  return participant_mask_;
}
inline void Lane::set_participant_mask(::google::protobuf::int32 value) {
  
  participant_mask_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.participant_mask)
}

// double max_speed_limit = 13;
inline void Lane::clear_max_speed_limit() {
  max_speed_limit_ = 0;
}
inline double Lane::max_speed_limit() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.max_speed_limit)
  return max_speed_limit_;
}
inline void Lane::set_max_speed_limit(double value) {
  
  max_speed_limit_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.max_speed_limit)
}

// double min_speed_limit = 14;
inline void Lane::clear_min_speed_limit() {
  min_speed_limit_ = 0;
}
inline double Lane::min_speed_limit() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.min_speed_limit)
  return min_speed_limit_;
}
inline void Lane::set_min_speed_limit(double value) {
  
  min_speed_limit_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.min_speed_limit)
}

// int32 direction = 15;
inline void Lane::clear_direction() {
  direction_ = 0;
}
inline ::google::protobuf::int32 Lane::direction() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Lane.direction)
  return direction_;
}
inline void Lane::set_direction(::google::protobuf::int32 value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Lane.direction)
}

// -------------------------------------------------------------------

// RoadSection

// int64 id = 1;
inline void RoadSection::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RoadSection::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadSection.id)
  return id_;
}
inline void RoadSection::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadSection.id)
}

// int32 index = 2;
inline void RoadSection::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 RoadSection::index() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadSection.index)
  return index_;
}
inline void RoadSection::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadSection.index)
}

// int64 pre_section_id = 3;
inline void RoadSection::clear_pre_section_id() {
  pre_section_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RoadSection::pre_section_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadSection.pre_section_id)
  return pre_section_id_;
}
inline void RoadSection::set_pre_section_id(::google::protobuf::int64 value) {
  
  pre_section_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadSection.pre_section_id)
}

// int64 post_section_id = 4;
inline void RoadSection::clear_post_section_id() {
  post_section_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RoadSection::post_section_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadSection.post_section_id)
  return post_section_id_;
}
inline void RoadSection::set_post_section_id(::google::protobuf::int64 value) {
  
  post_section_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadSection.post_section_id)
}

// repeated int64 lanes = 5;
inline int RoadSection::lanes_size() const {
  return lanes_.size();
}
inline void RoadSection::clear_lanes() {
  lanes_.Clear();
}
inline ::google::protobuf::int64 RoadSection::lanes(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadSection.lanes)
  return lanes_.Get(index);
}
inline void RoadSection::set_lanes(int index, ::google::protobuf::int64 value) {
  lanes_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadSection.lanes)
}
inline void RoadSection::add_lanes(::google::protobuf::int64 value) {
  lanes_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.RoadSection.lanes)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
RoadSection::lanes() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.RoadSection.lanes)
  return lanes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
RoadSection::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.RoadSection.lanes)
  return &lanes_;
}

// -------------------------------------------------------------------

// Road

// int64 id = 1;
inline void Road::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Road::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Road.id)
  return id_;
}
inline void Road::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Road.id)
}

// repeated int64 pre_road_id = 2;
inline int Road::pre_road_id_size() const {
  return pre_road_id_.size();
}
inline void Road::clear_pre_road_id() {
  pre_road_id_.Clear();
}
inline ::google::protobuf::int64 Road::pre_road_id(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Road.pre_road_id)
  return pre_road_id_.Get(index);
}
inline void Road::set_pre_road_id(int index, ::google::protobuf::int64 value) {
  pre_road_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Road.pre_road_id)
}
inline void Road::add_pre_road_id(::google::protobuf::int64 value) {
  pre_road_id_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.Road.pre_road_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Road::pre_road_id() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.Road.pre_road_id)
  return pre_road_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Road::mutable_pre_road_id() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.Road.pre_road_id)
  return &pre_road_id_;
}

// repeated int64 post_road_id = 3;
inline int Road::post_road_id_size() const {
  return post_road_id_.size();
}
inline void Road::clear_post_road_id() {
  post_road_id_.Clear();
}
inline ::google::protobuf::int64 Road::post_road_id(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Road.post_road_id)
  return post_road_id_.Get(index);
}
inline void Road::set_post_road_id(int index, ::google::protobuf::int64 value) {
  post_road_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Road.post_road_id)
}
inline void Road::add_post_road_id(::google::protobuf::int64 value) {
  post_road_id_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.Road.post_road_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Road::post_road_id() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.Road.post_road_id)
  return post_road_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Road::mutable_post_road_id() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.Road.post_road_id)
  return &post_road_id_;
}

// repeated .xsproto.hdmap.RoadSection road_sections = 4;
inline int Road::road_sections_size() const {
  return road_sections_.size();
}
inline void Road::clear_road_sections() {
  road_sections_.Clear();
}
inline const ::xsproto::hdmap::RoadSection& Road::road_sections(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Road.road_sections)
  return road_sections_.Get(index);
}
inline ::xsproto::hdmap::RoadSection* Road::mutable_road_sections(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.Road.road_sections)
  return road_sections_.Mutable(index);
}
inline ::xsproto::hdmap::RoadSection* Road::add_road_sections() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.Road.road_sections)
  return road_sections_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::RoadSection >*
Road::mutable_road_sections() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.Road.road_sections)
  return &road_sections_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::RoadSection >&
Road::road_sections() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.Road.road_sections)
  return road_sections_;
}

// int64 junction_id = 5;
inline void Road::clear_junction_id() {
  junction_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Road::junction_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Road.junction_id)
  return junction_id_;
}
inline void Road::set_junction_id(::google::protobuf::int64 value) {
  
  junction_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Road.junction_id)
}

// double length = 6;
inline void Road::clear_length() {
  length_ = 0;
}
inline double Road::length() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Road.length)
  return length_;
}
inline void Road::set_length(double value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Road.length)
}

// -------------------------------------------------------------------

// ObserveLane

// int64 lane_id = 1;
inline void ObserveLane::clear_lane_id() {
  lane_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ObserveLane::lane_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.ObserveLane.lane_id)
  return lane_id_;
}
inline void ObserveLane::set_lane_id(::google::protobuf::int64 value) {
  
  lane_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.ObserveLane.lane_id)
}

// .xsproto.hdmap.PassDirection pass_direction = 2;
inline void ObserveLane::clear_pass_direction() {
  pass_direction_ = 0;
}
inline ::xsproto::hdmap::PassDirection ObserveLane::pass_direction() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.ObserveLane.pass_direction)
  return static_cast< ::xsproto::hdmap::PassDirection >(pass_direction_);
}
inline void ObserveLane::set_pass_direction(::xsproto::hdmap::PassDirection value) {
  
  pass_direction_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.ObserveLane.pass_direction)
}

// .xsproto.hdmap.PassRule pass_rule = 3;
inline void ObserveLane::clear_pass_rule() {
  pass_rule_ = 0;
}
inline ::xsproto::hdmap::PassRule ObserveLane::pass_rule() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.ObserveLane.pass_rule)
  return static_cast< ::xsproto::hdmap::PassRule >(pass_rule_);
}
inline void ObserveLane::set_pass_rule(::xsproto::hdmap::PassRule value) {
  
  pass_rule_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.ObserveLane.pass_rule)
}

// -------------------------------------------------------------------

// ObserveArea

// int64 area_id = 1;
inline void ObserveArea::clear_area_id() {
  area_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ObserveArea::area_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.ObserveArea.area_id)
  return area_id_;
}
inline void ObserveArea::set_area_id(::google::protobuf::int64 value) {
  
  area_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.ObserveArea.area_id)
}

// .xsproto.hdmap.PassDirection enter_pass_direction = 2;
inline void ObserveArea::clear_enter_pass_direction() {
  enter_pass_direction_ = 0;
}
inline ::xsproto::hdmap::PassDirection ObserveArea::enter_pass_direction() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.ObserveArea.enter_pass_direction)
  return static_cast< ::xsproto::hdmap::PassDirection >(enter_pass_direction_);
}
inline void ObserveArea::set_enter_pass_direction(::xsproto::hdmap::PassDirection value) {
  
  enter_pass_direction_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.ObserveArea.enter_pass_direction)
}

// .xsproto.hdmap.PassRule enter_pass_rule = 3;
inline void ObserveArea::clear_enter_pass_rule() {
  enter_pass_rule_ = 0;
}
inline ::xsproto::hdmap::PassRule ObserveArea::enter_pass_rule() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.ObserveArea.enter_pass_rule)
  return static_cast< ::xsproto::hdmap::PassRule >(enter_pass_rule_);
}
inline void ObserveArea::set_enter_pass_rule(::xsproto::hdmap::PassRule value) {
  
  enter_pass_rule_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.ObserveArea.enter_pass_rule)
}

// .xsproto.hdmap.PassDirection exit_pass_direction = 4;
inline void ObserveArea::clear_exit_pass_direction() {
  exit_pass_direction_ = 0;
}
inline ::xsproto::hdmap::PassDirection ObserveArea::exit_pass_direction() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.ObserveArea.exit_pass_direction)
  return static_cast< ::xsproto::hdmap::PassDirection >(exit_pass_direction_);
}
inline void ObserveArea::set_exit_pass_direction(::xsproto::hdmap::PassDirection value) {
  
  exit_pass_direction_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.ObserveArea.exit_pass_direction)
}

// .xsproto.hdmap.PassRule exit_pass_rule = 5;
inline void ObserveArea::clear_exit_pass_rule() {
  exit_pass_rule_ = 0;
}
inline ::xsproto::hdmap::PassRule ObserveArea::exit_pass_rule() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.ObserveArea.exit_pass_rule)
  return static_cast< ::xsproto::hdmap::PassRule >(exit_pass_rule_);
}
inline void ObserveArea::set_exit_pass_rule(::xsproto::hdmap::PassRule value) {
  
  exit_pass_rule_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.ObserveArea.exit_pass_rule)
}

// -------------------------------------------------------------------

// TrafficLightGroup

// int64 id = 1;
inline void TrafficLightGroup::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficLightGroup::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.TrafficLightGroup.id)
  return id_;
}
inline void TrafficLightGroup::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.TrafficLightGroup.id)
}

// repeated .xsproto.hdmap.ObserveLane observe_lane = 2;
inline int TrafficLightGroup::observe_lane_size() const {
  return observe_lane_.size();
}
inline void TrafficLightGroup::clear_observe_lane() {
  observe_lane_.Clear();
}
inline const ::xsproto::hdmap::ObserveLane& TrafficLightGroup::observe_lane(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.TrafficLightGroup.observe_lane)
  return observe_lane_.Get(index);
}
inline ::xsproto::hdmap::ObserveLane* TrafficLightGroup::mutable_observe_lane(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.TrafficLightGroup.observe_lane)
  return observe_lane_.Mutable(index);
}
inline ::xsproto::hdmap::ObserveLane* TrafficLightGroup::add_observe_lane() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.TrafficLightGroup.observe_lane)
  return observe_lane_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ObserveLane >*
TrafficLightGroup::mutable_observe_lane() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.TrafficLightGroup.observe_lane)
  return &observe_lane_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ObserveLane >&
TrafficLightGroup::observe_lane() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.TrafficLightGroup.observe_lane)
  return observe_lane_;
}

// repeated .xsproto.hdmap.ObserveArea observe_area = 3;
inline int TrafficLightGroup::observe_area_size() const {
  return observe_area_.size();
}
inline void TrafficLightGroup::clear_observe_area() {
  observe_area_.Clear();
}
inline const ::xsproto::hdmap::ObserveArea& TrafficLightGroup::observe_area(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.TrafficLightGroup.observe_area)
  return observe_area_.Get(index);
}
inline ::xsproto::hdmap::ObserveArea* TrafficLightGroup::mutable_observe_area(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.TrafficLightGroup.observe_area)
  return observe_area_.Mutable(index);
}
inline ::xsproto::hdmap::ObserveArea* TrafficLightGroup::add_observe_area() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.TrafficLightGroup.observe_area)
  return observe_area_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ObserveArea >*
TrafficLightGroup::mutable_observe_area() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.TrafficLightGroup.observe_area)
  return &observe_area_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ObserveArea >&
TrafficLightGroup::observe_area() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.TrafficLightGroup.observe_area)
  return observe_area_;
}

// int32 has_left = 4;
inline void TrafficLightGroup::clear_has_left() {
  has_left_ = 0;
}
inline ::google::protobuf::int32 TrafficLightGroup::has_left() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.TrafficLightGroup.has_left)
  return has_left_;
}
inline void TrafficLightGroup::set_has_left(::google::protobuf::int32 value) {
  
  has_left_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.TrafficLightGroup.has_left)
}

// int32 has_right = 5;
inline void TrafficLightGroup::clear_has_right() {
  has_right_ = 0;
}
inline ::google::protobuf::int32 TrafficLightGroup::has_right() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.TrafficLightGroup.has_right)
  return has_right_;
}
inline void TrafficLightGroup::set_has_right(::google::protobuf::int32 value) {
  
  has_right_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.TrafficLightGroup.has_right)
}

// int32 has_forward = 6;
inline void TrafficLightGroup::clear_has_forward() {
  has_forward_ = 0;
}
inline ::google::protobuf::int32 TrafficLightGroup::has_forward() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.TrafficLightGroup.has_forward)
  return has_forward_;
}
inline void TrafficLightGroup::set_has_forward(::google::protobuf::int32 value) {
  
  has_forward_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.TrafficLightGroup.has_forward)
}

// int32 has_uturn = 7;
inline void TrafficLightGroup::clear_has_uturn() {
  has_uturn_ = 0;
}
inline ::google::protobuf::int32 TrafficLightGroup::has_uturn() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.TrafficLightGroup.has_uturn)
  return has_uturn_;
}
inline void TrafficLightGroup::set_has_uturn(::google::protobuf::int32 value) {
  
  has_uturn_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.TrafficLightGroup.has_uturn)
}

// int32 is_circle = 8;
inline void TrafficLightGroup::clear_is_circle() {
  is_circle_ = 0;
}
inline ::google::protobuf::int32 TrafficLightGroup::is_circle() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.TrafficLightGroup.is_circle)
  return is_circle_;
}
inline void TrafficLightGroup::set_is_circle(::google::protobuf::int32 value) {
  
  is_circle_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.TrafficLightGroup.is_circle)
}

// .xsproto.hdmap.Point position = 9;
inline bool TrafficLightGroup::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void TrafficLightGroup::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::xsproto::hdmap::Point& TrafficLightGroup::position() const {
  const ::xsproto::hdmap::Point* p = position_;
  // @@protoc_insertion_point(field_get:xsproto.hdmap.TrafficLightGroup.position)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::hdmap::Point*>(
      &::xsproto::hdmap::_Point_default_instance_);
}
inline ::xsproto::hdmap::Point* TrafficLightGroup::release_position() {
  // @@protoc_insertion_point(field_release:xsproto.hdmap.TrafficLightGroup.position)
  
  ::xsproto::hdmap::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::xsproto::hdmap::Point* TrafficLightGroup::mutable_position() {
  
  if (position_ == NULL) {
    position_ = new ::xsproto::hdmap::Point;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.TrafficLightGroup.position)
  return position_;
}
inline void TrafficLightGroup::set_allocated_position(::xsproto::hdmap::Point* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:xsproto.hdmap.TrafficLightGroup.position)
}

// -------------------------------------------------------------------

// TrafficLightPole

// int64 id = 1;
inline void TrafficLightPole::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TrafficLightPole::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.TrafficLightPole.id)
  return id_;
}
inline void TrafficLightPole::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.TrafficLightPole.id)
}

// repeated .xsproto.hdmap.TrafficLightGroup traffic_lights = 2;
inline int TrafficLightPole::traffic_lights_size() const {
  return traffic_lights_.size();
}
inline void TrafficLightPole::clear_traffic_lights() {
  traffic_lights_.Clear();
}
inline const ::xsproto::hdmap::TrafficLightGroup& TrafficLightPole::traffic_lights(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.TrafficLightPole.traffic_lights)
  return traffic_lights_.Get(index);
}
inline ::xsproto::hdmap::TrafficLightGroup* TrafficLightPole::mutable_traffic_lights(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.TrafficLightPole.traffic_lights)
  return traffic_lights_.Mutable(index);
}
inline ::xsproto::hdmap::TrafficLightGroup* TrafficLightPole::add_traffic_lights() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.TrafficLightPole.traffic_lights)
  return traffic_lights_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::TrafficLightGroup >*
TrafficLightPole::mutable_traffic_lights() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.TrafficLightPole.traffic_lights)
  return &traffic_lights_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::TrafficLightGroup >&
TrafficLightPole::traffic_lights() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.TrafficLightPole.traffic_lights)
  return traffic_lights_;
}

// -------------------------------------------------------------------

// IntersectedLane

// int64 lane_id = 1;
inline void IntersectedLane::clear_lane_id() {
  lane_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 IntersectedLane::lane_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.IntersectedLane.lane_id)
  return lane_id_;
}
inline void IntersectedLane::set_lane_id(::google::protobuf::int64 value) {
  
  lane_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.IntersectedLane.lane_id)
}

// bool yield = 2;
inline void IntersectedLane::clear_yield() {
  yield_ = false;
}
inline bool IntersectedLane::yield() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.IntersectedLane.yield)
  return yield_;
}
inline void IntersectedLane::set_yield(bool value) {
  
  yield_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.IntersectedLane.yield)
}

// -------------------------------------------------------------------

// LaneInJunction

// int64 id = 1;
inline void LaneInJunction::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LaneInJunction::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LaneInJunction.id)
  return id_;
}
inline void LaneInJunction::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LaneInJunction.id)
}

// repeated .xsproto.hdmap.IntersectedLane interseced_lanes = 2;
inline int LaneInJunction::interseced_lanes_size() const {
  return interseced_lanes_.size();
}
inline void LaneInJunction::clear_interseced_lanes() {
  interseced_lanes_.Clear();
}
inline const ::xsproto::hdmap::IntersectedLane& LaneInJunction::interseced_lanes(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LaneInJunction.interseced_lanes)
  return interseced_lanes_.Get(index);
}
inline ::xsproto::hdmap::IntersectedLane* LaneInJunction::mutable_interseced_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LaneInJunction.interseced_lanes)
  return interseced_lanes_.Mutable(index);
}
inline ::xsproto::hdmap::IntersectedLane* LaneInJunction::add_interseced_lanes() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LaneInJunction.interseced_lanes)
  return interseced_lanes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::IntersectedLane >*
LaneInJunction::mutable_interseced_lanes() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LaneInJunction.interseced_lanes)
  return &interseced_lanes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::IntersectedLane >&
LaneInJunction::interseced_lanes() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LaneInJunction.interseced_lanes)
  return interseced_lanes_;
}

// -------------------------------------------------------------------

// Junction

// int64 id = 1;
inline void Junction::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Junction::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Junction.id)
  return id_;
}
inline void Junction::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Junction.id)
}

// repeated .xsproto.hdmap.LaneInJunction lanes = 2;
inline int Junction::lanes_size() const {
  return lanes_.size();
}
inline void Junction::clear_lanes() {
  lanes_.Clear();
}
inline const ::xsproto::hdmap::LaneInJunction& Junction::lanes(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Junction.lanes)
  return lanes_.Get(index);
}
inline ::xsproto::hdmap::LaneInJunction* Junction::mutable_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.Junction.lanes)
  return lanes_.Mutable(index);
}
inline ::xsproto::hdmap::LaneInJunction* Junction::add_lanes() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.Junction.lanes)
  return lanes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::LaneInJunction >*
Junction::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.Junction.lanes)
  return &lanes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::LaneInJunction >&
Junction::lanes() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.Junction.lanes)
  return lanes_;
}

// repeated int64 traffic_light_poles = 3;
inline int Junction::traffic_light_poles_size() const {
  return traffic_light_poles_.size();
}
inline void Junction::clear_traffic_light_poles() {
  traffic_light_poles_.Clear();
}
inline ::google::protobuf::int64 Junction::traffic_light_poles(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Junction.traffic_light_poles)
  return traffic_light_poles_.Get(index);
}
inline void Junction::set_traffic_light_poles(int index, ::google::protobuf::int64 value) {
  traffic_light_poles_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Junction.traffic_light_poles)
}
inline void Junction::add_traffic_light_poles(::google::protobuf::int64 value) {
  traffic_light_poles_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.Junction.traffic_light_poles)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Junction::traffic_light_poles() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.Junction.traffic_light_poles)
  return traffic_light_poles_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Junction::mutable_traffic_light_poles() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.Junction.traffic_light_poles)
  return &traffic_light_poles_;
}

// -------------------------------------------------------------------

// AreaGap

// .xsproto.hdmap.AreaGap.GapType type = 1;
inline void AreaGap::clear_type() {
  type_ = 0;
}
inline ::xsproto::hdmap::AreaGap_GapType AreaGap::type() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.AreaGap.type)
  return static_cast< ::xsproto::hdmap::AreaGap_GapType >(type_);
}
inline void AreaGap::set_type(::xsproto::hdmap::AreaGap_GapType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.AreaGap.type)
}

// int64 linestring_id = 2;
inline void AreaGap::clear_linestring_id() {
  linestring_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AreaGap::linestring_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.AreaGap.linestring_id)
  return linestring_id_;
}
inline void AreaGap::set_linestring_id(::google::protobuf::int64 value) {
  
  linestring_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.AreaGap.linestring_id)
}

// -------------------------------------------------------------------

// Area

// int64 id = 1;
inline void Area::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Area::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Area.id)
  return id_;
}
inline void Area::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Area.id)
}

// repeated int64 linestrings = 2;
inline int Area::linestrings_size() const {
  return linestrings_.size();
}
inline void Area::clear_linestrings() {
  linestrings_.Clear();
}
inline ::google::protobuf::int64 Area::linestrings(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Area.linestrings)
  return linestrings_.Get(index);
}
inline void Area::set_linestrings(int index, ::google::protobuf::int64 value) {
  linestrings_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Area.linestrings)
}
inline void Area::add_linestrings(::google::protobuf::int64 value) {
  linestrings_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.Area.linestrings)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Area::linestrings() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.Area.linestrings)
  return linestrings_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Area::mutable_linestrings() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.Area.linestrings)
  return &linestrings_;
}

// int32 shape = 3;
inline void Area::clear_shape() {
  shape_ = 0;
}
inline ::google::protobuf::int32 Area::shape() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Area.shape)
  return shape_;
}
inline void Area::set_shape(::google::protobuf::int32 value) {
  
  shape_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Area.shape)
}

// repeated .xsproto.hdmap.AreaGap gaps = 4;
inline int Area::gaps_size() const {
  return gaps_.size();
}
inline void Area::clear_gaps() {
  gaps_.Clear();
}
inline const ::xsproto::hdmap::AreaGap& Area::gaps(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Area.gaps)
  return gaps_.Get(index);
}
inline ::xsproto::hdmap::AreaGap* Area::mutable_gaps(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.Area.gaps)
  return gaps_.Mutable(index);
}
inline ::xsproto::hdmap::AreaGap* Area::add_gaps() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.Area.gaps)
  return gaps_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >*
Area::mutable_gaps() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.Area.gaps)
  return &gaps_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >&
Area::gaps() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.Area.gaps)
  return gaps_;
}

// -------------------------------------------------------------------

// Obstacle

// int64 id = 1;
inline void Obstacle::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Obstacle::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Obstacle.id)
  return id_;
}
inline void Obstacle::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Obstacle.id)
}

// int32 type = 2;
inline void Obstacle::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 Obstacle::type() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Obstacle.type)
  return type_;
}
inline void Obstacle::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Obstacle.type)
}

// int64 area_id = 3;
inline void Obstacle::clear_area_id() {
  area_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Obstacle::area_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Obstacle.area_id)
  return area_id_;
}
inline void Obstacle::set_area_id(::google::protobuf::int64 value) {
  
  area_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Obstacle.area_id)
}

// -------------------------------------------------------------------

// PedestrianCrossing

// int64 id = 1;
inline void PedestrianCrossing::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PedestrianCrossing::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.PedestrianCrossing.id)
  return id_;
}
inline void PedestrianCrossing::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.PedestrianCrossing.id)
}

// repeated .xsproto.hdmap.AreaGap gaps = 2;
inline int PedestrianCrossing::gaps_size() const {
  return gaps_.size();
}
inline void PedestrianCrossing::clear_gaps() {
  gaps_.Clear();
}
inline const ::xsproto::hdmap::AreaGap& PedestrianCrossing::gaps(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.PedestrianCrossing.gaps)
  return gaps_.Get(index);
}
inline ::xsproto::hdmap::AreaGap* PedestrianCrossing::mutable_gaps(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.PedestrianCrossing.gaps)
  return gaps_.Mutable(index);
}
inline ::xsproto::hdmap::AreaGap* PedestrianCrossing::add_gaps() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.PedestrianCrossing.gaps)
  return gaps_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >*
PedestrianCrossing::mutable_gaps() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.PedestrianCrossing.gaps)
  return &gaps_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >&
PedestrianCrossing::gaps() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.PedestrianCrossing.gaps)
  return gaps_;
}

// int64 area_id = 3;
inline void PedestrianCrossing::clear_area_id() {
  area_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PedestrianCrossing::area_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.PedestrianCrossing.area_id)
  return area_id_;
}
inline void PedestrianCrossing::set_area_id(::google::protobuf::int64 value) {
  
  area_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.PedestrianCrossing.area_id)
}

// -------------------------------------------------------------------

// ParkingSpace

// int64 id = 1;
inline void ParkingSpace::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ParkingSpace::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.ParkingSpace.id)
  return id_;
}
inline void ParkingSpace::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.ParkingSpace.id)
}

// int64 on_road = 2;
inline void ParkingSpace::clear_on_road() {
  on_road_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ParkingSpace::on_road() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.ParkingSpace.on_road)
  return on_road_;
}
inline void ParkingSpace::set_on_road(::google::protobuf::int64 value) {
  
  on_road_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.ParkingSpace.on_road)
}

// repeated .xsproto.hdmap.AreaGap gaps = 3;
inline int ParkingSpace::gaps_size() const {
  return gaps_.size();
}
inline void ParkingSpace::clear_gaps() {
  gaps_.Clear();
}
inline const ::xsproto::hdmap::AreaGap& ParkingSpace::gaps(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.ParkingSpace.gaps)
  return gaps_.Get(index);
}
inline ::xsproto::hdmap::AreaGap* ParkingSpace::mutable_gaps(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.ParkingSpace.gaps)
  return gaps_.Mutable(index);
}
inline ::xsproto::hdmap::AreaGap* ParkingSpace::add_gaps() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.ParkingSpace.gaps)
  return gaps_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >*
ParkingSpace::mutable_gaps() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.ParkingSpace.gaps)
  return &gaps_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >&
ParkingSpace::gaps() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.ParkingSpace.gaps)
  return gaps_;
}

// int64 area_id = 4;
inline void ParkingSpace::clear_area_id() {
  area_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ParkingSpace::area_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.ParkingSpace.area_id)
  return area_id_;
}
inline void ParkingSpace::set_area_id(::google::protobuf::int64 value) {
  
  area_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.ParkingSpace.area_id)
}

// -------------------------------------------------------------------

// Concavity

// int64 id = 1;
inline void Concavity::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Concavity::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Concavity.id)
  return id_;
}
inline void Concavity::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Concavity.id)
}

// int64 area_id = 2;
inline void Concavity::clear_area_id() {
  area_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Concavity::area_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Concavity.area_id)
  return area_id_;
}
inline void Concavity::set_area_id(::google::protobuf::int64 value) {
  
  area_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Concavity.area_id)
}

// -------------------------------------------------------------------

// Alley

// int64 id = 1;
inline void Alley::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Alley::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Alley.id)
  return id_;
}
inline void Alley::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Alley.id)
}

// int64 area_id = 2;
inline void Alley::clear_area_id() {
  area_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Alley::area_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Alley.area_id)
  return area_id_;
}
inline void Alley::set_area_id(::google::protobuf::int64 value) {
  
  area_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Alley.area_id)
}

// -------------------------------------------------------------------

// PassableArea

// int64 id = 1;
inline void PassableArea::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PassableArea::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.PassableArea.id)
  return id_;
}
inline void PassableArea::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.PassableArea.id)
}

// int64 area_id = 2;
inline void PassableArea::clear_area_id() {
  area_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PassableArea::area_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.PassableArea.area_id)
  return area_id_;
}
inline void PassableArea::set_area_id(::google::protobuf::int64 value) {
  
  area_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.PassableArea.area_id)
}

// -------------------------------------------------------------------

// NoObstacleArea

// int64 id = 1;
inline void NoObstacleArea::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NoObstacleArea::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.NoObstacleArea.id)
  return id_;
}
inline void NoObstacleArea::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.NoObstacleArea.id)
}

// int64 area_id = 2;
inline void NoObstacleArea::clear_area_id() {
  area_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 NoObstacleArea::area_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.NoObstacleArea.area_id)
  return area_id_;
}
inline void NoObstacleArea::set_area_id(::google::protobuf::int64 value) {
  
  area_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.NoObstacleArea.area_id)
}

// -------------------------------------------------------------------

// WaitArea

// int64 id = 1;
inline void WaitArea::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 WaitArea::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.WaitArea.id)
  return id_;
}
inline void WaitArea::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.WaitArea.id)
}

// repeated .xsproto.hdmap.AreaGap gaps = 2;
inline int WaitArea::gaps_size() const {
  return gaps_.size();
}
inline void WaitArea::clear_gaps() {
  gaps_.Clear();
}
inline const ::xsproto::hdmap::AreaGap& WaitArea::gaps(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.WaitArea.gaps)
  return gaps_.Get(index);
}
inline ::xsproto::hdmap::AreaGap* WaitArea::mutable_gaps(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.WaitArea.gaps)
  return gaps_.Mutable(index);
}
inline ::xsproto::hdmap::AreaGap* WaitArea::add_gaps() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.WaitArea.gaps)
  return gaps_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >*
WaitArea::mutable_gaps() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.WaitArea.gaps)
  return &gaps_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::AreaGap >&
WaitArea::gaps() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.WaitArea.gaps)
  return gaps_;
}

// int64 area_id = 3;
inline void WaitArea::clear_area_id() {
  area_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 WaitArea::area_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.WaitArea.area_id)
  return area_id_;
}
inline void WaitArea::set_area_id(::google::protobuf::int64 value) {
  
  area_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.WaitArea.area_id)
}

// -------------------------------------------------------------------

// Stopline

// int64 id = 1;
inline void Stopline::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Stopline::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Stopline.id)
  return id_;
}
inline void Stopline::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Stopline.id)
}

// int64 area_id = 2;
inline void Stopline::clear_area_id() {
  area_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Stopline::area_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.Stopline.area_id)
  return area_id_;
}
inline void Stopline::set_area_id(::google::protobuf::int64 value) {
  
  area_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.Stopline.area_id)
}

// -------------------------------------------------------------------

// LocalHDMapEx

// int64 current_road_id = 1;
inline void LocalHDMapEx::clear_current_road_id() {
  current_road_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LocalHDMapEx::current_road_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.current_road_id)
  return current_road_id_;
}
inline void LocalHDMapEx::set_current_road_id(::google::protobuf::int64 value) {
  
  current_road_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LocalHDMapEx.current_road_id)
}

// int64 current_section_id = 2;
inline void LocalHDMapEx::clear_current_section_id() {
  current_section_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LocalHDMapEx::current_section_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.current_section_id)
  return current_section_id_;
}
inline void LocalHDMapEx::set_current_section_id(::google::protobuf::int64 value) {
  
  current_section_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LocalHDMapEx.current_section_id)
}

// repeated int64 passed_road_ids = 3;
inline int LocalHDMapEx::passed_road_ids_size() const {
  return passed_road_ids_.size();
}
inline void LocalHDMapEx::clear_passed_road_ids() {
  passed_road_ids_.Clear();
}
inline ::google::protobuf::int64 LocalHDMapEx::passed_road_ids(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.passed_road_ids)
  return passed_road_ids_.Get(index);
}
inline void LocalHDMapEx::set_passed_road_ids(int index, ::google::protobuf::int64 value) {
  passed_road_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LocalHDMapEx.passed_road_ids)
}
inline void LocalHDMapEx::add_passed_road_ids(::google::protobuf::int64 value) {
  passed_road_ids_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.passed_road_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
LocalHDMapEx::passed_road_ids() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.passed_road_ids)
  return passed_road_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
LocalHDMapEx::mutable_passed_road_ids() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.passed_road_ids)
  return &passed_road_ids_;
}

// repeated int64 next_road_ids = 4;
inline int LocalHDMapEx::next_road_ids_size() const {
  return next_road_ids_.size();
}
inline void LocalHDMapEx::clear_next_road_ids() {
  next_road_ids_.Clear();
}
inline ::google::protobuf::int64 LocalHDMapEx::next_road_ids(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.next_road_ids)
  return next_road_ids_.Get(index);
}
inline void LocalHDMapEx::set_next_road_ids(int index, ::google::protobuf::int64 value) {
  next_road_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LocalHDMapEx.next_road_ids)
}
inline void LocalHDMapEx::add_next_road_ids(::google::protobuf::int64 value) {
  next_road_ids_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.next_road_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
LocalHDMapEx::next_road_ids() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.next_road_ids)
  return next_road_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
LocalHDMapEx::mutable_next_road_ids() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.next_road_ids)
  return &next_road_ids_;
}

// .xsproto.globalpath.TaskList task_point_list = 5;
inline bool LocalHDMapEx::has_task_point_list() const {
  return this != internal_default_instance() && task_point_list_ != NULL;
}
inline const ::xsproto::globalpath::TaskList& LocalHDMapEx::task_point_list() const {
  const ::xsproto::globalpath::TaskList* p = task_point_list_;
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.task_point_list)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::globalpath::TaskList*>(
      &::xsproto::globalpath::_TaskList_default_instance_);
}
inline ::xsproto::globalpath::TaskList* LocalHDMapEx::release_task_point_list() {
  // @@protoc_insertion_point(field_release:xsproto.hdmap.LocalHDMapEx.task_point_list)
  
  ::xsproto::globalpath::TaskList* temp = task_point_list_;
  task_point_list_ = NULL;
  return temp;
}
inline ::xsproto::globalpath::TaskList* LocalHDMapEx::mutable_task_point_list() {
  
  if (task_point_list_ == NULL) {
    task_point_list_ = new ::xsproto::globalpath::TaskList;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.task_point_list)
  return task_point_list_;
}
inline void LocalHDMapEx::set_allocated_task_point_list(::xsproto::globalpath::TaskList* task_point_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(task_point_list_);
  }
  if (task_point_list) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      task_point_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_point_list, submessage_arena);
    }
    
  } else {
    
  }
  task_point_list_ = task_point_list;
  // @@protoc_insertion_point(field_set_allocated:xsproto.hdmap.LocalHDMapEx.task_point_list)
}

// repeated .xsproto.hdmap.Linestring linestrings = 6;
inline int LocalHDMapEx::linestrings_size() const {
  return linestrings_.size();
}
inline void LocalHDMapEx::clear_linestrings() {
  linestrings_.Clear();
}
inline const ::xsproto::hdmap::Linestring& LocalHDMapEx::linestrings(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.linestrings)
  return linestrings_.Get(index);
}
inline ::xsproto::hdmap::Linestring* LocalHDMapEx::mutable_linestrings(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.linestrings)
  return linestrings_.Mutable(index);
}
inline ::xsproto::hdmap::Linestring* LocalHDMapEx::add_linestrings() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.linestrings)
  return linestrings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Linestring >*
LocalHDMapEx::mutable_linestrings() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.linestrings)
  return &linestrings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Linestring >&
LocalHDMapEx::linestrings() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.linestrings)
  return linestrings_;
}

// repeated .xsproto.hdmap.Lane lanes = 7;
inline int LocalHDMapEx::lanes_size() const {
  return lanes_.size();
}
inline void LocalHDMapEx::clear_lanes() {
  lanes_.Clear();
}
inline const ::xsproto::hdmap::Lane& LocalHDMapEx::lanes(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.lanes)
  return lanes_.Get(index);
}
inline ::xsproto::hdmap::Lane* LocalHDMapEx::mutable_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.lanes)
  return lanes_.Mutable(index);
}
inline ::xsproto::hdmap::Lane* LocalHDMapEx::add_lanes() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.lanes)
  return lanes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Lane >*
LocalHDMapEx::mutable_lanes() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.lanes)
  return &lanes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Lane >&
LocalHDMapEx::lanes() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.lanes)
  return lanes_;
}

// repeated .xsproto.hdmap.Road roads = 8;
inline int LocalHDMapEx::roads_size() const {
  return roads_.size();
}
inline void LocalHDMapEx::clear_roads() {
  roads_.Clear();
}
inline const ::xsproto::hdmap::Road& LocalHDMapEx::roads(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.roads)
  return roads_.Get(index);
}
inline ::xsproto::hdmap::Road* LocalHDMapEx::mutable_roads(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.roads)
  return roads_.Mutable(index);
}
inline ::xsproto::hdmap::Road* LocalHDMapEx::add_roads() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.roads)
  return roads_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Road >*
LocalHDMapEx::mutable_roads() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.roads)
  return &roads_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Road >&
LocalHDMapEx::roads() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.roads)
  return roads_;
}

// repeated .xsproto.hdmap.Area areas = 9;
inline int LocalHDMapEx::areas_size() const {
  return areas_.size();
}
inline void LocalHDMapEx::clear_areas() {
  areas_.Clear();
}
inline const ::xsproto::hdmap::Area& LocalHDMapEx::areas(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.areas)
  return areas_.Get(index);
}
inline ::xsproto::hdmap::Area* LocalHDMapEx::mutable_areas(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.areas)
  return areas_.Mutable(index);
}
inline ::xsproto::hdmap::Area* LocalHDMapEx::add_areas() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.areas)
  return areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Area >*
LocalHDMapEx::mutable_areas() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.areas)
  return &areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Area >&
LocalHDMapEx::areas() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.areas)
  return areas_;
}

// repeated .xsproto.hdmap.Stopline stoplines = 10;
inline int LocalHDMapEx::stoplines_size() const {
  return stoplines_.size();
}
inline void LocalHDMapEx::clear_stoplines() {
  stoplines_.Clear();
}
inline const ::xsproto::hdmap::Stopline& LocalHDMapEx::stoplines(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.stoplines)
  return stoplines_.Get(index);
}
inline ::xsproto::hdmap::Stopline* LocalHDMapEx::mutable_stoplines(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.stoplines)
  return stoplines_.Mutable(index);
}
inline ::xsproto::hdmap::Stopline* LocalHDMapEx::add_stoplines() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.stoplines)
  return stoplines_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Stopline >*
LocalHDMapEx::mutable_stoplines() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.stoplines)
  return &stoplines_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Stopline >&
LocalHDMapEx::stoplines() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.stoplines)
  return stoplines_;
}

// repeated .xsproto.hdmap.Junction junctions = 11;
inline int LocalHDMapEx::junctions_size() const {
  return junctions_.size();
}
inline void LocalHDMapEx::clear_junctions() {
  junctions_.Clear();
}
inline const ::xsproto::hdmap::Junction& LocalHDMapEx::junctions(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.junctions)
  return junctions_.Get(index);
}
inline ::xsproto::hdmap::Junction* LocalHDMapEx::mutable_junctions(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.junctions)
  return junctions_.Mutable(index);
}
inline ::xsproto::hdmap::Junction* LocalHDMapEx::add_junctions() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.junctions)
  return junctions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Junction >*
LocalHDMapEx::mutable_junctions() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.junctions)
  return &junctions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Junction >&
LocalHDMapEx::junctions() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.junctions)
  return junctions_;
}

// repeated .xsproto.hdmap.Obstacle obstacles = 12;
inline int LocalHDMapEx::obstacles_size() const {
  return obstacles_.size();
}
inline void LocalHDMapEx::clear_obstacles() {
  obstacles_.Clear();
}
inline const ::xsproto::hdmap::Obstacle& LocalHDMapEx::obstacles(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.obstacles)
  return obstacles_.Get(index);
}
inline ::xsproto::hdmap::Obstacle* LocalHDMapEx::mutable_obstacles(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.obstacles)
  return obstacles_.Mutable(index);
}
inline ::xsproto::hdmap::Obstacle* LocalHDMapEx::add_obstacles() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.obstacles)
  return obstacles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Obstacle >*
LocalHDMapEx::mutable_obstacles() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.obstacles)
  return &obstacles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Obstacle >&
LocalHDMapEx::obstacles() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.obstacles)
  return obstacles_;
}

// repeated .xsproto.hdmap.ParkingSpace parking_spaces = 13;
inline int LocalHDMapEx::parking_spaces_size() const {
  return parking_spaces_.size();
}
inline void LocalHDMapEx::clear_parking_spaces() {
  parking_spaces_.Clear();
}
inline const ::xsproto::hdmap::ParkingSpace& LocalHDMapEx::parking_spaces(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.parking_spaces)
  return parking_spaces_.Get(index);
}
inline ::xsproto::hdmap::ParkingSpace* LocalHDMapEx::mutable_parking_spaces(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.parking_spaces)
  return parking_spaces_.Mutable(index);
}
inline ::xsproto::hdmap::ParkingSpace* LocalHDMapEx::add_parking_spaces() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.parking_spaces)
  return parking_spaces_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ParkingSpace >*
LocalHDMapEx::mutable_parking_spaces() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.parking_spaces)
  return &parking_spaces_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::ParkingSpace >&
LocalHDMapEx::parking_spaces() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.parking_spaces)
  return parking_spaces_;
}

// repeated .xsproto.hdmap.Concavity concavities = 14;
inline int LocalHDMapEx::concavities_size() const {
  return concavities_.size();
}
inline void LocalHDMapEx::clear_concavities() {
  concavities_.Clear();
}
inline const ::xsproto::hdmap::Concavity& LocalHDMapEx::concavities(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.concavities)
  return concavities_.Get(index);
}
inline ::xsproto::hdmap::Concavity* LocalHDMapEx::mutable_concavities(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.concavities)
  return concavities_.Mutable(index);
}
inline ::xsproto::hdmap::Concavity* LocalHDMapEx::add_concavities() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.concavities)
  return concavities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Concavity >*
LocalHDMapEx::mutable_concavities() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.concavities)
  return &concavities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Concavity >&
LocalHDMapEx::concavities() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.concavities)
  return concavities_;
}

// repeated .xsproto.hdmap.Alley alleys = 15;
inline int LocalHDMapEx::alleys_size() const {
  return alleys_.size();
}
inline void LocalHDMapEx::clear_alleys() {
  alleys_.Clear();
}
inline const ::xsproto::hdmap::Alley& LocalHDMapEx::alleys(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.alleys)
  return alleys_.Get(index);
}
inline ::xsproto::hdmap::Alley* LocalHDMapEx::mutable_alleys(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.alleys)
  return alleys_.Mutable(index);
}
inline ::xsproto::hdmap::Alley* LocalHDMapEx::add_alleys() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.alleys)
  return alleys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Alley >*
LocalHDMapEx::mutable_alleys() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.alleys)
  return &alleys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::Alley >&
LocalHDMapEx::alleys() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.alleys)
  return alleys_;
}

// repeated .xsproto.hdmap.PassableArea passable_areas = 16;
inline int LocalHDMapEx::passable_areas_size() const {
  return passable_areas_.size();
}
inline void LocalHDMapEx::clear_passable_areas() {
  passable_areas_.Clear();
}
inline const ::xsproto::hdmap::PassableArea& LocalHDMapEx::passable_areas(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.passable_areas)
  return passable_areas_.Get(index);
}
inline ::xsproto::hdmap::PassableArea* LocalHDMapEx::mutable_passable_areas(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.passable_areas)
  return passable_areas_.Mutable(index);
}
inline ::xsproto::hdmap::PassableArea* LocalHDMapEx::add_passable_areas() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.passable_areas)
  return passable_areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::PassableArea >*
LocalHDMapEx::mutable_passable_areas() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.passable_areas)
  return &passable_areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::PassableArea >&
LocalHDMapEx::passable_areas() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.passable_areas)
  return passable_areas_;
}

// repeated .xsproto.hdmap.NoObstacleArea no_obstacle_areas = 17;
inline int LocalHDMapEx::no_obstacle_areas_size() const {
  return no_obstacle_areas_.size();
}
inline void LocalHDMapEx::clear_no_obstacle_areas() {
  no_obstacle_areas_.Clear();
}
inline const ::xsproto::hdmap::NoObstacleArea& LocalHDMapEx::no_obstacle_areas(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.no_obstacle_areas)
  return no_obstacle_areas_.Get(index);
}
inline ::xsproto::hdmap::NoObstacleArea* LocalHDMapEx::mutable_no_obstacle_areas(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.no_obstacle_areas)
  return no_obstacle_areas_.Mutable(index);
}
inline ::xsproto::hdmap::NoObstacleArea* LocalHDMapEx::add_no_obstacle_areas() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.no_obstacle_areas)
  return no_obstacle_areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::NoObstacleArea >*
LocalHDMapEx::mutable_no_obstacle_areas() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.no_obstacle_areas)
  return &no_obstacle_areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::NoObstacleArea >&
LocalHDMapEx::no_obstacle_areas() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.no_obstacle_areas)
  return no_obstacle_areas_;
}

// repeated .xsproto.hdmap.PedestrianCrossing pedestrian_crossing_areas = 18;
inline int LocalHDMapEx::pedestrian_crossing_areas_size() const {
  return pedestrian_crossing_areas_.size();
}
inline void LocalHDMapEx::clear_pedestrian_crossing_areas() {
  pedestrian_crossing_areas_.Clear();
}
inline const ::xsproto::hdmap::PedestrianCrossing& LocalHDMapEx::pedestrian_crossing_areas(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.pedestrian_crossing_areas)
  return pedestrian_crossing_areas_.Get(index);
}
inline ::xsproto::hdmap::PedestrianCrossing* LocalHDMapEx::mutable_pedestrian_crossing_areas(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.pedestrian_crossing_areas)
  return pedestrian_crossing_areas_.Mutable(index);
}
inline ::xsproto::hdmap::PedestrianCrossing* LocalHDMapEx::add_pedestrian_crossing_areas() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.pedestrian_crossing_areas)
  return pedestrian_crossing_areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::PedestrianCrossing >*
LocalHDMapEx::mutable_pedestrian_crossing_areas() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.pedestrian_crossing_areas)
  return &pedestrian_crossing_areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::PedestrianCrossing >&
LocalHDMapEx::pedestrian_crossing_areas() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.pedestrian_crossing_areas)
  return pedestrian_crossing_areas_;
}

// repeated .xsproto.hdmap.TrafficLightPole trafficlight_poles = 19;
inline int LocalHDMapEx::trafficlight_poles_size() const {
  return trafficlight_poles_.size();
}
inline void LocalHDMapEx::clear_trafficlight_poles() {
  trafficlight_poles_.Clear();
}
inline const ::xsproto::hdmap::TrafficLightPole& LocalHDMapEx::trafficlight_poles(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMapEx.trafficlight_poles)
  return trafficlight_poles_.Get(index);
}
inline ::xsproto::hdmap::TrafficLightPole* LocalHDMapEx::mutable_trafficlight_poles(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMapEx.trafficlight_poles)
  return trafficlight_poles_.Mutable(index);
}
inline ::xsproto::hdmap::TrafficLightPole* LocalHDMapEx::add_trafficlight_poles() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMapEx.trafficlight_poles)
  return trafficlight_poles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::TrafficLightPole >*
LocalHDMapEx::mutable_trafficlight_poles() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMapEx.trafficlight_poles)
  return &trafficlight_poles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::TrafficLightPole >&
LocalHDMapEx::trafficlight_poles() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMapEx.trafficlight_poles)
  return trafficlight_poles_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hdmap
}  // namespace xsproto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::xsproto::hdmap::Lane_LaneChangeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::hdmap::Lane_LaneChangeType>() {
  return ::xsproto::hdmap::Lane_LaneChangeType_descriptor();
}
template <> struct is_proto_enum< ::xsproto::hdmap::AreaGap_GapType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::hdmap::AreaGap_GapType>() {
  return ::xsproto::hdmap::AreaGap_GapType_descriptor();
}
template <> struct is_proto_enum< ::xsproto::hdmap::PassRule> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::hdmap::PassRule>() {
  return ::xsproto::hdmap::PassRule_descriptor();
}
template <> struct is_proto_enum< ::xsproto::hdmap::PassDirection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::hdmap::PassDirection>() {
  return ::xsproto::hdmap::PassDirection_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_hdmap_2flocal_5fhdmap_5fex_2eproto__INCLUDED
