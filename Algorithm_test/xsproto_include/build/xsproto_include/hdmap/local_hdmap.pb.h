// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hdmap/local_hdmap.proto

#ifndef PROTOBUF_hdmap_2flocal_5fhdmap_2eproto__INCLUDED
#define PROTOBUF_hdmap_2flocal_5fhdmap_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "base/header.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_hdmap_2flocal_5fhdmap_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRoadMarkingImpl();
void InitDefaultsRoadMarking();
void InitDefaultsMapObstacleImpl();
void InitDefaultsMapObstacle();
void InitDefaultsMapParkingImpl();
void InitDefaultsMapParking();
void InitDefaultsLaneMarkingPointImpl();
void InitDefaultsLaneMarkingPoint();
void InitDefaultsMapLaneMarkingImpl();
void InitDefaultsMapLaneMarking();
void InitDefaultsMapAreaInoutPointImpl();
void InitDefaultsMapAreaInoutPoint();
void InitDefaultsMapAreaImpl();
void InitDefaultsMapArea();
void InitDefaultsMapConcavityImpl();
void InitDefaultsMapConcavity();
void InitDefaultsMapAlleyImpl();
void InitDefaultsMapAlley();
void InitDefaultsMapPassableAreaImpl();
void InitDefaultsMapPassableArea();
void InitDefaultsMapNoObstacleAreaImpl();
void InitDefaultsMapNoObstacleArea();
void InitDefaultsMapOddAreaImpl();
void InitDefaultsMapOddArea();
void InitDefaultsMapTransferAreaImpl();
void InitDefaultsMapTransferArea();
void InitDefaultsMapPropertyAreaImpl();
void InitDefaultsMapPropertyArea();
void InitDefaultsMapQueuingAreaImpl();
void InitDefaultsMapQueuingArea();
void InitDefaultsMapStopLineImpl();
void InitDefaultsMapStopLine();
void InitDefaultsMapSpeedLimitAreaImpl();
void InitDefaultsMapSpeedLimitArea();
void InitDefaultsMapSpeedhumpImpl();
void InitDefaultsMapSpeedhump();
void InitDefaultsMapTrafficLightImpl();
void InitDefaultsMapTrafficLight();
void InitDefaultsLocalHDMapImpl();
void InitDefaultsLocalHDMap();
inline void InitDefaults() {
  InitDefaultsRoadMarking();
  InitDefaultsMapObstacle();
  InitDefaultsMapParking();
  InitDefaultsLaneMarkingPoint();
  InitDefaultsMapLaneMarking();
  InitDefaultsMapAreaInoutPoint();
  InitDefaultsMapArea();
  InitDefaultsMapConcavity();
  InitDefaultsMapAlley();
  InitDefaultsMapPassableArea();
  InitDefaultsMapNoObstacleArea();
  InitDefaultsMapOddArea();
  InitDefaultsMapTransferArea();
  InitDefaultsMapPropertyArea();
  InitDefaultsMapQueuingArea();
  InitDefaultsMapStopLine();
  InitDefaultsMapSpeedLimitArea();
  InitDefaultsMapSpeedhump();
  InitDefaultsMapTrafficLight();
  InitDefaultsLocalHDMap();
}
}  // namespace protobuf_hdmap_2flocal_5fhdmap_2eproto
namespace xsproto {
namespace hdmap {
class LaneMarkingPoint;
class LaneMarkingPointDefaultTypeInternal;
extern LaneMarkingPointDefaultTypeInternal _LaneMarkingPoint_default_instance_;
class LocalHDMap;
class LocalHDMapDefaultTypeInternal;
extern LocalHDMapDefaultTypeInternal _LocalHDMap_default_instance_;
class MapAlley;
class MapAlleyDefaultTypeInternal;
extern MapAlleyDefaultTypeInternal _MapAlley_default_instance_;
class MapArea;
class MapAreaDefaultTypeInternal;
extern MapAreaDefaultTypeInternal _MapArea_default_instance_;
class MapAreaInoutPoint;
class MapAreaInoutPointDefaultTypeInternal;
extern MapAreaInoutPointDefaultTypeInternal _MapAreaInoutPoint_default_instance_;
class MapConcavity;
class MapConcavityDefaultTypeInternal;
extern MapConcavityDefaultTypeInternal _MapConcavity_default_instance_;
class MapLaneMarking;
class MapLaneMarkingDefaultTypeInternal;
extern MapLaneMarkingDefaultTypeInternal _MapLaneMarking_default_instance_;
class MapNoObstacleArea;
class MapNoObstacleAreaDefaultTypeInternal;
extern MapNoObstacleAreaDefaultTypeInternal _MapNoObstacleArea_default_instance_;
class MapObstacle;
class MapObstacleDefaultTypeInternal;
extern MapObstacleDefaultTypeInternal _MapObstacle_default_instance_;
class MapOddArea;
class MapOddAreaDefaultTypeInternal;
extern MapOddAreaDefaultTypeInternal _MapOddArea_default_instance_;
class MapParking;
class MapParkingDefaultTypeInternal;
extern MapParkingDefaultTypeInternal _MapParking_default_instance_;
class MapPassableArea;
class MapPassableAreaDefaultTypeInternal;
extern MapPassableAreaDefaultTypeInternal _MapPassableArea_default_instance_;
class MapPropertyArea;
class MapPropertyAreaDefaultTypeInternal;
extern MapPropertyAreaDefaultTypeInternal _MapPropertyArea_default_instance_;
class MapQueuingArea;
class MapQueuingAreaDefaultTypeInternal;
extern MapQueuingAreaDefaultTypeInternal _MapQueuingArea_default_instance_;
class MapSpeedLimitArea;
class MapSpeedLimitAreaDefaultTypeInternal;
extern MapSpeedLimitAreaDefaultTypeInternal _MapSpeedLimitArea_default_instance_;
class MapSpeedhump;
class MapSpeedhumpDefaultTypeInternal;
extern MapSpeedhumpDefaultTypeInternal _MapSpeedhump_default_instance_;
class MapStopLine;
class MapStopLineDefaultTypeInternal;
extern MapStopLineDefaultTypeInternal _MapStopLine_default_instance_;
class MapTrafficLight;
class MapTrafficLightDefaultTypeInternal;
extern MapTrafficLightDefaultTypeInternal _MapTrafficLight_default_instance_;
class MapTransferArea;
class MapTransferAreaDefaultTypeInternal;
extern MapTransferAreaDefaultTypeInternal _MapTransferArea_default_instance_;
class RoadMarking;
class RoadMarkingDefaultTypeInternal;
extern RoadMarkingDefaultTypeInternal _RoadMarking_default_instance_;
}  // namespace hdmap
}  // namespace xsproto
namespace xsproto {
namespace hdmap {

enum LaneTurnType {
  NO_TURN = 0,
  JUNCTION_TURN_LEFT = 1,
  JUNCTION_TURN_GO_STRAIGHT = 2,
  JUNCTION_TURN_RIGHT = 3,
  JUNCTION_TURN_U_TURN = 4,
  NORMAL_TURN_LEFT = 5,
  NORMAL_TURN_RIGHT = 6,
  NORMAL_TURN_U_TURN = 7,
  LaneTurnType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LaneTurnType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LaneTurnType_IsValid(int value);
const LaneTurnType LaneTurnType_MIN = NO_TURN;
const LaneTurnType LaneTurnType_MAX = NORMAL_TURN_U_TURN;
const int LaneTurnType_ARRAYSIZE = LaneTurnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneTurnType_descriptor();
inline const ::std::string& LaneTurnType_Name(LaneTurnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneTurnType_descriptor(), value);
}
inline bool LaneTurnType_Parse(
    const ::std::string& name, LaneTurnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneTurnType>(
    LaneTurnType_descriptor(), name, value);
}
enum LaneType {
  FOR_VEHICLE = 0,
  FOR_EMERGENCY = 1,
  FOR_BUS = 2,
  FOR_BICYCLE = 3,
  FOR_PEDESTIAN = 4,
  LaneType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LaneType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LaneType_IsValid(int value);
const LaneType LaneType_MIN = FOR_VEHICLE;
const LaneType LaneType_MAX = FOR_PEDESTIAN;
const int LaneType_ARRAYSIZE = LaneType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneType_descriptor();
inline const ::std::string& LaneType_Name(LaneType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneType_descriptor(), value);
}
inline bool LaneType_Parse(
    const ::std::string& name, LaneType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneType>(
    LaneType_descriptor(), name, value);
}
enum LaneChangeRole {
  BI_ALLOWED = 0,
  BI_FORBIDDEN = 1,
  UNI_LEFT_TO_RIGHT = 2,
  UNI_RIGHT_TO_LEFT = 3,
  LaneChangeRole_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LaneChangeRole_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LaneChangeRole_IsValid(int value);
const LaneChangeRole LaneChangeRole_MIN = BI_ALLOWED;
const LaneChangeRole LaneChangeRole_MAX = UNI_RIGHT_TO_LEFT;
const int LaneChangeRole_ARRAYSIZE = LaneChangeRole_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneChangeRole_descriptor();
inline const ::std::string& LaneChangeRole_Name(LaneChangeRole value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneChangeRole_descriptor(), value);
}
inline bool LaneChangeRole_Parse(
    const ::std::string& name, LaneChangeRole* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneChangeRole>(
    LaneChangeRole_descriptor(), name, value);
}
enum TrafficDirection {
  UNI_DIRECTION = 0,
  BI_DIRECTION = 1,
  TrafficDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficDirection_IsValid(int value);
const TrafficDirection TrafficDirection_MIN = UNI_DIRECTION;
const TrafficDirection TrafficDirection_MAX = BI_DIRECTION;
const int TrafficDirection_ARRAYSIZE = TrafficDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficDirection_descriptor();
inline const ::std::string& TrafficDirection_Name(TrafficDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficDirection_descriptor(), value);
}
inline bool TrafficDirection_Parse(
    const ::std::string& name, TrafficDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficDirection>(
    TrafficDirection_descriptor(), name, value);
}
enum RampWayType {
  RWT_IN_NULL = 0,
  RWT_IN_LEFT = 1,
  RWT_IN_RIGHT = 2,
  RWT_OUT_LEFT = 3,
  RWT_OUT_RIGHT = 4,
  RampWayType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RampWayType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RampWayType_IsValid(int value);
const RampWayType RampWayType_MIN = RWT_IN_NULL;
const RampWayType RampWayType_MAX = RWT_OUT_RIGHT;
const int RampWayType_ARRAYSIZE = RampWayType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RampWayType_descriptor();
inline const ::std::string& RampWayType_Name(RampWayType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RampWayType_descriptor(), value);
}
inline bool RampWayType_Parse(
    const ::std::string& name, RampWayType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RampWayType>(
    RampWayType_descriptor(), name, value);
}
enum TrafficLighShapeType {
  CIRCLE = 0,
  ARROW = 1,
  TrafficLighShapeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficLighShapeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficLighShapeType_IsValid(int value);
const TrafficLighShapeType TrafficLighShapeType_MIN = CIRCLE;
const TrafficLighShapeType TrafficLighShapeType_MAX = ARROW;
const int TrafficLighShapeType_ARRAYSIZE = TrafficLighShapeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLighShapeType_descriptor();
inline const ::std::string& TrafficLighShapeType_Name(TrafficLighShapeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLighShapeType_descriptor(), value);
}
inline bool TrafficLighShapeType_Parse(
    const ::std::string& name, TrafficLighShapeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLighShapeType>(
    TrafficLighShapeType_descriptor(), name, value);
}
enum TrafficLightRangeWay {
  HORIZONTAL = 0,
  VERTICAL = 2,
  TrafficLightRangeWay_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficLightRangeWay_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficLightRangeWay_IsValid(int value);
const TrafficLightRangeWay TrafficLightRangeWay_MIN = HORIZONTAL;
const TrafficLightRangeWay TrafficLightRangeWay_MAX = VERTICAL;
const int TrafficLightRangeWay_ARRAYSIZE = TrafficLightRangeWay_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLightRangeWay_descriptor();
inline const ::std::string& TrafficLightRangeWay_Name(TrafficLightRangeWay value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLightRangeWay_descriptor(), value);
}
inline bool TrafficLightRangeWay_Parse(
    const ::std::string& name, TrafficLightRangeWay* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLightRangeWay>(
    TrafficLightRangeWay_descriptor(), name, value);
}
// ===================================================================

class RoadMarking : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.RoadMarking) */ {
 public:
  RoadMarking();
  virtual ~RoadMarking();

  RoadMarking(const RoadMarking& from);

  inline RoadMarking& operator=(const RoadMarking& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadMarking(RoadMarking&& from) noexcept
    : RoadMarking() {
    *this = ::std::move(from);
  }

  inline RoadMarking& operator=(RoadMarking&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadMarking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadMarking* internal_default_instance() {
    return reinterpret_cast<const RoadMarking*>(
               &_RoadMarking_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RoadMarking* other);
  friend void swap(RoadMarking& a, RoadMarking& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadMarking* New() const PROTOBUF_FINAL { return New(NULL); }

  RoadMarking* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoadMarking& from);
  void MergeFrom(const RoadMarking& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoadMarking* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double bottomleftx = 1;
  void clear_bottomleftx();
  static const int kBottomleftxFieldNumber = 1;
  double bottomleftx() const;
  void set_bottomleftx(double value);

  // double bottomlefty = 2;
  void clear_bottomlefty();
  static const int kBottomleftyFieldNumber = 2;
  double bottomlefty() const;
  void set_bottomlefty(double value);

  // double bottomrightx = 3;
  void clear_bottomrightx();
  static const int kBottomrightxFieldNumber = 3;
  double bottomrightx() const;
  void set_bottomrightx(double value);

  // double bottomrighty = 4;
  void clear_bottomrighty();
  static const int kBottomrightyFieldNumber = 4;
  double bottomrighty() const;
  void set_bottomrighty(double value);

  // double topleftx = 5;
  void clear_topleftx();
  static const int kTopleftxFieldNumber = 5;
  double topleftx() const;
  void set_topleftx(double value);

  // double toplefty = 6;
  void clear_toplefty();
  static const int kTopleftyFieldNumber = 6;
  double toplefty() const;
  void set_toplefty(double value);

  // double toprightx = 7;
  void clear_toprightx();
  static const int kToprightxFieldNumber = 7;
  double toprightx() const;
  void set_toprightx(double value);

  // double toprighty = 8;
  void clear_toprighty();
  static const int kToprightyFieldNumber = 8;
  double toprighty() const;
  void set_toprighty(double value);

  // int32 direction = 9;
  void clear_direction();
  static const int kDirectionFieldNumber = 9;
  ::google::protobuf::int32 direction() const;
  void set_direction(::google::protobuf::int32 value);

  // int32 width = 10;
  void clear_width();
  static const int kWidthFieldNumber = 10;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // int32 sign_type = 11;
  void clear_sign_type();
  static const int kSignTypeFieldNumber = 11;
  ::google::protobuf::int32 sign_type() const;
  void set_sign_type(::google::protobuf::int32 value);

  // int32 road_id = 12;
  void clear_road_id();
  static const int kRoadIdFieldNumber = 12;
  ::google::protobuf::int32 road_id() const;
  void set_road_id(::google::protobuf::int32 value);

  // int32 lane_id = 13;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 13;
  ::google::protobuf::int32 lane_id() const;
  void set_lane_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.RoadMarking)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double bottomleftx_;
  double bottomlefty_;
  double bottomrightx_;
  double bottomrighty_;
  double topleftx_;
  double toplefty_;
  double toprightx_;
  double toprighty_;
  ::google::protobuf::int32 direction_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 sign_type_;
  ::google::protobuf::int32 road_id_;
  ::google::protobuf::int32 lane_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsRoadMarkingImpl();
};
// -------------------------------------------------------------------

class MapObstacle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapObstacle) */ {
 public:
  MapObstacle();
  virtual ~MapObstacle();

  MapObstacle(const MapObstacle& from);

  inline MapObstacle& operator=(const MapObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapObstacle(MapObstacle&& from) noexcept
    : MapObstacle() {
    *this = ::std::move(from);
  }

  inline MapObstacle& operator=(MapObstacle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapObstacle* internal_default_instance() {
    return reinterpret_cast<const MapObstacle*>(
               &_MapObstacle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MapObstacle* other);
  friend void swap(MapObstacle& a, MapObstacle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapObstacle* New() const PROTOBUF_FINAL { return New(NULL); }

  MapObstacle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapObstacle& from);
  void MergeFrom(const MapObstacle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapObstacle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 2;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 3;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // int32 attr = 1;
  void clear_attr();
  static const int kAttrFieldNumber = 1;
  ::google::protobuf::int32 attr() const;
  void set_attr(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapObstacle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  ::google::protobuf::int32 attr_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapObstacleImpl();
};
// -------------------------------------------------------------------

class MapParking : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapParking) */ {
 public:
  MapParking();
  virtual ~MapParking();

  MapParking(const MapParking& from);

  inline MapParking& operator=(const MapParking& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapParking(MapParking&& from) noexcept
    : MapParking() {
    *this = ::std::move(from);
  }

  inline MapParking& operator=(MapParking&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapParking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapParking* internal_default_instance() {
    return reinterpret_cast<const MapParking*>(
               &_MapParking_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(MapParking* other);
  friend void swap(MapParking& a, MapParking& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapParking* New() const PROTOBUF_FINAL { return New(NULL); }

  MapParking* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapParking& from);
  void MergeFrom(const MapParking& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapParking* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 3;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 3;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 4;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 4;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 on_road = 2;
  void clear_on_road();
  static const int kOnRoadFieldNumber = 2;
  ::google::protobuf::int32 on_road() const;
  void set_on_road(::google::protobuf::int32 value);

  // double precision_x = 6;
  void clear_precision_x();
  static const int kPrecisionXFieldNumber = 6;
  double precision_x() const;
  void set_precision_x(double value);

  // double precision_y = 7;
  void clear_precision_y();
  static const int kPrecisionYFieldNumber = 7;
  double precision_y() const;
  void set_precision_y(double value);

  // int32 park_type = 5;
  void clear_park_type();
  static const int kParkTypeFieldNumber = 5;
  ::google::protobuf::int32 park_type() const;
  void set_park_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapParking)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 on_road_;
  double precision_x_;
  double precision_y_;
  ::google::protobuf::int32 park_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapParkingImpl();
};
// -------------------------------------------------------------------

class LaneMarkingPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.LaneMarkingPoint) */ {
 public:
  LaneMarkingPoint();
  virtual ~LaneMarkingPoint();

  LaneMarkingPoint(const LaneMarkingPoint& from);

  inline LaneMarkingPoint& operator=(const LaneMarkingPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneMarkingPoint(LaneMarkingPoint&& from) noexcept
    : LaneMarkingPoint() {
    *this = ::std::move(from);
  }

  inline LaneMarkingPoint& operator=(LaneMarkingPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneMarkingPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneMarkingPoint* internal_default_instance() {
    return reinterpret_cast<const LaneMarkingPoint*>(
               &_LaneMarkingPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(LaneMarkingPoint* other);
  friend void swap(LaneMarkingPoint& a, LaneMarkingPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneMarkingPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  LaneMarkingPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LaneMarkingPoint& from);
  void MergeFrom(const LaneMarkingPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LaneMarkingPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // int32 turn_type = 3;
  void clear_turn_type();
  static const int kTurnTypeFieldNumber = 3;
  ::google::protobuf::int32 turn_type() const;
  void set_turn_type(::google::protobuf::int32 value);

  // .xsproto.hdmap.LaneType lane_type = 4;
  void clear_lane_type();
  static const int kLaneTypeFieldNumber = 4;
  ::xsproto::hdmap::LaneType lane_type() const;
  void set_lane_type(::xsproto::hdmap::LaneType value);

  // .xsproto.hdmap.LaneChangeRole lane_change_role = 5;
  void clear_lane_change_role();
  static const int kLaneChangeRoleFieldNumber = 5;
  ::xsproto::hdmap::LaneChangeRole lane_change_role() const;
  void set_lane_change_role(::xsproto::hdmap::LaneChangeRole value);

  // .xsproto.hdmap.TrafficDirection traffic_direction = 6;
  void clear_traffic_direction();
  static const int kTrafficDirectionFieldNumber = 6;
  ::xsproto::hdmap::TrafficDirection traffic_direction() const;
  void set_traffic_direction(::xsproto::hdmap::TrafficDirection value);

  // .xsproto.hdmap.RampWayType ramp_way_type = 7;
  void clear_ramp_way_type();
  static const int kRampWayTypeFieldNumber = 7;
  ::xsproto::hdmap::RampWayType ramp_way_type() const;
  void set_ramp_way_type(::xsproto::hdmap::RampWayType value);

  // int32 stop_line_id = 8;
  void clear_stop_line_id();
  static const int kStopLineIdFieldNumber = 8;
  ::google::protobuf::int32 stop_line_id() const;
  void set_stop_line_id(::google::protobuf::int32 value);

  // int32 pt_type = 9;
  void clear_pt_type();
  static const int kPtTypeFieldNumber = 9;
  ::google::protobuf::int32 pt_type() const;
  void set_pt_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.LaneMarkingPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  ::google::protobuf::int32 turn_type_;
  int lane_type_;
  int lane_change_role_;
  int traffic_direction_;
  int ramp_way_type_;
  ::google::protobuf::int32 stop_line_id_;
  ::google::protobuf::int32 pt_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsLaneMarkingPointImpl();
};
// -------------------------------------------------------------------

class MapLaneMarking : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapLaneMarking) */ {
 public:
  MapLaneMarking();
  virtual ~MapLaneMarking();

  MapLaneMarking(const MapLaneMarking& from);

  inline MapLaneMarking& operator=(const MapLaneMarking& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapLaneMarking(MapLaneMarking&& from) noexcept
    : MapLaneMarking() {
    *this = ::std::move(from);
  }

  inline MapLaneMarking& operator=(MapLaneMarking&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapLaneMarking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapLaneMarking* internal_default_instance() {
    return reinterpret_cast<const MapLaneMarking*>(
               &_MapLaneMarking_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(MapLaneMarking* other);
  friend void swap(MapLaneMarking& a, MapLaneMarking& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapLaneMarking* New() const PROTOBUF_FINAL { return New(NULL); }

  MapLaneMarking* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapLaneMarking& from);
  void MergeFrom(const MapLaneMarking& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapLaneMarking* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 5;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 5;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 6;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 6;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // repeated .xsproto.hdmap.LaneMarkingPoint ext_points = 10;
  int ext_points_size() const;
  void clear_ext_points();
  static const int kExtPointsFieldNumber = 10;
  const ::xsproto::hdmap::LaneMarkingPoint& ext_points(int index) const;
  ::xsproto::hdmap::LaneMarkingPoint* mutable_ext_points(int index);
  ::xsproto::hdmap::LaneMarkingPoint* add_ext_points();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::LaneMarkingPoint >*
      mutable_ext_points();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::LaneMarkingPoint >&
      ext_points() const;

  // int32 road_id = 1;
  void clear_road_id();
  static const int kRoadIdFieldNumber = 1;
  ::google::protobuf::int32 road_id() const;
  void set_road_id(::google::protobuf::int32 value);

  // int32 lane_id = 2;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 2;
  ::google::protobuf::int32 lane_id() const;
  void set_lane_id(::google::protobuf::int32 value);

  // int32 lane_refer = 3;
  void clear_lane_refer();
  static const int kLaneReferFieldNumber = 3;
  ::google::protobuf::int32 lane_refer() const;
  void set_lane_refer(::google::protobuf::int32 value);

  // int32 lane_attr = 4;
  void clear_lane_attr();
  static const int kLaneAttrFieldNumber = 4;
  ::google::protobuf::int32 lane_attr() const;
  void set_lane_attr(::google::protobuf::int32 value);

  // int32 lane_chane_type = 9;
  void clear_lane_chane_type();
  static const int kLaneChaneTypeFieldNumber = 9;
  ::google::protobuf::int32 lane_chane_type() const;
  void set_lane_chane_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapLaneMarking)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::LaneMarkingPoint > ext_points_;
  ::google::protobuf::int32 road_id_;
  ::google::protobuf::int32 lane_id_;
  ::google::protobuf::int32 lane_refer_;
  ::google::protobuf::int32 lane_attr_;
  ::google::protobuf::int32 lane_chane_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapLaneMarkingImpl();
};
// -------------------------------------------------------------------

class MapAreaInoutPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapAreaInoutPoint) */ {
 public:
  MapAreaInoutPoint();
  virtual ~MapAreaInoutPoint();

  MapAreaInoutPoint(const MapAreaInoutPoint& from);

  inline MapAreaInoutPoint& operator=(const MapAreaInoutPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapAreaInoutPoint(MapAreaInoutPoint&& from) noexcept
    : MapAreaInoutPoint() {
    *this = ::std::move(from);
  }

  inline MapAreaInoutPoint& operator=(MapAreaInoutPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapAreaInoutPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapAreaInoutPoint* internal_default_instance() {
    return reinterpret_cast<const MapAreaInoutPoint*>(
               &_MapAreaInoutPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(MapAreaInoutPoint* other);
  friend void swap(MapAreaInoutPoint& a, MapAreaInoutPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapAreaInoutPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  MapAreaInoutPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapAreaInoutPoint& from);
  void MergeFrom(const MapAreaInoutPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapAreaInoutPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double ptx = 2;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx() const;
  void set_ptx(double value);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // double pty = 3;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty() const;
  void set_pty(double value);

  // int32 angle = 5;
  void clear_angle();
  static const int kAngleFieldNumber = 5;
  ::google::protobuf::int32 angle() const;
  void set_angle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapAreaInoutPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double ptx_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;
  double pty_;
  ::google::protobuf::int32 angle_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapAreaInoutPointImpl();
};
// -------------------------------------------------------------------

class MapArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapArea) */ {
 public:
  MapArea();
  virtual ~MapArea();

  MapArea(const MapArea& from);

  inline MapArea& operator=(const MapArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapArea(MapArea&& from) noexcept
    : MapArea() {
    *this = ::std::move(from);
  }

  inline MapArea& operator=(MapArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapArea* internal_default_instance() {
    return reinterpret_cast<const MapArea*>(
               &_MapArea_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(MapArea* other);
  friend void swap(MapArea& a, MapArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapArea* New() const PROTOBUF_FINAL { return New(NULL); }

  MapArea* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapArea& from);
  void MergeFrom(const MapArea& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 2;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 3;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // repeated .xsproto.hdmap.MapObstacle obstacles = 5;
  int obstacles_size() const;
  void clear_obstacles();
  static const int kObstaclesFieldNumber = 5;
  const ::xsproto::hdmap::MapObstacle& obstacles(int index) const;
  ::xsproto::hdmap::MapObstacle* mutable_obstacles(int index);
  ::xsproto::hdmap::MapObstacle* add_obstacles();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapObstacle >*
      mutable_obstacles();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapObstacle >&
      obstacles() const;

  // repeated .xsproto.hdmap.MapAreaInoutPoint inout_points = 6;
  int inout_points_size() const;
  void clear_inout_points();
  static const int kInoutPointsFieldNumber = 6;
  const ::xsproto::hdmap::MapAreaInoutPoint& inout_points(int index) const;
  ::xsproto::hdmap::MapAreaInoutPoint* mutable_inout_points(int index);
  ::xsproto::hdmap::MapAreaInoutPoint* add_inout_points();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapAreaInoutPoint >*
      mutable_inout_points();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapAreaInoutPoint >&
      inout_points() const;

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 attr = 4;
  void clear_attr();
  static const int kAttrFieldNumber = 4;
  ::google::protobuf::int32 attr() const;
  void set_attr(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapObstacle > obstacles_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapAreaInoutPoint > inout_points_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 attr_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapAreaImpl();
};
// -------------------------------------------------------------------

class MapConcavity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapConcavity) */ {
 public:
  MapConcavity();
  virtual ~MapConcavity();

  MapConcavity(const MapConcavity& from);

  inline MapConcavity& operator=(const MapConcavity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapConcavity(MapConcavity&& from) noexcept
    : MapConcavity() {
    *this = ::std::move(from);
  }

  inline MapConcavity& operator=(MapConcavity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapConcavity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapConcavity* internal_default_instance() {
    return reinterpret_cast<const MapConcavity*>(
               &_MapConcavity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(MapConcavity* other);
  friend void swap(MapConcavity& a, MapConcavity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapConcavity* New() const PROTOBUF_FINAL { return New(NULL); }

  MapConcavity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapConcavity& from);
  void MergeFrom(const MapConcavity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapConcavity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 2;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 3;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 attr = 4;
  void clear_attr();
  static const int kAttrFieldNumber = 4;
  ::google::protobuf::int32 attr() const;
  void set_attr(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapConcavity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 attr_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapConcavityImpl();
};
// -------------------------------------------------------------------

class MapAlley : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapAlley) */ {
 public:
  MapAlley();
  virtual ~MapAlley();

  MapAlley(const MapAlley& from);

  inline MapAlley& operator=(const MapAlley& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapAlley(MapAlley&& from) noexcept
    : MapAlley() {
    *this = ::std::move(from);
  }

  inline MapAlley& operator=(MapAlley&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapAlley& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapAlley* internal_default_instance() {
    return reinterpret_cast<const MapAlley*>(
               &_MapAlley_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(MapAlley* other);
  friend void swap(MapAlley& a, MapAlley& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapAlley* New() const PROTOBUF_FINAL { return New(NULL); }

  MapAlley* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapAlley& from);
  void MergeFrom(const MapAlley& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapAlley* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 2;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 3;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 attr = 4;
  void clear_attr();
  static const int kAttrFieldNumber = 4;
  ::google::protobuf::int32 attr() const;
  void set_attr(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapAlley)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 attr_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapAlleyImpl();
};
// -------------------------------------------------------------------

class MapPassableArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapPassableArea) */ {
 public:
  MapPassableArea();
  virtual ~MapPassableArea();

  MapPassableArea(const MapPassableArea& from);

  inline MapPassableArea& operator=(const MapPassableArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapPassableArea(MapPassableArea&& from) noexcept
    : MapPassableArea() {
    *this = ::std::move(from);
  }

  inline MapPassableArea& operator=(MapPassableArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapPassableArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapPassableArea* internal_default_instance() {
    return reinterpret_cast<const MapPassableArea*>(
               &_MapPassableArea_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(MapPassableArea* other);
  friend void swap(MapPassableArea& a, MapPassableArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapPassableArea* New() const PROTOBUF_FINAL { return New(NULL); }

  MapPassableArea* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapPassableArea& from);
  void MergeFrom(const MapPassableArea& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapPassableArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 2;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 3;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 attr = 4;
  void clear_attr();
  static const int kAttrFieldNumber = 4;
  ::google::protobuf::int32 attr() const;
  void set_attr(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapPassableArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 attr_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapPassableAreaImpl();
};
// -------------------------------------------------------------------

class MapNoObstacleArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapNoObstacleArea) */ {
 public:
  MapNoObstacleArea();
  virtual ~MapNoObstacleArea();

  MapNoObstacleArea(const MapNoObstacleArea& from);

  inline MapNoObstacleArea& operator=(const MapNoObstacleArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapNoObstacleArea(MapNoObstacleArea&& from) noexcept
    : MapNoObstacleArea() {
    *this = ::std::move(from);
  }

  inline MapNoObstacleArea& operator=(MapNoObstacleArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapNoObstacleArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapNoObstacleArea* internal_default_instance() {
    return reinterpret_cast<const MapNoObstacleArea*>(
               &_MapNoObstacleArea_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(MapNoObstacleArea* other);
  friend void swap(MapNoObstacleArea& a, MapNoObstacleArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapNoObstacleArea* New() const PROTOBUF_FINAL { return New(NULL); }

  MapNoObstacleArea* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapNoObstacleArea& from);
  void MergeFrom(const MapNoObstacleArea& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapNoObstacleArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 2;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 3;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 attr = 4;
  void clear_attr();
  static const int kAttrFieldNumber = 4;
  ::google::protobuf::int32 attr() const;
  void set_attr(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapNoObstacleArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 attr_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapNoObstacleAreaImpl();
};
// -------------------------------------------------------------------

class MapOddArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapOddArea) */ {
 public:
  MapOddArea();
  virtual ~MapOddArea();

  MapOddArea(const MapOddArea& from);

  inline MapOddArea& operator=(const MapOddArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapOddArea(MapOddArea&& from) noexcept
    : MapOddArea() {
    *this = ::std::move(from);
  }

  inline MapOddArea& operator=(MapOddArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapOddArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapOddArea* internal_default_instance() {
    return reinterpret_cast<const MapOddArea*>(
               &_MapOddArea_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(MapOddArea* other);
  friend void swap(MapOddArea& a, MapOddArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapOddArea* New() const PROTOBUF_FINAL { return New(NULL); }

  MapOddArea* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapOddArea& from);
  void MergeFrom(const MapOddArea& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapOddArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 2;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 3;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 attr = 4;
  void clear_attr();
  static const int kAttrFieldNumber = 4;
  ::google::protobuf::int32 attr() const;
  void set_attr(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapOddArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 attr_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapOddAreaImpl();
};
// -------------------------------------------------------------------

class MapTransferArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapTransferArea) */ {
 public:
  MapTransferArea();
  virtual ~MapTransferArea();

  MapTransferArea(const MapTransferArea& from);

  inline MapTransferArea& operator=(const MapTransferArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapTransferArea(MapTransferArea&& from) noexcept
    : MapTransferArea() {
    *this = ::std::move(from);
  }

  inline MapTransferArea& operator=(MapTransferArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapTransferArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapTransferArea* internal_default_instance() {
    return reinterpret_cast<const MapTransferArea*>(
               &_MapTransferArea_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(MapTransferArea* other);
  friend void swap(MapTransferArea& a, MapTransferArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapTransferArea* New() const PROTOBUF_FINAL { return New(NULL); }

  MapTransferArea* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapTransferArea& from);
  void MergeFrom(const MapTransferArea& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapTransferArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 2;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 3;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 attr = 4;
  void clear_attr();
  static const int kAttrFieldNumber = 4;
  ::google::protobuf::int32 attr() const;
  void set_attr(::google::protobuf::int32 value);

  // int32 floor = 5;
  void clear_floor();
  static const int kFloorFieldNumber = 5;
  ::google::protobuf::int32 floor() const;
  void set_floor(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapTransferArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 attr_;
  ::google::protobuf::int32 floor_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapTransferAreaImpl();
};
// -------------------------------------------------------------------

class MapPropertyArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapPropertyArea) */ {
 public:
  MapPropertyArea();
  virtual ~MapPropertyArea();

  MapPropertyArea(const MapPropertyArea& from);

  inline MapPropertyArea& operator=(const MapPropertyArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapPropertyArea(MapPropertyArea&& from) noexcept
    : MapPropertyArea() {
    *this = ::std::move(from);
  }

  inline MapPropertyArea& operator=(MapPropertyArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapPropertyArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapPropertyArea* internal_default_instance() {
    return reinterpret_cast<const MapPropertyArea*>(
               &_MapPropertyArea_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(MapPropertyArea* other);
  friend void swap(MapPropertyArea& a, MapPropertyArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapPropertyArea* New() const PROTOBUF_FINAL { return New(NULL); }

  MapPropertyArea* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapPropertyArea& from);
  void MergeFrom(const MapPropertyArea& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapPropertyArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 2;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 3;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 property = 4;
  void clear_property();
  static const int kPropertyFieldNumber = 4;
  ::google::protobuf::int32 property() const;
  void set_property(::google::protobuf::int32 value);

  // double distance = 5;
  void clear_distance();
  static const int kDistanceFieldNumber = 5;
  double distance() const;
  void set_distance(double value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapPropertyArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 property_;
  double distance_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapPropertyAreaImpl();
};
// -------------------------------------------------------------------

class MapQueuingArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapQueuingArea) */ {
 public:
  MapQueuingArea();
  virtual ~MapQueuingArea();

  MapQueuingArea(const MapQueuingArea& from);

  inline MapQueuingArea& operator=(const MapQueuingArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapQueuingArea(MapQueuingArea&& from) noexcept
    : MapQueuingArea() {
    *this = ::std::move(from);
  }

  inline MapQueuingArea& operator=(MapQueuingArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapQueuingArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapQueuingArea* internal_default_instance() {
    return reinterpret_cast<const MapQueuingArea*>(
               &_MapQueuingArea_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(MapQueuingArea* other);
  friend void swap(MapQueuingArea& a, MapQueuingArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapQueuingArea* New() const PROTOBUF_FINAL { return New(NULL); }

  MapQueuingArea* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapQueuingArea& from);
  void MergeFrom(const MapQueuingArea& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapQueuingArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 2;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 3;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 arrive_type = 4;
  void clear_arrive_type();
  static const int kArriveTypeFieldNumber = 4;
  ::google::protobuf::int32 arrive_type() const;
  void set_arrive_type(::google::protobuf::int32 value);

  // int32 queuing_span = 5;
  void clear_queuing_span();
  static const int kQueuingSpanFieldNumber = 5;
  ::google::protobuf::int32 queuing_span() const;
  void set_queuing_span(::google::protobuf::int32 value);

  // int32 arv_mht_dis = 6;
  void clear_arv_mht_dis();
  static const int kArvMhtDisFieldNumber = 6;
  ::google::protobuf::int32 arv_mht_dis() const;
  void set_arv_mht_dis(::google::protobuf::int32 value);

  // int32 park_method = 7;
  void clear_park_method();
  static const int kParkMethodFieldNumber = 7;
  ::google::protobuf::int32 park_method() const;
  void set_park_method(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapQueuingArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 arrive_type_;
  ::google::protobuf::int32 queuing_span_;
  ::google::protobuf::int32 arv_mht_dis_;
  ::google::protobuf::int32 park_method_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapQueuingAreaImpl();
};
// -------------------------------------------------------------------

class MapStopLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapStopLine) */ {
 public:
  MapStopLine();
  virtual ~MapStopLine();

  MapStopLine(const MapStopLine& from);

  inline MapStopLine& operator=(const MapStopLine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapStopLine(MapStopLine&& from) noexcept
    : MapStopLine() {
    *this = ::std::move(from);
  }

  inline MapStopLine& operator=(MapStopLine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapStopLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapStopLine* internal_default_instance() {
    return reinterpret_cast<const MapStopLine*>(
               &_MapStopLine_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(MapStopLine* other);
  friend void swap(MapStopLine& a, MapStopLine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapStopLine* New() const PROTOBUF_FINAL { return New(NULL); }

  MapStopLine* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapStopLine& from);
  void MergeFrom(const MapStopLine& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapStopLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 2;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 3;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 line_type = 4;
  void clear_line_type();
  static const int kLineTypeFieldNumber = 4;
  ::google::protobuf::int32 line_type() const;
  void set_line_type(::google::protobuf::int32 value);

  // double stop_time = 5;
  void clear_stop_time();
  static const int kStopTimeFieldNumber = 5;
  double stop_time() const;
  void set_stop_time(double value);

  // int32 traffic_light_id = 6;
  void clear_traffic_light_id();
  static const int kTrafficLightIdFieldNumber = 6;
  ::google::protobuf::int32 traffic_light_id() const;
  void set_traffic_light_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapStopLine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 line_type_;
  double stop_time_;
  ::google::protobuf::int32 traffic_light_id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapStopLineImpl();
};
// -------------------------------------------------------------------

class MapSpeedLimitArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapSpeedLimitArea) */ {
 public:
  MapSpeedLimitArea();
  virtual ~MapSpeedLimitArea();

  MapSpeedLimitArea(const MapSpeedLimitArea& from);

  inline MapSpeedLimitArea& operator=(const MapSpeedLimitArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapSpeedLimitArea(MapSpeedLimitArea&& from) noexcept
    : MapSpeedLimitArea() {
    *this = ::std::move(from);
  }

  inline MapSpeedLimitArea& operator=(MapSpeedLimitArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapSpeedLimitArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapSpeedLimitArea* internal_default_instance() {
    return reinterpret_cast<const MapSpeedLimitArea*>(
               &_MapSpeedLimitArea_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(MapSpeedLimitArea* other);
  friend void swap(MapSpeedLimitArea& a, MapSpeedLimitArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapSpeedLimitArea* New() const PROTOBUF_FINAL { return New(NULL); }

  MapSpeedLimitArea* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapSpeedLimitArea& from);
  void MergeFrom(const MapSpeedLimitArea& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapSpeedLimitArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ptx = 2;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx(int index) const;
  void set_ptx(int index, double value);
  void add_ptx(double value);
  const ::google::protobuf::RepeatedField< double >&
      ptx() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ptx();

  // repeated double pty = 3;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty(int index) const;
  void set_pty(int index, double value);
  void add_pty(double value);
  const ::google::protobuf::RepeatedField< double >&
      pty() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_pty();

  // double limit_speed = 4;
  void clear_limit_speed();
  static const int kLimitSpeedFieldNumber = 4;
  double limit_speed() const;
  void set_limit_speed(double value);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapSpeedLimitArea)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pty_;
  mutable int _pty_cached_byte_size_;
  double limit_speed_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapSpeedLimitAreaImpl();
};
// -------------------------------------------------------------------

class MapSpeedhump : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapSpeedhump) */ {
 public:
  MapSpeedhump();
  virtual ~MapSpeedhump();

  MapSpeedhump(const MapSpeedhump& from);

  inline MapSpeedhump& operator=(const MapSpeedhump& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapSpeedhump(MapSpeedhump&& from) noexcept
    : MapSpeedhump() {
    *this = ::std::move(from);
  }

  inline MapSpeedhump& operator=(MapSpeedhump&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapSpeedhump& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapSpeedhump* internal_default_instance() {
    return reinterpret_cast<const MapSpeedhump*>(
               &_MapSpeedhump_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(MapSpeedhump* other);
  friend void swap(MapSpeedhump& a, MapSpeedhump& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapSpeedhump* New() const PROTOBUF_FINAL { return New(NULL); }

  MapSpeedhump* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapSpeedhump& from);
  void MergeFrom(const MapSpeedhump& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapSpeedhump* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 ptx = 2;
  int ptx_size() const;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  ::google::protobuf::int32 ptx(int index) const;
  void set_ptx(int index, ::google::protobuf::int32 value);
  void add_ptx(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ptx() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ptx();

  // repeated int32 pty = 3;
  int pty_size() const;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  ::google::protobuf::int32 pty(int index) const;
  void set_pty(int index, ::google::protobuf::int32 value);
  void add_pty(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      pty() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_pty();

  // double limit_speed = 4;
  void clear_limit_speed();
  static const int kLimitSpeedFieldNumber = 4;
  double limit_speed() const;
  void set_limit_speed(double value);

  // double height = 5;
  void clear_height();
  static const int kHeightFieldNumber = 5;
  double height() const;
  void set_height(double value);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapSpeedhump)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ptx_;
  mutable int _ptx_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > pty_;
  mutable int _pty_cached_byte_size_;
  double limit_speed_;
  double height_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapSpeedhumpImpl();
};
// -------------------------------------------------------------------

class MapTrafficLight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.MapTrafficLight) */ {
 public:
  MapTrafficLight();
  virtual ~MapTrafficLight();

  MapTrafficLight(const MapTrafficLight& from);

  inline MapTrafficLight& operator=(const MapTrafficLight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapTrafficLight(MapTrafficLight&& from) noexcept
    : MapTrafficLight() {
    *this = ::std::move(from);
  }

  inline MapTrafficLight& operator=(MapTrafficLight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapTrafficLight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapTrafficLight* internal_default_instance() {
    return reinterpret_cast<const MapTrafficLight*>(
               &_MapTrafficLight_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(MapTrafficLight* other);
  friend void swap(MapTrafficLight& a, MapTrafficLight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapTrafficLight* New() const PROTOBUF_FINAL { return New(NULL); }

  MapTrafficLight* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapTrafficLight& from);
  void MergeFrom(const MapTrafficLight& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapTrafficLight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double ptx = 2;
  void clear_ptx();
  static const int kPtxFieldNumber = 2;
  double ptx() const;
  void set_ptx(double value);

  // double pty = 3;
  void clear_pty();
  static const int kPtyFieldNumber = 3;
  double pty() const;
  void set_pty(double value);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // .xsproto.hdmap.TrafficLighShapeType shape_type = 5;
  void clear_shape_type();
  static const int kShapeTypeFieldNumber = 5;
  ::xsproto::hdmap::TrafficLighShapeType shape_type() const;
  void set_shape_type(::xsproto::hdmap::TrafficLighShapeType value);

  // double ptz = 4;
  void clear_ptz();
  static const int kPtzFieldNumber = 4;
  double ptz() const;
  void set_ptz(double value);

  // .xsproto.hdmap.TrafficLightRangeWay range_way = 6;
  void clear_range_way();
  static const int kRangeWayFieldNumber = 6;
  ::xsproto::hdmap::TrafficLightRangeWay range_way() const;
  void set_range_way(::xsproto::hdmap::TrafficLightRangeWay value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.MapTrafficLight)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double ptx_;
  double pty_;
  ::google::protobuf::int32 id_;
  int shape_type_;
  double ptz_;
  int range_way_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsMapTrafficLightImpl();
};
// -------------------------------------------------------------------

class LocalHDMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.hdmap.LocalHDMap) */ {
 public:
  LocalHDMap();
  virtual ~LocalHDMap();

  LocalHDMap(const LocalHDMap& from);

  inline LocalHDMap& operator=(const LocalHDMap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocalHDMap(LocalHDMap&& from) noexcept
    : LocalHDMap() {
    *this = ::std::move(from);
  }

  inline LocalHDMap& operator=(LocalHDMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalHDMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalHDMap* internal_default_instance() {
    return reinterpret_cast<const LocalHDMap*>(
               &_LocalHDMap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(LocalHDMap* other);
  friend void swap(LocalHDMap& a, LocalHDMap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocalHDMap* New() const PROTOBUF_FINAL { return New(NULL); }

  LocalHDMap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LocalHDMap& from);
  void MergeFrom(const LocalHDMap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LocalHDMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.hdmap.RoadMarking markings = 8;
  int markings_size() const;
  void clear_markings();
  static const int kMarkingsFieldNumber = 8;
  const ::xsproto::hdmap::RoadMarking& markings(int index) const;
  ::xsproto::hdmap::RoadMarking* mutable_markings(int index);
  ::xsproto::hdmap::RoadMarking* add_markings();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::RoadMarking >*
      mutable_markings();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::RoadMarking >&
      markings() const;

  // repeated .xsproto.hdmap.MapObstacle obstacles = 9;
  int obstacles_size() const;
  void clear_obstacles();
  static const int kObstaclesFieldNumber = 9;
  const ::xsproto::hdmap::MapObstacle& obstacles(int index) const;
  ::xsproto::hdmap::MapObstacle* mutable_obstacles(int index);
  ::xsproto::hdmap::MapObstacle* add_obstacles();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapObstacle >*
      mutable_obstacles();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapObstacle >&
      obstacles() const;

  // repeated .xsproto.hdmap.MapParking parkings = 10;
  int parkings_size() const;
  void clear_parkings();
  static const int kParkingsFieldNumber = 10;
  const ::xsproto::hdmap::MapParking& parkings(int index) const;
  ::xsproto::hdmap::MapParking* mutable_parkings(int index);
  ::xsproto::hdmap::MapParking* add_parkings();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapParking >*
      mutable_parkings();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapParking >&
      parkings() const;

  // repeated .xsproto.hdmap.MapLaneMarking future_lanemarkings = 11;
  int future_lanemarkings_size() const;
  void clear_future_lanemarkings();
  static const int kFutureLanemarkingsFieldNumber = 11;
  const ::xsproto::hdmap::MapLaneMarking& future_lanemarkings(int index) const;
  ::xsproto::hdmap::MapLaneMarking* mutable_future_lanemarkings(int index);
  ::xsproto::hdmap::MapLaneMarking* add_future_lanemarkings();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapLaneMarking >*
      mutable_future_lanemarkings();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapLaneMarking >&
      future_lanemarkings() const;

  // repeated .xsproto.hdmap.MapLaneMarking past_lanemarkings = 12;
  int past_lanemarkings_size() const;
  void clear_past_lanemarkings();
  static const int kPastLanemarkingsFieldNumber = 12;
  const ::xsproto::hdmap::MapLaneMarking& past_lanemarkings(int index) const;
  ::xsproto::hdmap::MapLaneMarking* mutable_past_lanemarkings(int index);
  ::xsproto::hdmap::MapLaneMarking* add_past_lanemarkings();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapLaneMarking >*
      mutable_past_lanemarkings();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapLaneMarking >&
      past_lanemarkings() const;

  // repeated .xsproto.hdmap.MapArea areas = 14;
  int areas_size() const;
  void clear_areas();
  static const int kAreasFieldNumber = 14;
  const ::xsproto::hdmap::MapArea& areas(int index) const;
  ::xsproto::hdmap::MapArea* mutable_areas(int index);
  ::xsproto::hdmap::MapArea* add_areas();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapArea >*
      mutable_areas();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapArea >&
      areas() const;

  // repeated .xsproto.hdmap.MapConcavity concavities = 15;
  int concavities_size() const;
  void clear_concavities();
  static const int kConcavitiesFieldNumber = 15;
  const ::xsproto::hdmap::MapConcavity& concavities(int index) const;
  ::xsproto::hdmap::MapConcavity* mutable_concavities(int index);
  ::xsproto::hdmap::MapConcavity* add_concavities();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapConcavity >*
      mutable_concavities();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapConcavity >&
      concavities() const;

  // repeated .xsproto.hdmap.MapAlley alleys = 16;
  int alleys_size() const;
  void clear_alleys();
  static const int kAlleysFieldNumber = 16;
  const ::xsproto::hdmap::MapAlley& alleys(int index) const;
  ::xsproto::hdmap::MapAlley* mutable_alleys(int index);
  ::xsproto::hdmap::MapAlley* add_alleys();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapAlley >*
      mutable_alleys();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapAlley >&
      alleys() const;

  // repeated .xsproto.hdmap.MapPassableArea passable_areas = 17;
  int passable_areas_size() const;
  void clear_passable_areas();
  static const int kPassableAreasFieldNumber = 17;
  const ::xsproto::hdmap::MapPassableArea& passable_areas(int index) const;
  ::xsproto::hdmap::MapPassableArea* mutable_passable_areas(int index);
  ::xsproto::hdmap::MapPassableArea* add_passable_areas();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapPassableArea >*
      mutable_passable_areas();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapPassableArea >&
      passable_areas() const;

  // repeated .xsproto.hdmap.MapNoObstacleArea no_obstacle_areas = 18;
  int no_obstacle_areas_size() const;
  void clear_no_obstacle_areas();
  static const int kNoObstacleAreasFieldNumber = 18;
  const ::xsproto::hdmap::MapNoObstacleArea& no_obstacle_areas(int index) const;
  ::xsproto::hdmap::MapNoObstacleArea* mutable_no_obstacle_areas(int index);
  ::xsproto::hdmap::MapNoObstacleArea* add_no_obstacle_areas();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapNoObstacleArea >*
      mutable_no_obstacle_areas();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapNoObstacleArea >&
      no_obstacle_areas() const;

  // repeated .xsproto.hdmap.MapOddArea odd_areas = 19;
  int odd_areas_size() const;
  void clear_odd_areas();
  static const int kOddAreasFieldNumber = 19;
  const ::xsproto::hdmap::MapOddArea& odd_areas(int index) const;
  ::xsproto::hdmap::MapOddArea* mutable_odd_areas(int index);
  ::xsproto::hdmap::MapOddArea* add_odd_areas();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapOddArea >*
      mutable_odd_areas();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapOddArea >&
      odd_areas() const;

  // repeated .xsproto.hdmap.MapTransferArea transfer_areas = 20;
  int transfer_areas_size() const;
  void clear_transfer_areas();
  static const int kTransferAreasFieldNumber = 20;
  const ::xsproto::hdmap::MapTransferArea& transfer_areas(int index) const;
  ::xsproto::hdmap::MapTransferArea* mutable_transfer_areas(int index);
  ::xsproto::hdmap::MapTransferArea* add_transfer_areas();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapTransferArea >*
      mutable_transfer_areas();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapTransferArea >&
      transfer_areas() const;

  // repeated .xsproto.hdmap.MapPropertyArea property_areas = 21;
  int property_areas_size() const;
  void clear_property_areas();
  static const int kPropertyAreasFieldNumber = 21;
  const ::xsproto::hdmap::MapPropertyArea& property_areas(int index) const;
  ::xsproto::hdmap::MapPropertyArea* mutable_property_areas(int index);
  ::xsproto::hdmap::MapPropertyArea* add_property_areas();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapPropertyArea >*
      mutable_property_areas();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapPropertyArea >&
      property_areas() const;

  // repeated .xsproto.hdmap.MapQueuingArea queuing_areas = 22;
  int queuing_areas_size() const;
  void clear_queuing_areas();
  static const int kQueuingAreasFieldNumber = 22;
  const ::xsproto::hdmap::MapQueuingArea& queuing_areas(int index) const;
  ::xsproto::hdmap::MapQueuingArea* mutable_queuing_areas(int index);
  ::xsproto::hdmap::MapQueuingArea* add_queuing_areas();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapQueuingArea >*
      mutable_queuing_areas();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapQueuingArea >&
      queuing_areas() const;

  // repeated .xsproto.hdmap.MapStopLine stop_lines = 23;
  int stop_lines_size() const;
  void clear_stop_lines();
  static const int kStopLinesFieldNumber = 23;
  const ::xsproto::hdmap::MapStopLine& stop_lines(int index) const;
  ::xsproto::hdmap::MapStopLine* mutable_stop_lines(int index);
  ::xsproto::hdmap::MapStopLine* add_stop_lines();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapStopLine >*
      mutable_stop_lines();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapStopLine >&
      stop_lines() const;

  // repeated .xsproto.hdmap.MapSpeedLimitArea speed_limit_areas = 24;
  int speed_limit_areas_size() const;
  void clear_speed_limit_areas();
  static const int kSpeedLimitAreasFieldNumber = 24;
  const ::xsproto::hdmap::MapSpeedLimitArea& speed_limit_areas(int index) const;
  ::xsproto::hdmap::MapSpeedLimitArea* mutable_speed_limit_areas(int index);
  ::xsproto::hdmap::MapSpeedLimitArea* add_speed_limit_areas();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapSpeedLimitArea >*
      mutable_speed_limit_areas();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapSpeedLimitArea >&
      speed_limit_areas() const;

  // repeated .xsproto.hdmap.MapTrafficLight traffic_lights = 25;
  int traffic_lights_size() const;
  void clear_traffic_lights();
  static const int kTrafficLightsFieldNumber = 25;
  const ::xsproto::hdmap::MapTrafficLight& traffic_lights(int index) const;
  ::xsproto::hdmap::MapTrafficLight* mutable_traffic_lights(int index);
  ::xsproto::hdmap::MapTrafficLight* add_traffic_lights();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapTrafficLight >*
      mutable_traffic_lights();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapTrafficLight >&
      traffic_lights() const;

  // repeated .xsproto.hdmap.MapSpeedhump speedhumps = 26;
  int speedhumps_size() const;
  void clear_speedhumps();
  static const int kSpeedhumpsFieldNumber = 26;
  const ::xsproto::hdmap::MapSpeedhump& speedhumps(int index) const;
  ::xsproto::hdmap::MapSpeedhump* mutable_speedhumps(int index);
  ::xsproto::hdmap::MapSpeedhump* add_speedhumps();
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapSpeedhump >*
      mutable_speedhumps();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapSpeedhump >&
      speedhumps() const;

  // .xsproto.base.Header header = 13;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 13;
  const ::xsproto::base::Header& header() const;
  ::xsproto::base::Header* release_header();
  ::xsproto::base::Header* mutable_header();
  void set_allocated_header(::xsproto::base::Header* header);

  // double x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  double x() const;
  void set_x(double value);

  // double y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  double y() const;
  void set_y(double value);

  // double z = 4;
  void clear_z();
  static const int kZFieldNumber = 4;
  double z() const;
  void set_z(double value);

  // double azimuth = 5;
  void clear_azimuth();
  static const int kAzimuthFieldNumber = 5;
  double azimuth() const;
  void set_azimuth(double value);

  // double pitch = 6;
  void clear_pitch();
  static const int kPitchFieldNumber = 6;
  double pitch() const;
  void set_pitch(double value);

  // double roll = 7;
  void clear_roll();
  static const int kRollFieldNumber = 7;
  double roll() const;
  void set_roll(double value);

  // .xsproto.hdmap.RampWayType ramp_way = 27;
  void clear_ramp_way();
  static const int kRampWayFieldNumber = 27;
  ::xsproto::hdmap::RampWayType ramp_way() const;
  void set_ramp_way(::xsproto::hdmap::RampWayType value);

  // @@protoc_insertion_point(class_scope:xsproto.hdmap.LocalHDMap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::RoadMarking > markings_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapObstacle > obstacles_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapParking > parkings_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapLaneMarking > future_lanemarkings_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapLaneMarking > past_lanemarkings_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapArea > areas_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapConcavity > concavities_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapAlley > alleys_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapPassableArea > passable_areas_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapNoObstacleArea > no_obstacle_areas_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapOddArea > odd_areas_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapTransferArea > transfer_areas_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapPropertyArea > property_areas_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapQueuingArea > queuing_areas_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapStopLine > stop_lines_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapSpeedLimitArea > speed_limit_areas_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapTrafficLight > traffic_lights_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapSpeedhump > speedhumps_;
  ::xsproto::base::Header* header_;
  double x_;
  double y_;
  double z_;
  double azimuth_;
  double pitch_;
  double roll_;
  int ramp_way_;
  mutable int _cached_size_;
  friend struct ::protobuf_hdmap_2flocal_5fhdmap_2eproto::TableStruct;
  friend void ::protobuf_hdmap_2flocal_5fhdmap_2eproto::InitDefaultsLocalHDMapImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RoadMarking

// double bottomleftx = 1;
inline void RoadMarking::clear_bottomleftx() {
  bottomleftx_ = 0;
}
inline double RoadMarking::bottomleftx() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadMarking.bottomleftx)
  return bottomleftx_;
}
inline void RoadMarking::set_bottomleftx(double value) {
  
  bottomleftx_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadMarking.bottomleftx)
}

// double bottomlefty = 2;
inline void RoadMarking::clear_bottomlefty() {
  bottomlefty_ = 0;
}
inline double RoadMarking::bottomlefty() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadMarking.bottomlefty)
  return bottomlefty_;
}
inline void RoadMarking::set_bottomlefty(double value) {
  
  bottomlefty_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadMarking.bottomlefty)
}

// double bottomrightx = 3;
inline void RoadMarking::clear_bottomrightx() {
  bottomrightx_ = 0;
}
inline double RoadMarking::bottomrightx() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadMarking.bottomrightx)
  return bottomrightx_;
}
inline void RoadMarking::set_bottomrightx(double value) {
  
  bottomrightx_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadMarking.bottomrightx)
}

// double bottomrighty = 4;
inline void RoadMarking::clear_bottomrighty() {
  bottomrighty_ = 0;
}
inline double RoadMarking::bottomrighty() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadMarking.bottomrighty)
  return bottomrighty_;
}
inline void RoadMarking::set_bottomrighty(double value) {
  
  bottomrighty_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadMarking.bottomrighty)
}

// double topleftx = 5;
inline void RoadMarking::clear_topleftx() {
  topleftx_ = 0;
}
inline double RoadMarking::topleftx() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadMarking.topleftx)
  return topleftx_;
}
inline void RoadMarking::set_topleftx(double value) {
  
  topleftx_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadMarking.topleftx)
}

// double toplefty = 6;
inline void RoadMarking::clear_toplefty() {
  toplefty_ = 0;
}
inline double RoadMarking::toplefty() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadMarking.toplefty)
  return toplefty_;
}
inline void RoadMarking::set_toplefty(double value) {
  
  toplefty_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadMarking.toplefty)
}

// double toprightx = 7;
inline void RoadMarking::clear_toprightx() {
  toprightx_ = 0;
}
inline double RoadMarking::toprightx() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadMarking.toprightx)
  return toprightx_;
}
inline void RoadMarking::set_toprightx(double value) {
  
  toprightx_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadMarking.toprightx)
}

// double toprighty = 8;
inline void RoadMarking::clear_toprighty() {
  toprighty_ = 0;
}
inline double RoadMarking::toprighty() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadMarking.toprighty)
  return toprighty_;
}
inline void RoadMarking::set_toprighty(double value) {
  
  toprighty_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadMarking.toprighty)
}

// int32 direction = 9;
inline void RoadMarking::clear_direction() {
  direction_ = 0;
}
inline ::google::protobuf::int32 RoadMarking::direction() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadMarking.direction)
  return direction_;
}
inline void RoadMarking::set_direction(::google::protobuf::int32 value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadMarking.direction)
}

// int32 width = 10;
inline void RoadMarking::clear_width() {
  width_ = 0;
}
inline ::google::protobuf::int32 RoadMarking::width() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadMarking.width)
  return width_;
}
inline void RoadMarking::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadMarking.width)
}

// int32 sign_type = 11;
inline void RoadMarking::clear_sign_type() {
  sign_type_ = 0;
}
inline ::google::protobuf::int32 RoadMarking::sign_type() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadMarking.sign_type)
  return sign_type_;
}
inline void RoadMarking::set_sign_type(::google::protobuf::int32 value) {
  
  sign_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadMarking.sign_type)
}

// int32 road_id = 12;
inline void RoadMarking::clear_road_id() {
  road_id_ = 0;
}
inline ::google::protobuf::int32 RoadMarking::road_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadMarking.road_id)
  return road_id_;
}
inline void RoadMarking::set_road_id(::google::protobuf::int32 value) {
  
  road_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadMarking.road_id)
}

// int32 lane_id = 13;
inline void RoadMarking::clear_lane_id() {
  lane_id_ = 0;
}
inline ::google::protobuf::int32 RoadMarking::lane_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.RoadMarking.lane_id)
  return lane_id_;
}
inline void RoadMarking::set_lane_id(::google::protobuf::int32 value) {
  
  lane_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.RoadMarking.lane_id)
}

// -------------------------------------------------------------------

// MapObstacle

// int32 attr = 1;
inline void MapObstacle::clear_attr() {
  attr_ = 0;
}
inline ::google::protobuf::int32 MapObstacle::attr() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapObstacle.attr)
  return attr_;
}
inline void MapObstacle::set_attr(::google::protobuf::int32 value) {
  
  attr_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapObstacle.attr)
}

// repeated double ptx = 2;
inline int MapObstacle::ptx_size() const {
  return ptx_.size();
}
inline void MapObstacle::clear_ptx() {
  ptx_.Clear();
}
inline double MapObstacle::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapObstacle.ptx)
  return ptx_.Get(index);
}
inline void MapObstacle::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapObstacle.ptx)
}
inline void MapObstacle::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapObstacle.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapObstacle::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapObstacle.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapObstacle::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapObstacle.ptx)
  return &ptx_;
}

// repeated double pty = 3;
inline int MapObstacle::pty_size() const {
  return pty_.size();
}
inline void MapObstacle::clear_pty() {
  pty_.Clear();
}
inline double MapObstacle::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapObstacle.pty)
  return pty_.Get(index);
}
inline void MapObstacle::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapObstacle.pty)
}
inline void MapObstacle::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapObstacle.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapObstacle::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapObstacle.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapObstacle::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapObstacle.pty)
  return &pty_;
}

// -------------------------------------------------------------------

// MapParking

// int32 id = 1;
inline void MapParking::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapParking::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapParking.id)
  return id_;
}
inline void MapParking::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapParking.id)
}

// int32 on_road = 2;
inline void MapParking::clear_on_road() {
  on_road_ = 0;
}
inline ::google::protobuf::int32 MapParking::on_road() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapParking.on_road)
  return on_road_;
}
inline void MapParking::set_on_road(::google::protobuf::int32 value) {
  
  on_road_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapParking.on_road)
}

// repeated double ptx = 3;
inline int MapParking::ptx_size() const {
  return ptx_.size();
}
inline void MapParking::clear_ptx() {
  ptx_.Clear();
}
inline double MapParking::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapParking.ptx)
  return ptx_.Get(index);
}
inline void MapParking::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapParking.ptx)
}
inline void MapParking::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapParking.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapParking::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapParking.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapParking::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapParking.ptx)
  return &ptx_;
}

// repeated double pty = 4;
inline int MapParking::pty_size() const {
  return pty_.size();
}
inline void MapParking::clear_pty() {
  pty_.Clear();
}
inline double MapParking::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapParking.pty)
  return pty_.Get(index);
}
inline void MapParking::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapParking.pty)
}
inline void MapParking::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapParking.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapParking::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapParking.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapParking::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapParking.pty)
  return &pty_;
}

// int32 park_type = 5;
inline void MapParking::clear_park_type() {
  park_type_ = 0;
}
inline ::google::protobuf::int32 MapParking::park_type() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapParking.park_type)
  return park_type_;
}
inline void MapParking::set_park_type(::google::protobuf::int32 value) {
  
  park_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapParking.park_type)
}

// double precision_x = 6;
inline void MapParking::clear_precision_x() {
  precision_x_ = 0;
}
inline double MapParking::precision_x() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapParking.precision_x)
  return precision_x_;
}
inline void MapParking::set_precision_x(double value) {
  
  precision_x_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapParking.precision_x)
}

// double precision_y = 7;
inline void MapParking::clear_precision_y() {
  precision_y_ = 0;
}
inline double MapParking::precision_y() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapParking.precision_y)
  return precision_y_;
}
inline void MapParking::set_precision_y(double value) {
  
  precision_y_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapParking.precision_y)
}

// -------------------------------------------------------------------

// LaneMarkingPoint

// double x = 1;
inline void LaneMarkingPoint::clear_x() {
  x_ = 0;
}
inline double LaneMarkingPoint::x() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LaneMarkingPoint.x)
  return x_;
}
inline void LaneMarkingPoint::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LaneMarkingPoint.x)
}

// double y = 2;
inline void LaneMarkingPoint::clear_y() {
  y_ = 0;
}
inline double LaneMarkingPoint::y() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LaneMarkingPoint.y)
  return y_;
}
inline void LaneMarkingPoint::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LaneMarkingPoint.y)
}

// int32 turn_type = 3;
inline void LaneMarkingPoint::clear_turn_type() {
  turn_type_ = 0;
}
inline ::google::protobuf::int32 LaneMarkingPoint::turn_type() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LaneMarkingPoint.turn_type)
  return turn_type_;
}
inline void LaneMarkingPoint::set_turn_type(::google::protobuf::int32 value) {
  
  turn_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LaneMarkingPoint.turn_type)
}

// .xsproto.hdmap.LaneType lane_type = 4;
inline void LaneMarkingPoint::clear_lane_type() {
  lane_type_ = 0;
}
inline ::xsproto::hdmap::LaneType LaneMarkingPoint::lane_type() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LaneMarkingPoint.lane_type)
  return static_cast< ::xsproto::hdmap::LaneType >(lane_type_);
}
inline void LaneMarkingPoint::set_lane_type(::xsproto::hdmap::LaneType value) {
  
  lane_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LaneMarkingPoint.lane_type)
}

// .xsproto.hdmap.LaneChangeRole lane_change_role = 5;
inline void LaneMarkingPoint::clear_lane_change_role() {
  lane_change_role_ = 0;
}
inline ::xsproto::hdmap::LaneChangeRole LaneMarkingPoint::lane_change_role() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LaneMarkingPoint.lane_change_role)
  return static_cast< ::xsproto::hdmap::LaneChangeRole >(lane_change_role_);
}
inline void LaneMarkingPoint::set_lane_change_role(::xsproto::hdmap::LaneChangeRole value) {
  
  lane_change_role_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LaneMarkingPoint.lane_change_role)
}

// .xsproto.hdmap.TrafficDirection traffic_direction = 6;
inline void LaneMarkingPoint::clear_traffic_direction() {
  traffic_direction_ = 0;
}
inline ::xsproto::hdmap::TrafficDirection LaneMarkingPoint::traffic_direction() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LaneMarkingPoint.traffic_direction)
  return static_cast< ::xsproto::hdmap::TrafficDirection >(traffic_direction_);
}
inline void LaneMarkingPoint::set_traffic_direction(::xsproto::hdmap::TrafficDirection value) {
  
  traffic_direction_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LaneMarkingPoint.traffic_direction)
}

// .xsproto.hdmap.RampWayType ramp_way_type = 7;
inline void LaneMarkingPoint::clear_ramp_way_type() {
  ramp_way_type_ = 0;
}
inline ::xsproto::hdmap::RampWayType LaneMarkingPoint::ramp_way_type() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LaneMarkingPoint.ramp_way_type)
  return static_cast< ::xsproto::hdmap::RampWayType >(ramp_way_type_);
}
inline void LaneMarkingPoint::set_ramp_way_type(::xsproto::hdmap::RampWayType value) {
  
  ramp_way_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LaneMarkingPoint.ramp_way_type)
}

// int32 stop_line_id = 8;
inline void LaneMarkingPoint::clear_stop_line_id() {
  stop_line_id_ = 0;
}
inline ::google::protobuf::int32 LaneMarkingPoint::stop_line_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LaneMarkingPoint.stop_line_id)
  return stop_line_id_;
}
inline void LaneMarkingPoint::set_stop_line_id(::google::protobuf::int32 value) {
  
  stop_line_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LaneMarkingPoint.stop_line_id)
}

// int32 pt_type = 9;
inline void LaneMarkingPoint::clear_pt_type() {
  pt_type_ = 0;
}
inline ::google::protobuf::int32 LaneMarkingPoint::pt_type() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LaneMarkingPoint.pt_type)
  return pt_type_;
}
inline void LaneMarkingPoint::set_pt_type(::google::protobuf::int32 value) {
  
  pt_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LaneMarkingPoint.pt_type)
}

// -------------------------------------------------------------------

// MapLaneMarking

// int32 road_id = 1;
inline void MapLaneMarking::clear_road_id() {
  road_id_ = 0;
}
inline ::google::protobuf::int32 MapLaneMarking::road_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapLaneMarking.road_id)
  return road_id_;
}
inline void MapLaneMarking::set_road_id(::google::protobuf::int32 value) {
  
  road_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapLaneMarking.road_id)
}

// int32 lane_id = 2;
inline void MapLaneMarking::clear_lane_id() {
  lane_id_ = 0;
}
inline ::google::protobuf::int32 MapLaneMarking::lane_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapLaneMarking.lane_id)
  return lane_id_;
}
inline void MapLaneMarking::set_lane_id(::google::protobuf::int32 value) {
  
  lane_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapLaneMarking.lane_id)
}

// int32 lane_refer = 3;
inline void MapLaneMarking::clear_lane_refer() {
  lane_refer_ = 0;
}
inline ::google::protobuf::int32 MapLaneMarking::lane_refer() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapLaneMarking.lane_refer)
  return lane_refer_;
}
inline void MapLaneMarking::set_lane_refer(::google::protobuf::int32 value) {
  
  lane_refer_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapLaneMarking.lane_refer)
}

// int32 lane_attr = 4;
inline void MapLaneMarking::clear_lane_attr() {
  lane_attr_ = 0;
}
inline ::google::protobuf::int32 MapLaneMarking::lane_attr() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapLaneMarking.lane_attr)
  return lane_attr_;
}
inline void MapLaneMarking::set_lane_attr(::google::protobuf::int32 value) {
  
  lane_attr_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapLaneMarking.lane_attr)
}

// repeated double ptx = 5;
inline int MapLaneMarking::ptx_size() const {
  return ptx_.size();
}
inline void MapLaneMarking::clear_ptx() {
  ptx_.Clear();
}
inline double MapLaneMarking::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapLaneMarking.ptx)
  return ptx_.Get(index);
}
inline void MapLaneMarking::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapLaneMarking.ptx)
}
inline void MapLaneMarking::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapLaneMarking.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapLaneMarking::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapLaneMarking.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapLaneMarking::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapLaneMarking.ptx)
  return &ptx_;
}

// repeated double pty = 6;
inline int MapLaneMarking::pty_size() const {
  return pty_.size();
}
inline void MapLaneMarking::clear_pty() {
  pty_.Clear();
}
inline double MapLaneMarking::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapLaneMarking.pty)
  return pty_.Get(index);
}
inline void MapLaneMarking::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapLaneMarking.pty)
}
inline void MapLaneMarking::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapLaneMarking.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapLaneMarking::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapLaneMarking.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapLaneMarking::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapLaneMarking.pty)
  return &pty_;
}

// int32 lane_chane_type = 9;
inline void MapLaneMarking::clear_lane_chane_type() {
  lane_chane_type_ = 0;
}
inline ::google::protobuf::int32 MapLaneMarking::lane_chane_type() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapLaneMarking.lane_chane_type)
  return lane_chane_type_;
}
inline void MapLaneMarking::set_lane_chane_type(::google::protobuf::int32 value) {
  
  lane_chane_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapLaneMarking.lane_chane_type)
}

// repeated .xsproto.hdmap.LaneMarkingPoint ext_points = 10;
inline int MapLaneMarking::ext_points_size() const {
  return ext_points_.size();
}
inline void MapLaneMarking::clear_ext_points() {
  ext_points_.Clear();
}
inline const ::xsproto::hdmap::LaneMarkingPoint& MapLaneMarking::ext_points(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapLaneMarking.ext_points)
  return ext_points_.Get(index);
}
inline ::xsproto::hdmap::LaneMarkingPoint* MapLaneMarking::mutable_ext_points(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.MapLaneMarking.ext_points)
  return ext_points_.Mutable(index);
}
inline ::xsproto::hdmap::LaneMarkingPoint* MapLaneMarking::add_ext_points() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapLaneMarking.ext_points)
  return ext_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::LaneMarkingPoint >*
MapLaneMarking::mutable_ext_points() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapLaneMarking.ext_points)
  return &ext_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::LaneMarkingPoint >&
MapLaneMarking::ext_points() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapLaneMarking.ext_points)
  return ext_points_;
}

// -------------------------------------------------------------------

// MapAreaInoutPoint

// int32 id = 1;
inline void MapAreaInoutPoint::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapAreaInoutPoint::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapAreaInoutPoint.id)
  return id_;
}
inline void MapAreaInoutPoint::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapAreaInoutPoint.id)
}

// double ptx = 2;
inline void MapAreaInoutPoint::clear_ptx() {
  ptx_ = 0;
}
inline double MapAreaInoutPoint::ptx() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapAreaInoutPoint.ptx)
  return ptx_;
}
inline void MapAreaInoutPoint::set_ptx(double value) {
  
  ptx_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapAreaInoutPoint.ptx)
}

// double pty = 3;
inline void MapAreaInoutPoint::clear_pty() {
  pty_ = 0;
}
inline double MapAreaInoutPoint::pty() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapAreaInoutPoint.pty)
  return pty_;
}
inline void MapAreaInoutPoint::set_pty(double value) {
  
  pty_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapAreaInoutPoint.pty)
}

// int32 type = 4;
inline void MapAreaInoutPoint::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 MapAreaInoutPoint::type() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapAreaInoutPoint.type)
  return type_;
}
inline void MapAreaInoutPoint::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapAreaInoutPoint.type)
}

// int32 angle = 5;
inline void MapAreaInoutPoint::clear_angle() {
  angle_ = 0;
}
inline ::google::protobuf::int32 MapAreaInoutPoint::angle() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapAreaInoutPoint.angle)
  return angle_;
}
inline void MapAreaInoutPoint::set_angle(::google::protobuf::int32 value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapAreaInoutPoint.angle)
}

// -------------------------------------------------------------------

// MapArea

// int32 id = 1;
inline void MapArea::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapArea::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapArea.id)
  return id_;
}
inline void MapArea::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapArea.id)
}

// repeated double ptx = 2;
inline int MapArea::ptx_size() const {
  return ptx_.size();
}
inline void MapArea::clear_ptx() {
  ptx_.Clear();
}
inline double MapArea::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapArea.ptx)
  return ptx_.Get(index);
}
inline void MapArea::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapArea.ptx)
}
inline void MapArea::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapArea.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapArea::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapArea.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapArea::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapArea.ptx)
  return &ptx_;
}

// repeated double pty = 3;
inline int MapArea::pty_size() const {
  return pty_.size();
}
inline void MapArea::clear_pty() {
  pty_.Clear();
}
inline double MapArea::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapArea.pty)
  return pty_.Get(index);
}
inline void MapArea::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapArea.pty)
}
inline void MapArea::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapArea.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapArea::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapArea.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapArea::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapArea.pty)
  return &pty_;
}

// int32 attr = 4;
inline void MapArea::clear_attr() {
  attr_ = 0;
}
inline ::google::protobuf::int32 MapArea::attr() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapArea.attr)
  return attr_;
}
inline void MapArea::set_attr(::google::protobuf::int32 value) {
  
  attr_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapArea.attr)
}

// repeated .xsproto.hdmap.MapObstacle obstacles = 5;
inline int MapArea::obstacles_size() const {
  return obstacles_.size();
}
inline void MapArea::clear_obstacles() {
  obstacles_.Clear();
}
inline const ::xsproto::hdmap::MapObstacle& MapArea::obstacles(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapArea.obstacles)
  return obstacles_.Get(index);
}
inline ::xsproto::hdmap::MapObstacle* MapArea::mutable_obstacles(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.MapArea.obstacles)
  return obstacles_.Mutable(index);
}
inline ::xsproto::hdmap::MapObstacle* MapArea::add_obstacles() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapArea.obstacles)
  return obstacles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapObstacle >*
MapArea::mutable_obstacles() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapArea.obstacles)
  return &obstacles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapObstacle >&
MapArea::obstacles() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapArea.obstacles)
  return obstacles_;
}

// repeated .xsproto.hdmap.MapAreaInoutPoint inout_points = 6;
inline int MapArea::inout_points_size() const {
  return inout_points_.size();
}
inline void MapArea::clear_inout_points() {
  inout_points_.Clear();
}
inline const ::xsproto::hdmap::MapAreaInoutPoint& MapArea::inout_points(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapArea.inout_points)
  return inout_points_.Get(index);
}
inline ::xsproto::hdmap::MapAreaInoutPoint* MapArea::mutable_inout_points(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.MapArea.inout_points)
  return inout_points_.Mutable(index);
}
inline ::xsproto::hdmap::MapAreaInoutPoint* MapArea::add_inout_points() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapArea.inout_points)
  return inout_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapAreaInoutPoint >*
MapArea::mutable_inout_points() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapArea.inout_points)
  return &inout_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapAreaInoutPoint >&
MapArea::inout_points() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapArea.inout_points)
  return inout_points_;
}

// -------------------------------------------------------------------

// MapConcavity

// int32 id = 1;
inline void MapConcavity::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapConcavity::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapConcavity.id)
  return id_;
}
inline void MapConcavity::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapConcavity.id)
}

// repeated double ptx = 2;
inline int MapConcavity::ptx_size() const {
  return ptx_.size();
}
inline void MapConcavity::clear_ptx() {
  ptx_.Clear();
}
inline double MapConcavity::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapConcavity.ptx)
  return ptx_.Get(index);
}
inline void MapConcavity::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapConcavity.ptx)
}
inline void MapConcavity::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapConcavity.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapConcavity::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapConcavity.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapConcavity::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapConcavity.ptx)
  return &ptx_;
}

// repeated double pty = 3;
inline int MapConcavity::pty_size() const {
  return pty_.size();
}
inline void MapConcavity::clear_pty() {
  pty_.Clear();
}
inline double MapConcavity::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapConcavity.pty)
  return pty_.Get(index);
}
inline void MapConcavity::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapConcavity.pty)
}
inline void MapConcavity::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapConcavity.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapConcavity::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapConcavity.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapConcavity::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapConcavity.pty)
  return &pty_;
}

// int32 attr = 4;
inline void MapConcavity::clear_attr() {
  attr_ = 0;
}
inline ::google::protobuf::int32 MapConcavity::attr() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapConcavity.attr)
  return attr_;
}
inline void MapConcavity::set_attr(::google::protobuf::int32 value) {
  
  attr_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapConcavity.attr)
}

// -------------------------------------------------------------------

// MapAlley

// int32 id = 1;
inline void MapAlley::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapAlley::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapAlley.id)
  return id_;
}
inline void MapAlley::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapAlley.id)
}

// repeated double ptx = 2;
inline int MapAlley::ptx_size() const {
  return ptx_.size();
}
inline void MapAlley::clear_ptx() {
  ptx_.Clear();
}
inline double MapAlley::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapAlley.ptx)
  return ptx_.Get(index);
}
inline void MapAlley::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapAlley.ptx)
}
inline void MapAlley::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapAlley.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapAlley::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapAlley.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapAlley::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapAlley.ptx)
  return &ptx_;
}

// repeated double pty = 3;
inline int MapAlley::pty_size() const {
  return pty_.size();
}
inline void MapAlley::clear_pty() {
  pty_.Clear();
}
inline double MapAlley::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapAlley.pty)
  return pty_.Get(index);
}
inline void MapAlley::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapAlley.pty)
}
inline void MapAlley::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapAlley.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapAlley::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapAlley.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapAlley::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapAlley.pty)
  return &pty_;
}

// int32 attr = 4;
inline void MapAlley::clear_attr() {
  attr_ = 0;
}
inline ::google::protobuf::int32 MapAlley::attr() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapAlley.attr)
  return attr_;
}
inline void MapAlley::set_attr(::google::protobuf::int32 value) {
  
  attr_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapAlley.attr)
}

// -------------------------------------------------------------------

// MapPassableArea

// int32 id = 1;
inline void MapPassableArea::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapPassableArea::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapPassableArea.id)
  return id_;
}
inline void MapPassableArea::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapPassableArea.id)
}

// repeated double ptx = 2;
inline int MapPassableArea::ptx_size() const {
  return ptx_.size();
}
inline void MapPassableArea::clear_ptx() {
  ptx_.Clear();
}
inline double MapPassableArea::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapPassableArea.ptx)
  return ptx_.Get(index);
}
inline void MapPassableArea::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapPassableArea.ptx)
}
inline void MapPassableArea::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapPassableArea.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapPassableArea::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapPassableArea.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapPassableArea::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapPassableArea.ptx)
  return &ptx_;
}

// repeated double pty = 3;
inline int MapPassableArea::pty_size() const {
  return pty_.size();
}
inline void MapPassableArea::clear_pty() {
  pty_.Clear();
}
inline double MapPassableArea::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapPassableArea.pty)
  return pty_.Get(index);
}
inline void MapPassableArea::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapPassableArea.pty)
}
inline void MapPassableArea::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapPassableArea.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapPassableArea::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapPassableArea.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapPassableArea::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapPassableArea.pty)
  return &pty_;
}

// int32 attr = 4;
inline void MapPassableArea::clear_attr() {
  attr_ = 0;
}
inline ::google::protobuf::int32 MapPassableArea::attr() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapPassableArea.attr)
  return attr_;
}
inline void MapPassableArea::set_attr(::google::protobuf::int32 value) {
  
  attr_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapPassableArea.attr)
}

// -------------------------------------------------------------------

// MapNoObstacleArea

// int32 id = 1;
inline void MapNoObstacleArea::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapNoObstacleArea::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapNoObstacleArea.id)
  return id_;
}
inline void MapNoObstacleArea::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapNoObstacleArea.id)
}

// repeated double ptx = 2;
inline int MapNoObstacleArea::ptx_size() const {
  return ptx_.size();
}
inline void MapNoObstacleArea::clear_ptx() {
  ptx_.Clear();
}
inline double MapNoObstacleArea::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapNoObstacleArea.ptx)
  return ptx_.Get(index);
}
inline void MapNoObstacleArea::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapNoObstacleArea.ptx)
}
inline void MapNoObstacleArea::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapNoObstacleArea.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapNoObstacleArea::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapNoObstacleArea.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapNoObstacleArea::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapNoObstacleArea.ptx)
  return &ptx_;
}

// repeated double pty = 3;
inline int MapNoObstacleArea::pty_size() const {
  return pty_.size();
}
inline void MapNoObstacleArea::clear_pty() {
  pty_.Clear();
}
inline double MapNoObstacleArea::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapNoObstacleArea.pty)
  return pty_.Get(index);
}
inline void MapNoObstacleArea::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapNoObstacleArea.pty)
}
inline void MapNoObstacleArea::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapNoObstacleArea.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapNoObstacleArea::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapNoObstacleArea.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapNoObstacleArea::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapNoObstacleArea.pty)
  return &pty_;
}

// int32 attr = 4;
inline void MapNoObstacleArea::clear_attr() {
  attr_ = 0;
}
inline ::google::protobuf::int32 MapNoObstacleArea::attr() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapNoObstacleArea.attr)
  return attr_;
}
inline void MapNoObstacleArea::set_attr(::google::protobuf::int32 value) {
  
  attr_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapNoObstacleArea.attr)
}

// -------------------------------------------------------------------

// MapOddArea

// int32 id = 1;
inline void MapOddArea::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapOddArea::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapOddArea.id)
  return id_;
}
inline void MapOddArea::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapOddArea.id)
}

// repeated double ptx = 2;
inline int MapOddArea::ptx_size() const {
  return ptx_.size();
}
inline void MapOddArea::clear_ptx() {
  ptx_.Clear();
}
inline double MapOddArea::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapOddArea.ptx)
  return ptx_.Get(index);
}
inline void MapOddArea::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapOddArea.ptx)
}
inline void MapOddArea::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapOddArea.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapOddArea::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapOddArea.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapOddArea::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapOddArea.ptx)
  return &ptx_;
}

// repeated double pty = 3;
inline int MapOddArea::pty_size() const {
  return pty_.size();
}
inline void MapOddArea::clear_pty() {
  pty_.Clear();
}
inline double MapOddArea::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapOddArea.pty)
  return pty_.Get(index);
}
inline void MapOddArea::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapOddArea.pty)
}
inline void MapOddArea::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapOddArea.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapOddArea::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapOddArea.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapOddArea::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapOddArea.pty)
  return &pty_;
}

// int32 attr = 4;
inline void MapOddArea::clear_attr() {
  attr_ = 0;
}
inline ::google::protobuf::int32 MapOddArea::attr() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapOddArea.attr)
  return attr_;
}
inline void MapOddArea::set_attr(::google::protobuf::int32 value) {
  
  attr_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapOddArea.attr)
}

// -------------------------------------------------------------------

// MapTransferArea

// int32 id = 1;
inline void MapTransferArea::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapTransferArea::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapTransferArea.id)
  return id_;
}
inline void MapTransferArea::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapTransferArea.id)
}

// repeated double ptx = 2;
inline int MapTransferArea::ptx_size() const {
  return ptx_.size();
}
inline void MapTransferArea::clear_ptx() {
  ptx_.Clear();
}
inline double MapTransferArea::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapTransferArea.ptx)
  return ptx_.Get(index);
}
inline void MapTransferArea::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapTransferArea.ptx)
}
inline void MapTransferArea::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapTransferArea.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapTransferArea::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapTransferArea.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapTransferArea::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapTransferArea.ptx)
  return &ptx_;
}

// repeated double pty = 3;
inline int MapTransferArea::pty_size() const {
  return pty_.size();
}
inline void MapTransferArea::clear_pty() {
  pty_.Clear();
}
inline double MapTransferArea::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapTransferArea.pty)
  return pty_.Get(index);
}
inline void MapTransferArea::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapTransferArea.pty)
}
inline void MapTransferArea::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapTransferArea.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapTransferArea::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapTransferArea.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapTransferArea::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapTransferArea.pty)
  return &pty_;
}

// int32 attr = 4;
inline void MapTransferArea::clear_attr() {
  attr_ = 0;
}
inline ::google::protobuf::int32 MapTransferArea::attr() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapTransferArea.attr)
  return attr_;
}
inline void MapTransferArea::set_attr(::google::protobuf::int32 value) {
  
  attr_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapTransferArea.attr)
}

// int32 floor = 5;
inline void MapTransferArea::clear_floor() {
  floor_ = 0;
}
inline ::google::protobuf::int32 MapTransferArea::floor() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapTransferArea.floor)
  return floor_;
}
inline void MapTransferArea::set_floor(::google::protobuf::int32 value) {
  
  floor_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapTransferArea.floor)
}

// -------------------------------------------------------------------

// MapPropertyArea

// int32 id = 1;
inline void MapPropertyArea::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapPropertyArea::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapPropertyArea.id)
  return id_;
}
inline void MapPropertyArea::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapPropertyArea.id)
}

// repeated double ptx = 2;
inline int MapPropertyArea::ptx_size() const {
  return ptx_.size();
}
inline void MapPropertyArea::clear_ptx() {
  ptx_.Clear();
}
inline double MapPropertyArea::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapPropertyArea.ptx)
  return ptx_.Get(index);
}
inline void MapPropertyArea::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapPropertyArea.ptx)
}
inline void MapPropertyArea::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapPropertyArea.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapPropertyArea::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapPropertyArea.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapPropertyArea::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapPropertyArea.ptx)
  return &ptx_;
}

// repeated double pty = 3;
inline int MapPropertyArea::pty_size() const {
  return pty_.size();
}
inline void MapPropertyArea::clear_pty() {
  pty_.Clear();
}
inline double MapPropertyArea::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapPropertyArea.pty)
  return pty_.Get(index);
}
inline void MapPropertyArea::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapPropertyArea.pty)
}
inline void MapPropertyArea::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapPropertyArea.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapPropertyArea::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapPropertyArea.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapPropertyArea::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapPropertyArea.pty)
  return &pty_;
}

// int32 property = 4;
inline void MapPropertyArea::clear_property() {
  property_ = 0;
}
inline ::google::protobuf::int32 MapPropertyArea::property() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapPropertyArea.property)
  return property_;
}
inline void MapPropertyArea::set_property(::google::protobuf::int32 value) {
  
  property_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapPropertyArea.property)
}

// double distance = 5;
inline void MapPropertyArea::clear_distance() {
  distance_ = 0;
}
inline double MapPropertyArea::distance() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapPropertyArea.distance)
  return distance_;
}
inline void MapPropertyArea::set_distance(double value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapPropertyArea.distance)
}

// -------------------------------------------------------------------

// MapQueuingArea

// int32 id = 1;
inline void MapQueuingArea::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapQueuingArea::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapQueuingArea.id)
  return id_;
}
inline void MapQueuingArea::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapQueuingArea.id)
}

// repeated double ptx = 2;
inline int MapQueuingArea::ptx_size() const {
  return ptx_.size();
}
inline void MapQueuingArea::clear_ptx() {
  ptx_.Clear();
}
inline double MapQueuingArea::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapQueuingArea.ptx)
  return ptx_.Get(index);
}
inline void MapQueuingArea::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapQueuingArea.ptx)
}
inline void MapQueuingArea::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapQueuingArea.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapQueuingArea::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapQueuingArea.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapQueuingArea::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapQueuingArea.ptx)
  return &ptx_;
}

// repeated double pty = 3;
inline int MapQueuingArea::pty_size() const {
  return pty_.size();
}
inline void MapQueuingArea::clear_pty() {
  pty_.Clear();
}
inline double MapQueuingArea::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapQueuingArea.pty)
  return pty_.Get(index);
}
inline void MapQueuingArea::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapQueuingArea.pty)
}
inline void MapQueuingArea::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapQueuingArea.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapQueuingArea::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapQueuingArea.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapQueuingArea::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapQueuingArea.pty)
  return &pty_;
}

// int32 arrive_type = 4;
inline void MapQueuingArea::clear_arrive_type() {
  arrive_type_ = 0;
}
inline ::google::protobuf::int32 MapQueuingArea::arrive_type() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapQueuingArea.arrive_type)
  return arrive_type_;
}
inline void MapQueuingArea::set_arrive_type(::google::protobuf::int32 value) {
  
  arrive_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapQueuingArea.arrive_type)
}

// int32 queuing_span = 5;
inline void MapQueuingArea::clear_queuing_span() {
  queuing_span_ = 0;
}
inline ::google::protobuf::int32 MapQueuingArea::queuing_span() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapQueuingArea.queuing_span)
  return queuing_span_;
}
inline void MapQueuingArea::set_queuing_span(::google::protobuf::int32 value) {
  
  queuing_span_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapQueuingArea.queuing_span)
}

// int32 arv_mht_dis = 6;
inline void MapQueuingArea::clear_arv_mht_dis() {
  arv_mht_dis_ = 0;
}
inline ::google::protobuf::int32 MapQueuingArea::arv_mht_dis() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapQueuingArea.arv_mht_dis)
  return arv_mht_dis_;
}
inline void MapQueuingArea::set_arv_mht_dis(::google::protobuf::int32 value) {
  
  arv_mht_dis_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapQueuingArea.arv_mht_dis)
}

// int32 park_method = 7;
inline void MapQueuingArea::clear_park_method() {
  park_method_ = 0;
}
inline ::google::protobuf::int32 MapQueuingArea::park_method() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapQueuingArea.park_method)
  return park_method_;
}
inline void MapQueuingArea::set_park_method(::google::protobuf::int32 value) {
  
  park_method_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapQueuingArea.park_method)
}

// -------------------------------------------------------------------

// MapStopLine

// int32 id = 1;
inline void MapStopLine::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapStopLine::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapStopLine.id)
  return id_;
}
inline void MapStopLine::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapStopLine.id)
}

// repeated double ptx = 2;
inline int MapStopLine::ptx_size() const {
  return ptx_.size();
}
inline void MapStopLine::clear_ptx() {
  ptx_.Clear();
}
inline double MapStopLine::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapStopLine.ptx)
  return ptx_.Get(index);
}
inline void MapStopLine::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapStopLine.ptx)
}
inline void MapStopLine::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapStopLine.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapStopLine::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapStopLine.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapStopLine::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapStopLine.ptx)
  return &ptx_;
}

// repeated double pty = 3;
inline int MapStopLine::pty_size() const {
  return pty_.size();
}
inline void MapStopLine::clear_pty() {
  pty_.Clear();
}
inline double MapStopLine::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapStopLine.pty)
  return pty_.Get(index);
}
inline void MapStopLine::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapStopLine.pty)
}
inline void MapStopLine::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapStopLine.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapStopLine::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapStopLine.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapStopLine::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapStopLine.pty)
  return &pty_;
}

// int32 line_type = 4;
inline void MapStopLine::clear_line_type() {
  line_type_ = 0;
}
inline ::google::protobuf::int32 MapStopLine::line_type() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapStopLine.line_type)
  return line_type_;
}
inline void MapStopLine::set_line_type(::google::protobuf::int32 value) {
  
  line_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapStopLine.line_type)
}

// double stop_time = 5;
inline void MapStopLine::clear_stop_time() {
  stop_time_ = 0;
}
inline double MapStopLine::stop_time() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapStopLine.stop_time)
  return stop_time_;
}
inline void MapStopLine::set_stop_time(double value) {
  
  stop_time_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapStopLine.stop_time)
}

// int32 traffic_light_id = 6;
inline void MapStopLine::clear_traffic_light_id() {
  traffic_light_id_ = 0;
}
inline ::google::protobuf::int32 MapStopLine::traffic_light_id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapStopLine.traffic_light_id)
  return traffic_light_id_;
}
inline void MapStopLine::set_traffic_light_id(::google::protobuf::int32 value) {
  
  traffic_light_id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapStopLine.traffic_light_id)
}

// -------------------------------------------------------------------

// MapSpeedLimitArea

// int32 id = 1;
inline void MapSpeedLimitArea::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapSpeedLimitArea::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapSpeedLimitArea.id)
  return id_;
}
inline void MapSpeedLimitArea::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapSpeedLimitArea.id)
}

// repeated double ptx = 2;
inline int MapSpeedLimitArea::ptx_size() const {
  return ptx_.size();
}
inline void MapSpeedLimitArea::clear_ptx() {
  ptx_.Clear();
}
inline double MapSpeedLimitArea::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapSpeedLimitArea.ptx)
  return ptx_.Get(index);
}
inline void MapSpeedLimitArea::set_ptx(int index, double value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapSpeedLimitArea.ptx)
}
inline void MapSpeedLimitArea::add_ptx(double value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapSpeedLimitArea.ptx)
}
inline const ::google::protobuf::RepeatedField< double >&
MapSpeedLimitArea::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapSpeedLimitArea.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< double >*
MapSpeedLimitArea::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapSpeedLimitArea.ptx)
  return &ptx_;
}

// repeated double pty = 3;
inline int MapSpeedLimitArea::pty_size() const {
  return pty_.size();
}
inline void MapSpeedLimitArea::clear_pty() {
  pty_.Clear();
}
inline double MapSpeedLimitArea::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapSpeedLimitArea.pty)
  return pty_.Get(index);
}
inline void MapSpeedLimitArea::set_pty(int index, double value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapSpeedLimitArea.pty)
}
inline void MapSpeedLimitArea::add_pty(double value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapSpeedLimitArea.pty)
}
inline const ::google::protobuf::RepeatedField< double >&
MapSpeedLimitArea::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapSpeedLimitArea.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< double >*
MapSpeedLimitArea::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapSpeedLimitArea.pty)
  return &pty_;
}

// double limit_speed = 4;
inline void MapSpeedLimitArea::clear_limit_speed() {
  limit_speed_ = 0;
}
inline double MapSpeedLimitArea::limit_speed() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapSpeedLimitArea.limit_speed)
  return limit_speed_;
}
inline void MapSpeedLimitArea::set_limit_speed(double value) {
  
  limit_speed_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapSpeedLimitArea.limit_speed)
}

// -------------------------------------------------------------------

// MapSpeedhump

// int32 id = 1;
inline void MapSpeedhump::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapSpeedhump::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapSpeedhump.id)
  return id_;
}
inline void MapSpeedhump::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapSpeedhump.id)
}

// repeated int32 ptx = 2;
inline int MapSpeedhump::ptx_size() const {
  return ptx_.size();
}
inline void MapSpeedhump::clear_ptx() {
  ptx_.Clear();
}
inline ::google::protobuf::int32 MapSpeedhump::ptx(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapSpeedhump.ptx)
  return ptx_.Get(index);
}
inline void MapSpeedhump::set_ptx(int index, ::google::protobuf::int32 value) {
  ptx_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapSpeedhump.ptx)
}
inline void MapSpeedhump::add_ptx(::google::protobuf::int32 value) {
  ptx_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapSpeedhump.ptx)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MapSpeedhump::ptx() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapSpeedhump.ptx)
  return ptx_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MapSpeedhump::mutable_ptx() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapSpeedhump.ptx)
  return &ptx_;
}

// repeated int32 pty = 3;
inline int MapSpeedhump::pty_size() const {
  return pty_.size();
}
inline void MapSpeedhump::clear_pty() {
  pty_.Clear();
}
inline ::google::protobuf::int32 MapSpeedhump::pty(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapSpeedhump.pty)
  return pty_.Get(index);
}
inline void MapSpeedhump::set_pty(int index, ::google::protobuf::int32 value) {
  pty_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapSpeedhump.pty)
}
inline void MapSpeedhump::add_pty(::google::protobuf::int32 value) {
  pty_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.hdmap.MapSpeedhump.pty)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MapSpeedhump::pty() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.MapSpeedhump.pty)
  return pty_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MapSpeedhump::mutable_pty() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.MapSpeedhump.pty)
  return &pty_;
}

// double limit_speed = 4;
inline void MapSpeedhump::clear_limit_speed() {
  limit_speed_ = 0;
}
inline double MapSpeedhump::limit_speed() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapSpeedhump.limit_speed)
  return limit_speed_;
}
inline void MapSpeedhump::set_limit_speed(double value) {
  
  limit_speed_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapSpeedhump.limit_speed)
}

// double height = 5;
inline void MapSpeedhump::clear_height() {
  height_ = 0;
}
inline double MapSpeedhump::height() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapSpeedhump.height)
  return height_;
}
inline void MapSpeedhump::set_height(double value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapSpeedhump.height)
}

// -------------------------------------------------------------------

// MapTrafficLight

// int32 id = 1;
inline void MapTrafficLight::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 MapTrafficLight::id() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapTrafficLight.id)
  return id_;
}
inline void MapTrafficLight::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapTrafficLight.id)
}

// double ptx = 2;
inline void MapTrafficLight::clear_ptx() {
  ptx_ = 0;
}
inline double MapTrafficLight::ptx() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapTrafficLight.ptx)
  return ptx_;
}
inline void MapTrafficLight::set_ptx(double value) {
  
  ptx_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapTrafficLight.ptx)
}

// double pty = 3;
inline void MapTrafficLight::clear_pty() {
  pty_ = 0;
}
inline double MapTrafficLight::pty() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapTrafficLight.pty)
  return pty_;
}
inline void MapTrafficLight::set_pty(double value) {
  
  pty_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapTrafficLight.pty)
}

// double ptz = 4;
inline void MapTrafficLight::clear_ptz() {
  ptz_ = 0;
}
inline double MapTrafficLight::ptz() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapTrafficLight.ptz)
  return ptz_;
}
inline void MapTrafficLight::set_ptz(double value) {
  
  ptz_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapTrafficLight.ptz)
}

// .xsproto.hdmap.TrafficLighShapeType shape_type = 5;
inline void MapTrafficLight::clear_shape_type() {
  shape_type_ = 0;
}
inline ::xsproto::hdmap::TrafficLighShapeType MapTrafficLight::shape_type() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapTrafficLight.shape_type)
  return static_cast< ::xsproto::hdmap::TrafficLighShapeType >(shape_type_);
}
inline void MapTrafficLight::set_shape_type(::xsproto::hdmap::TrafficLighShapeType value) {
  
  shape_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapTrafficLight.shape_type)
}

// .xsproto.hdmap.TrafficLightRangeWay range_way = 6;
inline void MapTrafficLight::clear_range_way() {
  range_way_ = 0;
}
inline ::xsproto::hdmap::TrafficLightRangeWay MapTrafficLight::range_way() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.MapTrafficLight.range_way)
  return static_cast< ::xsproto::hdmap::TrafficLightRangeWay >(range_way_);
}
inline void MapTrafficLight::set_range_way(::xsproto::hdmap::TrafficLightRangeWay value) {
  
  range_way_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.MapTrafficLight.range_way)
}

// -------------------------------------------------------------------

// LocalHDMap

// double x = 2;
inline void LocalHDMap::clear_x() {
  x_ = 0;
}
inline double LocalHDMap::x() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.x)
  return x_;
}
inline void LocalHDMap::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LocalHDMap.x)
}

// double y = 3;
inline void LocalHDMap::clear_y() {
  y_ = 0;
}
inline double LocalHDMap::y() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.y)
  return y_;
}
inline void LocalHDMap::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LocalHDMap.y)
}

// double z = 4;
inline void LocalHDMap::clear_z() {
  z_ = 0;
}
inline double LocalHDMap::z() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.z)
  return z_;
}
inline void LocalHDMap::set_z(double value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LocalHDMap.z)
}

// double azimuth = 5;
inline void LocalHDMap::clear_azimuth() {
  azimuth_ = 0;
}
inline double LocalHDMap::azimuth() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.azimuth)
  return azimuth_;
}
inline void LocalHDMap::set_azimuth(double value) {
  
  azimuth_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LocalHDMap.azimuth)
}

// double pitch = 6;
inline void LocalHDMap::clear_pitch() {
  pitch_ = 0;
}
inline double LocalHDMap::pitch() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.pitch)
  return pitch_;
}
inline void LocalHDMap::set_pitch(double value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LocalHDMap.pitch)
}

// double roll = 7;
inline void LocalHDMap::clear_roll() {
  roll_ = 0;
}
inline double LocalHDMap::roll() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.roll)
  return roll_;
}
inline void LocalHDMap::set_roll(double value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LocalHDMap.roll)
}

// repeated .xsproto.hdmap.RoadMarking markings = 8;
inline int LocalHDMap::markings_size() const {
  return markings_.size();
}
inline void LocalHDMap::clear_markings() {
  markings_.Clear();
}
inline const ::xsproto::hdmap::RoadMarking& LocalHDMap::markings(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.markings)
  return markings_.Get(index);
}
inline ::xsproto::hdmap::RoadMarking* LocalHDMap::mutable_markings(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.markings)
  return markings_.Mutable(index);
}
inline ::xsproto::hdmap::RoadMarking* LocalHDMap::add_markings() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.markings)
  return markings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::RoadMarking >*
LocalHDMap::mutable_markings() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.markings)
  return &markings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::RoadMarking >&
LocalHDMap::markings() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.markings)
  return markings_;
}

// repeated .xsproto.hdmap.MapObstacle obstacles = 9;
inline int LocalHDMap::obstacles_size() const {
  return obstacles_.size();
}
inline void LocalHDMap::clear_obstacles() {
  obstacles_.Clear();
}
inline const ::xsproto::hdmap::MapObstacle& LocalHDMap::obstacles(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.obstacles)
  return obstacles_.Get(index);
}
inline ::xsproto::hdmap::MapObstacle* LocalHDMap::mutable_obstacles(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.obstacles)
  return obstacles_.Mutable(index);
}
inline ::xsproto::hdmap::MapObstacle* LocalHDMap::add_obstacles() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.obstacles)
  return obstacles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapObstacle >*
LocalHDMap::mutable_obstacles() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.obstacles)
  return &obstacles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapObstacle >&
LocalHDMap::obstacles() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.obstacles)
  return obstacles_;
}

// repeated .xsproto.hdmap.MapParking parkings = 10;
inline int LocalHDMap::parkings_size() const {
  return parkings_.size();
}
inline void LocalHDMap::clear_parkings() {
  parkings_.Clear();
}
inline const ::xsproto::hdmap::MapParking& LocalHDMap::parkings(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.parkings)
  return parkings_.Get(index);
}
inline ::xsproto::hdmap::MapParking* LocalHDMap::mutable_parkings(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.parkings)
  return parkings_.Mutable(index);
}
inline ::xsproto::hdmap::MapParking* LocalHDMap::add_parkings() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.parkings)
  return parkings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapParking >*
LocalHDMap::mutable_parkings() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.parkings)
  return &parkings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapParking >&
LocalHDMap::parkings() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.parkings)
  return parkings_;
}

// repeated .xsproto.hdmap.MapLaneMarking future_lanemarkings = 11;
inline int LocalHDMap::future_lanemarkings_size() const {
  return future_lanemarkings_.size();
}
inline void LocalHDMap::clear_future_lanemarkings() {
  future_lanemarkings_.Clear();
}
inline const ::xsproto::hdmap::MapLaneMarking& LocalHDMap::future_lanemarkings(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.future_lanemarkings)
  return future_lanemarkings_.Get(index);
}
inline ::xsproto::hdmap::MapLaneMarking* LocalHDMap::mutable_future_lanemarkings(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.future_lanemarkings)
  return future_lanemarkings_.Mutable(index);
}
inline ::xsproto::hdmap::MapLaneMarking* LocalHDMap::add_future_lanemarkings() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.future_lanemarkings)
  return future_lanemarkings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapLaneMarking >*
LocalHDMap::mutable_future_lanemarkings() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.future_lanemarkings)
  return &future_lanemarkings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapLaneMarking >&
LocalHDMap::future_lanemarkings() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.future_lanemarkings)
  return future_lanemarkings_;
}

// repeated .xsproto.hdmap.MapLaneMarking past_lanemarkings = 12;
inline int LocalHDMap::past_lanemarkings_size() const {
  return past_lanemarkings_.size();
}
inline void LocalHDMap::clear_past_lanemarkings() {
  past_lanemarkings_.Clear();
}
inline const ::xsproto::hdmap::MapLaneMarking& LocalHDMap::past_lanemarkings(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.past_lanemarkings)
  return past_lanemarkings_.Get(index);
}
inline ::xsproto::hdmap::MapLaneMarking* LocalHDMap::mutable_past_lanemarkings(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.past_lanemarkings)
  return past_lanemarkings_.Mutable(index);
}
inline ::xsproto::hdmap::MapLaneMarking* LocalHDMap::add_past_lanemarkings() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.past_lanemarkings)
  return past_lanemarkings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapLaneMarking >*
LocalHDMap::mutable_past_lanemarkings() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.past_lanemarkings)
  return &past_lanemarkings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapLaneMarking >&
LocalHDMap::past_lanemarkings() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.past_lanemarkings)
  return past_lanemarkings_;
}

// .xsproto.base.Header header = 13;
inline bool LocalHDMap::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::xsproto::base::Header& LocalHDMap::header() const {
  const ::xsproto::base::Header* p = header_;
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.header)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::base::Header*>(
      &::xsproto::base::_Header_default_instance_);
}
inline ::xsproto::base::Header* LocalHDMap::release_header() {
  // @@protoc_insertion_point(field_release:xsproto.hdmap.LocalHDMap.header)
  
  ::xsproto::base::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::xsproto::base::Header* LocalHDMap::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::xsproto::base::Header;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.header)
  return header_;
}
inline void LocalHDMap::set_allocated_header(::xsproto::base::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xsproto.hdmap.LocalHDMap.header)
}

// repeated .xsproto.hdmap.MapArea areas = 14;
inline int LocalHDMap::areas_size() const {
  return areas_.size();
}
inline void LocalHDMap::clear_areas() {
  areas_.Clear();
}
inline const ::xsproto::hdmap::MapArea& LocalHDMap::areas(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.areas)
  return areas_.Get(index);
}
inline ::xsproto::hdmap::MapArea* LocalHDMap::mutable_areas(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.areas)
  return areas_.Mutable(index);
}
inline ::xsproto::hdmap::MapArea* LocalHDMap::add_areas() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.areas)
  return areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapArea >*
LocalHDMap::mutable_areas() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.areas)
  return &areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapArea >&
LocalHDMap::areas() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.areas)
  return areas_;
}

// repeated .xsproto.hdmap.MapConcavity concavities = 15;
inline int LocalHDMap::concavities_size() const {
  return concavities_.size();
}
inline void LocalHDMap::clear_concavities() {
  concavities_.Clear();
}
inline const ::xsproto::hdmap::MapConcavity& LocalHDMap::concavities(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.concavities)
  return concavities_.Get(index);
}
inline ::xsproto::hdmap::MapConcavity* LocalHDMap::mutable_concavities(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.concavities)
  return concavities_.Mutable(index);
}
inline ::xsproto::hdmap::MapConcavity* LocalHDMap::add_concavities() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.concavities)
  return concavities_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapConcavity >*
LocalHDMap::mutable_concavities() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.concavities)
  return &concavities_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapConcavity >&
LocalHDMap::concavities() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.concavities)
  return concavities_;
}

// repeated .xsproto.hdmap.MapAlley alleys = 16;
inline int LocalHDMap::alleys_size() const {
  return alleys_.size();
}
inline void LocalHDMap::clear_alleys() {
  alleys_.Clear();
}
inline const ::xsproto::hdmap::MapAlley& LocalHDMap::alleys(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.alleys)
  return alleys_.Get(index);
}
inline ::xsproto::hdmap::MapAlley* LocalHDMap::mutable_alleys(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.alleys)
  return alleys_.Mutable(index);
}
inline ::xsproto::hdmap::MapAlley* LocalHDMap::add_alleys() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.alleys)
  return alleys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapAlley >*
LocalHDMap::mutable_alleys() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.alleys)
  return &alleys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapAlley >&
LocalHDMap::alleys() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.alleys)
  return alleys_;
}

// repeated .xsproto.hdmap.MapPassableArea passable_areas = 17;
inline int LocalHDMap::passable_areas_size() const {
  return passable_areas_.size();
}
inline void LocalHDMap::clear_passable_areas() {
  passable_areas_.Clear();
}
inline const ::xsproto::hdmap::MapPassableArea& LocalHDMap::passable_areas(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.passable_areas)
  return passable_areas_.Get(index);
}
inline ::xsproto::hdmap::MapPassableArea* LocalHDMap::mutable_passable_areas(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.passable_areas)
  return passable_areas_.Mutable(index);
}
inline ::xsproto::hdmap::MapPassableArea* LocalHDMap::add_passable_areas() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.passable_areas)
  return passable_areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapPassableArea >*
LocalHDMap::mutable_passable_areas() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.passable_areas)
  return &passable_areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapPassableArea >&
LocalHDMap::passable_areas() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.passable_areas)
  return passable_areas_;
}

// repeated .xsproto.hdmap.MapNoObstacleArea no_obstacle_areas = 18;
inline int LocalHDMap::no_obstacle_areas_size() const {
  return no_obstacle_areas_.size();
}
inline void LocalHDMap::clear_no_obstacle_areas() {
  no_obstacle_areas_.Clear();
}
inline const ::xsproto::hdmap::MapNoObstacleArea& LocalHDMap::no_obstacle_areas(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.no_obstacle_areas)
  return no_obstacle_areas_.Get(index);
}
inline ::xsproto::hdmap::MapNoObstacleArea* LocalHDMap::mutable_no_obstacle_areas(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.no_obstacle_areas)
  return no_obstacle_areas_.Mutable(index);
}
inline ::xsproto::hdmap::MapNoObstacleArea* LocalHDMap::add_no_obstacle_areas() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.no_obstacle_areas)
  return no_obstacle_areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapNoObstacleArea >*
LocalHDMap::mutable_no_obstacle_areas() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.no_obstacle_areas)
  return &no_obstacle_areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapNoObstacleArea >&
LocalHDMap::no_obstacle_areas() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.no_obstacle_areas)
  return no_obstacle_areas_;
}

// repeated .xsproto.hdmap.MapOddArea odd_areas = 19;
inline int LocalHDMap::odd_areas_size() const {
  return odd_areas_.size();
}
inline void LocalHDMap::clear_odd_areas() {
  odd_areas_.Clear();
}
inline const ::xsproto::hdmap::MapOddArea& LocalHDMap::odd_areas(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.odd_areas)
  return odd_areas_.Get(index);
}
inline ::xsproto::hdmap::MapOddArea* LocalHDMap::mutable_odd_areas(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.odd_areas)
  return odd_areas_.Mutable(index);
}
inline ::xsproto::hdmap::MapOddArea* LocalHDMap::add_odd_areas() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.odd_areas)
  return odd_areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapOddArea >*
LocalHDMap::mutable_odd_areas() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.odd_areas)
  return &odd_areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapOddArea >&
LocalHDMap::odd_areas() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.odd_areas)
  return odd_areas_;
}

// repeated .xsproto.hdmap.MapTransferArea transfer_areas = 20;
inline int LocalHDMap::transfer_areas_size() const {
  return transfer_areas_.size();
}
inline void LocalHDMap::clear_transfer_areas() {
  transfer_areas_.Clear();
}
inline const ::xsproto::hdmap::MapTransferArea& LocalHDMap::transfer_areas(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.transfer_areas)
  return transfer_areas_.Get(index);
}
inline ::xsproto::hdmap::MapTransferArea* LocalHDMap::mutable_transfer_areas(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.transfer_areas)
  return transfer_areas_.Mutable(index);
}
inline ::xsproto::hdmap::MapTransferArea* LocalHDMap::add_transfer_areas() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.transfer_areas)
  return transfer_areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapTransferArea >*
LocalHDMap::mutable_transfer_areas() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.transfer_areas)
  return &transfer_areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapTransferArea >&
LocalHDMap::transfer_areas() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.transfer_areas)
  return transfer_areas_;
}

// repeated .xsproto.hdmap.MapPropertyArea property_areas = 21;
inline int LocalHDMap::property_areas_size() const {
  return property_areas_.size();
}
inline void LocalHDMap::clear_property_areas() {
  property_areas_.Clear();
}
inline const ::xsproto::hdmap::MapPropertyArea& LocalHDMap::property_areas(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.property_areas)
  return property_areas_.Get(index);
}
inline ::xsproto::hdmap::MapPropertyArea* LocalHDMap::mutable_property_areas(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.property_areas)
  return property_areas_.Mutable(index);
}
inline ::xsproto::hdmap::MapPropertyArea* LocalHDMap::add_property_areas() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.property_areas)
  return property_areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapPropertyArea >*
LocalHDMap::mutable_property_areas() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.property_areas)
  return &property_areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapPropertyArea >&
LocalHDMap::property_areas() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.property_areas)
  return property_areas_;
}

// repeated .xsproto.hdmap.MapQueuingArea queuing_areas = 22;
inline int LocalHDMap::queuing_areas_size() const {
  return queuing_areas_.size();
}
inline void LocalHDMap::clear_queuing_areas() {
  queuing_areas_.Clear();
}
inline const ::xsproto::hdmap::MapQueuingArea& LocalHDMap::queuing_areas(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.queuing_areas)
  return queuing_areas_.Get(index);
}
inline ::xsproto::hdmap::MapQueuingArea* LocalHDMap::mutable_queuing_areas(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.queuing_areas)
  return queuing_areas_.Mutable(index);
}
inline ::xsproto::hdmap::MapQueuingArea* LocalHDMap::add_queuing_areas() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.queuing_areas)
  return queuing_areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapQueuingArea >*
LocalHDMap::mutable_queuing_areas() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.queuing_areas)
  return &queuing_areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapQueuingArea >&
LocalHDMap::queuing_areas() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.queuing_areas)
  return queuing_areas_;
}

// repeated .xsproto.hdmap.MapStopLine stop_lines = 23;
inline int LocalHDMap::stop_lines_size() const {
  return stop_lines_.size();
}
inline void LocalHDMap::clear_stop_lines() {
  stop_lines_.Clear();
}
inline const ::xsproto::hdmap::MapStopLine& LocalHDMap::stop_lines(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.stop_lines)
  return stop_lines_.Get(index);
}
inline ::xsproto::hdmap::MapStopLine* LocalHDMap::mutable_stop_lines(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.stop_lines)
  return stop_lines_.Mutable(index);
}
inline ::xsproto::hdmap::MapStopLine* LocalHDMap::add_stop_lines() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.stop_lines)
  return stop_lines_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapStopLine >*
LocalHDMap::mutable_stop_lines() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.stop_lines)
  return &stop_lines_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapStopLine >&
LocalHDMap::stop_lines() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.stop_lines)
  return stop_lines_;
}

// repeated .xsproto.hdmap.MapSpeedLimitArea speed_limit_areas = 24;
inline int LocalHDMap::speed_limit_areas_size() const {
  return speed_limit_areas_.size();
}
inline void LocalHDMap::clear_speed_limit_areas() {
  speed_limit_areas_.Clear();
}
inline const ::xsproto::hdmap::MapSpeedLimitArea& LocalHDMap::speed_limit_areas(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.speed_limit_areas)
  return speed_limit_areas_.Get(index);
}
inline ::xsproto::hdmap::MapSpeedLimitArea* LocalHDMap::mutable_speed_limit_areas(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.speed_limit_areas)
  return speed_limit_areas_.Mutable(index);
}
inline ::xsproto::hdmap::MapSpeedLimitArea* LocalHDMap::add_speed_limit_areas() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.speed_limit_areas)
  return speed_limit_areas_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapSpeedLimitArea >*
LocalHDMap::mutable_speed_limit_areas() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.speed_limit_areas)
  return &speed_limit_areas_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapSpeedLimitArea >&
LocalHDMap::speed_limit_areas() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.speed_limit_areas)
  return speed_limit_areas_;
}

// repeated .xsproto.hdmap.MapTrafficLight traffic_lights = 25;
inline int LocalHDMap::traffic_lights_size() const {
  return traffic_lights_.size();
}
inline void LocalHDMap::clear_traffic_lights() {
  traffic_lights_.Clear();
}
inline const ::xsproto::hdmap::MapTrafficLight& LocalHDMap::traffic_lights(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.traffic_lights)
  return traffic_lights_.Get(index);
}
inline ::xsproto::hdmap::MapTrafficLight* LocalHDMap::mutable_traffic_lights(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.traffic_lights)
  return traffic_lights_.Mutable(index);
}
inline ::xsproto::hdmap::MapTrafficLight* LocalHDMap::add_traffic_lights() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.traffic_lights)
  return traffic_lights_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapTrafficLight >*
LocalHDMap::mutable_traffic_lights() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.traffic_lights)
  return &traffic_lights_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapTrafficLight >&
LocalHDMap::traffic_lights() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.traffic_lights)
  return traffic_lights_;
}

// repeated .xsproto.hdmap.MapSpeedhump speedhumps = 26;
inline int LocalHDMap::speedhumps_size() const {
  return speedhumps_.size();
}
inline void LocalHDMap::clear_speedhumps() {
  speedhumps_.Clear();
}
inline const ::xsproto::hdmap::MapSpeedhump& LocalHDMap::speedhumps(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.speedhumps)
  return speedhumps_.Get(index);
}
inline ::xsproto::hdmap::MapSpeedhump* LocalHDMap::mutable_speedhumps(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.hdmap.LocalHDMap.speedhumps)
  return speedhumps_.Mutable(index);
}
inline ::xsproto::hdmap::MapSpeedhump* LocalHDMap::add_speedhumps() {
  // @@protoc_insertion_point(field_add:xsproto.hdmap.LocalHDMap.speedhumps)
  return speedhumps_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapSpeedhump >*
LocalHDMap::mutable_speedhumps() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.hdmap.LocalHDMap.speedhumps)
  return &speedhumps_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::hdmap::MapSpeedhump >&
LocalHDMap::speedhumps() const {
  // @@protoc_insertion_point(field_list:xsproto.hdmap.LocalHDMap.speedhumps)
  return speedhumps_;
}

// .xsproto.hdmap.RampWayType ramp_way = 27;
inline void LocalHDMap::clear_ramp_way() {
  ramp_way_ = 0;
}
inline ::xsproto::hdmap::RampWayType LocalHDMap::ramp_way() const {
  // @@protoc_insertion_point(field_get:xsproto.hdmap.LocalHDMap.ramp_way)
  return static_cast< ::xsproto::hdmap::RampWayType >(ramp_way_);
}
inline void LocalHDMap::set_ramp_way(::xsproto::hdmap::RampWayType value) {
  
  ramp_way_ = value;
  // @@protoc_insertion_point(field_set:xsproto.hdmap.LocalHDMap.ramp_way)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hdmap
}  // namespace xsproto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::xsproto::hdmap::LaneTurnType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::hdmap::LaneTurnType>() {
  return ::xsproto::hdmap::LaneTurnType_descriptor();
}
template <> struct is_proto_enum< ::xsproto::hdmap::LaneType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::hdmap::LaneType>() {
  return ::xsproto::hdmap::LaneType_descriptor();
}
template <> struct is_proto_enum< ::xsproto::hdmap::LaneChangeRole> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::hdmap::LaneChangeRole>() {
  return ::xsproto::hdmap::LaneChangeRole_descriptor();
}
template <> struct is_proto_enum< ::xsproto::hdmap::TrafficDirection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::hdmap::TrafficDirection>() {
  return ::xsproto::hdmap::TrafficDirection_descriptor();
}
template <> struct is_proto_enum< ::xsproto::hdmap::RampWayType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::hdmap::RampWayType>() {
  return ::xsproto::hdmap::RampWayType_descriptor();
}
template <> struct is_proto_enum< ::xsproto::hdmap::TrafficLighShapeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::hdmap::TrafficLighShapeType>() {
  return ::xsproto::hdmap::TrafficLighShapeType_descriptor();
}
template <> struct is_proto_enum< ::xsproto::hdmap::TrafficLightRangeWay> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::hdmap::TrafficLightRangeWay>() {
  return ::xsproto::hdmap::TrafficLightRangeWay_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_hdmap_2flocal_5fhdmap_2eproto__INCLUDED
