// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perception/prediction_obstacle.proto

#ifndef PROTOBUF_perception_2fprediction_5fobstacle_2eproto__INCLUDED
#define PROTOBUF_perception_2fprediction_5fobstacle_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "base/header.pb.h"
#include "perception/perception_object_info.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_perception_2fprediction_5fobstacle_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsObstacleInherentIntentImpl();
void InitDefaultsObstacleInherentIntent();
void InitDefaultsObstacleIntentImpl();
void InitDefaultsObstacleIntent();
void InitDefaultsPredictionPathPointImpl();
void InitDefaultsPredictionPathPoint();
void InitDefaultsPredictionTrajectoryPointImpl();
void InitDefaultsPredictionTrajectoryPoint();
void InitDefaultsTrajectoryPointImpl();
void InitDefaultsTrajectoryPoint();
void InitDefaultsTrajectoryImpl();
void InitDefaultsTrajectory();
void InitDefaultsScenarioImpl();
void InitDefaultsScenario();
void InitDefaultsObstaclePriorityImpl();
void InitDefaultsObstaclePriority();
void InitDefaultsObstacleInteractiveTagImpl();
void InitDefaultsObstacleInteractiveTag();
void InitDefaultsPredictionObstacleImpl();
void InitDefaultsPredictionObstacle();
void InitDefaultsObstacleFeatureImpl();
void InitDefaultsObstacleFeature();
void InitDefaultsPredictionObstaclesImpl();
void InitDefaultsPredictionObstacles();
inline void InitDefaults() {
  InitDefaultsObstacleInherentIntent();
  InitDefaultsObstacleIntent();
  InitDefaultsPredictionPathPoint();
  InitDefaultsPredictionTrajectoryPoint();
  InitDefaultsTrajectoryPoint();
  InitDefaultsTrajectory();
  InitDefaultsScenario();
  InitDefaultsObstaclePriority();
  InitDefaultsObstacleInteractiveTag();
  InitDefaultsPredictionObstacle();
  InitDefaultsObstacleFeature();
  InitDefaultsPredictionObstacles();
}
}  // namespace protobuf_perception_2fprediction_5fobstacle_2eproto
namespace xsproto {
namespace perception {
class ObstacleFeature;
class ObstacleFeatureDefaultTypeInternal;
extern ObstacleFeatureDefaultTypeInternal _ObstacleFeature_default_instance_;
class ObstacleInherentIntent;
class ObstacleInherentIntentDefaultTypeInternal;
extern ObstacleInherentIntentDefaultTypeInternal _ObstacleInherentIntent_default_instance_;
class ObstacleIntent;
class ObstacleIntentDefaultTypeInternal;
extern ObstacleIntentDefaultTypeInternal _ObstacleIntent_default_instance_;
class ObstacleInteractiveTag;
class ObstacleInteractiveTagDefaultTypeInternal;
extern ObstacleInteractiveTagDefaultTypeInternal _ObstacleInteractiveTag_default_instance_;
class ObstaclePriority;
class ObstaclePriorityDefaultTypeInternal;
extern ObstaclePriorityDefaultTypeInternal _ObstaclePriority_default_instance_;
class PredictionObstacle;
class PredictionObstacleDefaultTypeInternal;
extern PredictionObstacleDefaultTypeInternal _PredictionObstacle_default_instance_;
class PredictionObstacles;
class PredictionObstaclesDefaultTypeInternal;
extern PredictionObstaclesDefaultTypeInternal _PredictionObstacles_default_instance_;
class PredictionPathPoint;
class PredictionPathPointDefaultTypeInternal;
extern PredictionPathPointDefaultTypeInternal _PredictionPathPoint_default_instance_;
class PredictionTrajectoryPoint;
class PredictionTrajectoryPointDefaultTypeInternal;
extern PredictionTrajectoryPointDefaultTypeInternal _PredictionTrajectoryPoint_default_instance_;
class Scenario;
class ScenarioDefaultTypeInternal;
extern ScenarioDefaultTypeInternal _Scenario_default_instance_;
class Trajectory;
class TrajectoryDefaultTypeInternal;
extern TrajectoryDefaultTypeInternal _Trajectory_default_instance_;
class TrajectoryPoint;
class TrajectoryPointDefaultTypeInternal;
extern TrajectoryPointDefaultTypeInternal _TrajectoryPoint_default_instance_;
}  // namespace perception
}  // namespace xsproto
namespace xsproto {
namespace perception {

enum ObstacleInherentIntent_InherentIntentType {
  ObstacleInherentIntent_InherentIntentType_UNKNOWN = 0,
  ObstacleInherentIntent_InherentIntentType_STOP = 1,
  ObstacleInherentIntent_InherentIntentType_STATIONARY = 2,
  ObstacleInherentIntent_InherentIntentType_MOVING = 3,
  ObstacleInherentIntent_InherentIntentType_CHANGE_LANE = 4,
  ObstacleInherentIntent_InherentIntentType_LOW_ACCELERATION = 5,
  ObstacleInherentIntent_InherentIntentType_HIGH_ACCELERATION = 6,
  ObstacleInherentIntent_InherentIntentType_LOW_DECELERATION = 7,
  ObstacleInherentIntent_InherentIntentType_HIGH_DECELERATION = 8,
  ObstacleInherentIntent_InherentIntentType_ObstacleInherentIntent_InherentIntentType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ObstacleInherentIntent_InherentIntentType_ObstacleInherentIntent_InherentIntentType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ObstacleInherentIntent_InherentIntentType_IsValid(int value);
const ObstacleInherentIntent_InherentIntentType ObstacleInherentIntent_InherentIntentType_InherentIntentType_MIN = ObstacleInherentIntent_InherentIntentType_UNKNOWN;
const ObstacleInherentIntent_InherentIntentType ObstacleInherentIntent_InherentIntentType_InherentIntentType_MAX = ObstacleInherentIntent_InherentIntentType_HIGH_DECELERATION;
const int ObstacleInherentIntent_InherentIntentType_InherentIntentType_ARRAYSIZE = ObstacleInherentIntent_InherentIntentType_InherentIntentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObstacleInherentIntent_InherentIntentType_descriptor();
inline const ::std::string& ObstacleInherentIntent_InherentIntentType_Name(ObstacleInherentIntent_InherentIntentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObstacleInherentIntent_InherentIntentType_descriptor(), value);
}
inline bool ObstacleInherentIntent_InherentIntentType_Parse(
    const ::std::string& name, ObstacleInherentIntent_InherentIntentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObstacleInherentIntent_InherentIntentType>(
    ObstacleInherentIntent_InherentIntentType_descriptor(), name, value);
}
enum ObstacleIntent_IntentType {
  ObstacleIntent_IntentType_INT_KEEP_LANE = 0,
  ObstacleIntent_IntentType_INT_KEEP_LANE_INTSEC = 1,
  ObstacleIntent_IntentType_INT_CHANGE_TO_LEFT = 2,
  ObstacleIntent_IntentType_INT_CHANGE_TO_RIGHT = 3,
  ObstacleIntent_IntentType_INT_TURN_LEFT = 4,
  ObstacleIntent_IntentType_INT_TURN_RIGHT = 5,
  ObstacleIntent_IntentType_INT_TURN_BACK = 6,
  ObstacleIntent_IntentType_INT_WAIT_AT_INT = 7,
  ObstacleIntent_IntentType_INT_WAIT_IN_QUEUING = 8,
  ObstacleIntent_IntentType_INT_CROSSING = 9,
  ObstacleIntent_IntentType_INT_YIELD = 10,
  ObstacleIntent_IntentType_INT_QUEUE_JUMP = 11,
  ObstacleIntent_IntentType_INT_CUT_TO_FRONT = 12,
  ObstacleIntent_IntentType_INT_INTERCHANGE = 13,
  ObstacleIntent_IntentType_INT_CUT_OUT = 14,
  ObstacleIntent_IntentType_INT_DO_NOT_DRIVE = 15,
  ObstacleIntent_IntentType_INT_PARKING_ROADSIDE = 16,
  ObstacleIntent_IntentType_ObstacleIntent_IntentType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ObstacleIntent_IntentType_ObstacleIntent_IntentType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ObstacleIntent_IntentType_IsValid(int value);
const ObstacleIntent_IntentType ObstacleIntent_IntentType_IntentType_MIN = ObstacleIntent_IntentType_INT_KEEP_LANE;
const ObstacleIntent_IntentType ObstacleIntent_IntentType_IntentType_MAX = ObstacleIntent_IntentType_INT_PARKING_ROADSIDE;
const int ObstacleIntent_IntentType_IntentType_ARRAYSIZE = ObstacleIntent_IntentType_IntentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObstacleIntent_IntentType_descriptor();
inline const ::std::string& ObstacleIntent_IntentType_Name(ObstacleIntent_IntentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObstacleIntent_IntentType_descriptor(), value);
}
inline bool ObstacleIntent_IntentType_Parse(
    const ::std::string& name, ObstacleIntent_IntentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObstacleIntent_IntentType>(
    ObstacleIntent_IntentType_descriptor(), name, value);
}
enum Scenario_Type {
  Scenario_Type_UNKNOWN = 0,
  Scenario_Type_CRUISE = 1000,
  Scenario_Type_CRUISE_URBAN = 1001,
  Scenario_Type_CRUISE_HIGHWAY = 1002,
  Scenario_Type_JUNCTION = 2000,
  Scenario_Type_JUNCTION_TRAFFIC_LIGHT = 2001,
  Scenario_Type_JUNCTION_STOP_SIGN = 2002,
  Scenario_Type_Scenario_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Scenario_Type_Scenario_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Scenario_Type_IsValid(int value);
const Scenario_Type Scenario_Type_Type_MIN = Scenario_Type_UNKNOWN;
const Scenario_Type Scenario_Type_Type_MAX = Scenario_Type_JUNCTION_STOP_SIGN;
const int Scenario_Type_Type_ARRAYSIZE = Scenario_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Scenario_Type_descriptor();
inline const ::std::string& Scenario_Type_Name(Scenario_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Scenario_Type_descriptor(), value);
}
inline bool Scenario_Type_Parse(
    const ::std::string& name, Scenario_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Scenario_Type>(
    Scenario_Type_descriptor(), name, value);
}
enum ObstaclePriority_Priority {
  ObstaclePriority_Priority_NORMAL = 0,
  ObstaclePriority_Priority_CAUTION = 1,
  ObstaclePriority_Priority_IGNORE = 2,
  ObstaclePriority_Priority_ObstaclePriority_Priority_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ObstaclePriority_Priority_ObstaclePriority_Priority_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ObstaclePriority_Priority_IsValid(int value);
const ObstaclePriority_Priority ObstaclePriority_Priority_Priority_MIN = ObstaclePriority_Priority_NORMAL;
const ObstaclePriority_Priority ObstaclePriority_Priority_Priority_MAX = ObstaclePriority_Priority_IGNORE;
const int ObstaclePriority_Priority_Priority_ARRAYSIZE = ObstaclePriority_Priority_Priority_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObstaclePriority_Priority_descriptor();
inline const ::std::string& ObstaclePriority_Priority_Name(ObstaclePriority_Priority value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObstaclePriority_Priority_descriptor(), value);
}
inline bool ObstaclePriority_Priority_Parse(
    const ::std::string& name, ObstaclePriority_Priority* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObstaclePriority_Priority>(
    ObstaclePriority_Priority_descriptor(), name, value);
}
enum ObstacleInteractiveTag_InteractiveTag {
  ObstacleInteractiveTag_InteractiveTag_NONINTERACTION = 0,
  ObstacleInteractiveTag_InteractiveTag_INTERACTION = 1,
  ObstacleInteractiveTag_InteractiveTag_ObstacleInteractiveTag_InteractiveTag_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ObstacleInteractiveTag_InteractiveTag_ObstacleInteractiveTag_InteractiveTag_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ObstacleInteractiveTag_InteractiveTag_IsValid(int value);
const ObstacleInteractiveTag_InteractiveTag ObstacleInteractiveTag_InteractiveTag_InteractiveTag_MIN = ObstacleInteractiveTag_InteractiveTag_NONINTERACTION;
const ObstacleInteractiveTag_InteractiveTag ObstacleInteractiveTag_InteractiveTag_InteractiveTag_MAX = ObstacleInteractiveTag_InteractiveTag_INTERACTION;
const int ObstacleInteractiveTag_InteractiveTag_InteractiveTag_ARRAYSIZE = ObstacleInteractiveTag_InteractiveTag_InteractiveTag_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObstacleInteractiveTag_InteractiveTag_descriptor();
inline const ::std::string& ObstacleInteractiveTag_InteractiveTag_Name(ObstacleInteractiveTag_InteractiveTag value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObstacleInteractiveTag_InteractiveTag_descriptor(), value);
}
inline bool ObstacleInteractiveTag_InteractiveTag_Parse(
    const ::std::string& name, ObstacleInteractiveTag_InteractiveTag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObstacleInteractiveTag_InteractiveTag>(
    ObstacleInteractiveTag_InteractiveTag_descriptor(), name, value);
}
// ===================================================================

class ObstacleInherentIntent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.ObstacleInherentIntent) */ {
 public:
  ObstacleInherentIntent();
  virtual ~ObstacleInherentIntent();

  ObstacleInherentIntent(const ObstacleInherentIntent& from);

  inline ObstacleInherentIntent& operator=(const ObstacleInherentIntent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstacleInherentIntent(ObstacleInherentIntent&& from) noexcept
    : ObstacleInherentIntent() {
    *this = ::std::move(from);
  }

  inline ObstacleInherentIntent& operator=(ObstacleInherentIntent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleInherentIntent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstacleInherentIntent* internal_default_instance() {
    return reinterpret_cast<const ObstacleInherentIntent*>(
               &_ObstacleInherentIntent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ObstacleInherentIntent* other);
  friend void swap(ObstacleInherentIntent& a, ObstacleInherentIntent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstacleInherentIntent* New() const PROTOBUF_FINAL { return New(NULL); }

  ObstacleInherentIntent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObstacleInherentIntent& from);
  void MergeFrom(const ObstacleInherentIntent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObstacleInherentIntent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ObstacleInherentIntent_InherentIntentType InherentIntentType;
  static const InherentIntentType UNKNOWN =
    ObstacleInherentIntent_InherentIntentType_UNKNOWN;
  static const InherentIntentType STOP =
    ObstacleInherentIntent_InherentIntentType_STOP;
  static const InherentIntentType STATIONARY =
    ObstacleInherentIntent_InherentIntentType_STATIONARY;
  static const InherentIntentType MOVING =
    ObstacleInherentIntent_InherentIntentType_MOVING;
  static const InherentIntentType CHANGE_LANE =
    ObstacleInherentIntent_InherentIntentType_CHANGE_LANE;
  static const InherentIntentType LOW_ACCELERATION =
    ObstacleInherentIntent_InherentIntentType_LOW_ACCELERATION;
  static const InherentIntentType HIGH_ACCELERATION =
    ObstacleInherentIntent_InherentIntentType_HIGH_ACCELERATION;
  static const InherentIntentType LOW_DECELERATION =
    ObstacleInherentIntent_InherentIntentType_LOW_DECELERATION;
  static const InherentIntentType HIGH_DECELERATION =
    ObstacleInherentIntent_InherentIntentType_HIGH_DECELERATION;
  static inline bool InherentIntentType_IsValid(int value) {
    return ObstacleInherentIntent_InherentIntentType_IsValid(value);
  }
  static const InherentIntentType InherentIntentType_MIN =
    ObstacleInherentIntent_InherentIntentType_InherentIntentType_MIN;
  static const InherentIntentType InherentIntentType_MAX =
    ObstacleInherentIntent_InherentIntentType_InherentIntentType_MAX;
  static const int InherentIntentType_ARRAYSIZE =
    ObstacleInherentIntent_InherentIntentType_InherentIntentType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InherentIntentType_descriptor() {
    return ObstacleInherentIntent_InherentIntentType_descriptor();
  }
  static inline const ::std::string& InherentIntentType_Name(InherentIntentType value) {
    return ObstacleInherentIntent_InherentIntentType_Name(value);
  }
  static inline bool InherentIntentType_Parse(const ::std::string& name,
      InherentIntentType* value) {
    return ObstacleInherentIntent_InherentIntentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .xsproto.perception.ObstacleInherentIntent.InherentIntentType inherent_intent_type = 1;
  void clear_inherent_intent_type();
  static const int kInherentIntentTypeFieldNumber = 1;
  ::xsproto::perception::ObstacleInherentIntent_InherentIntentType inherent_intent_type() const;
  void set_inherent_intent_type(::xsproto::perception::ObstacleInherentIntent_InherentIntentType value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.ObstacleInherentIntent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int inherent_intent_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fprediction_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_perception_2fprediction_5fobstacle_2eproto::InitDefaultsObstacleInherentIntentImpl();
};
// -------------------------------------------------------------------

class ObstacleIntent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.ObstacleIntent) */ {
 public:
  ObstacleIntent();
  virtual ~ObstacleIntent();

  ObstacleIntent(const ObstacleIntent& from);

  inline ObstacleIntent& operator=(const ObstacleIntent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstacleIntent(ObstacleIntent&& from) noexcept
    : ObstacleIntent() {
    *this = ::std::move(from);
  }

  inline ObstacleIntent& operator=(ObstacleIntent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleIntent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstacleIntent* internal_default_instance() {
    return reinterpret_cast<const ObstacleIntent*>(
               &_ObstacleIntent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ObstacleIntent* other);
  friend void swap(ObstacleIntent& a, ObstacleIntent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstacleIntent* New() const PROTOBUF_FINAL { return New(NULL); }

  ObstacleIntent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObstacleIntent& from);
  void MergeFrom(const ObstacleIntent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObstacleIntent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ObstacleIntent_IntentType IntentType;
  static const IntentType INT_KEEP_LANE =
    ObstacleIntent_IntentType_INT_KEEP_LANE;
  static const IntentType INT_KEEP_LANE_INTSEC =
    ObstacleIntent_IntentType_INT_KEEP_LANE_INTSEC;
  static const IntentType INT_CHANGE_TO_LEFT =
    ObstacleIntent_IntentType_INT_CHANGE_TO_LEFT;
  static const IntentType INT_CHANGE_TO_RIGHT =
    ObstacleIntent_IntentType_INT_CHANGE_TO_RIGHT;
  static const IntentType INT_TURN_LEFT =
    ObstacleIntent_IntentType_INT_TURN_LEFT;
  static const IntentType INT_TURN_RIGHT =
    ObstacleIntent_IntentType_INT_TURN_RIGHT;
  static const IntentType INT_TURN_BACK =
    ObstacleIntent_IntentType_INT_TURN_BACK;
  static const IntentType INT_WAIT_AT_INT =
    ObstacleIntent_IntentType_INT_WAIT_AT_INT;
  static const IntentType INT_WAIT_IN_QUEUING =
    ObstacleIntent_IntentType_INT_WAIT_IN_QUEUING;
  static const IntentType INT_CROSSING =
    ObstacleIntent_IntentType_INT_CROSSING;
  static const IntentType INT_YIELD =
    ObstacleIntent_IntentType_INT_YIELD;
  static const IntentType INT_QUEUE_JUMP =
    ObstacleIntent_IntentType_INT_QUEUE_JUMP;
  static const IntentType INT_CUT_TO_FRONT =
    ObstacleIntent_IntentType_INT_CUT_TO_FRONT;
  static const IntentType INT_INTERCHANGE =
    ObstacleIntent_IntentType_INT_INTERCHANGE;
  static const IntentType INT_CUT_OUT =
    ObstacleIntent_IntentType_INT_CUT_OUT;
  static const IntentType INT_DO_NOT_DRIVE =
    ObstacleIntent_IntentType_INT_DO_NOT_DRIVE;
  static const IntentType INT_PARKING_ROADSIDE =
    ObstacleIntent_IntentType_INT_PARKING_ROADSIDE;
  static inline bool IntentType_IsValid(int value) {
    return ObstacleIntent_IntentType_IsValid(value);
  }
  static const IntentType IntentType_MIN =
    ObstacleIntent_IntentType_IntentType_MIN;
  static const IntentType IntentType_MAX =
    ObstacleIntent_IntentType_IntentType_MAX;
  static const int IntentType_ARRAYSIZE =
    ObstacleIntent_IntentType_IntentType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IntentType_descriptor() {
    return ObstacleIntent_IntentType_descriptor();
  }
  static inline const ::std::string& IntentType_Name(IntentType value) {
    return ObstacleIntent_IntentType_Name(value);
  }
  static inline bool IntentType_Parse(const ::std::string& name,
      IntentType* value) {
    return ObstacleIntent_IntentType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .xsproto.perception.ObstacleIntent.IntentType intent_type = 1;
  void clear_intent_type();
  static const int kIntentTypeFieldNumber = 1;
  ::xsproto::perception::ObstacleIntent_IntentType intent_type() const;
  void set_intent_type(::xsproto::perception::ObstacleIntent_IntentType value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.ObstacleIntent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int intent_type_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fprediction_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_perception_2fprediction_5fobstacle_2eproto::InitDefaultsObstacleIntentImpl();
};
// -------------------------------------------------------------------

class PredictionPathPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.PredictionPathPoint) */ {
 public:
  PredictionPathPoint();
  virtual ~PredictionPathPoint();

  PredictionPathPoint(const PredictionPathPoint& from);

  inline PredictionPathPoint& operator=(const PredictionPathPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PredictionPathPoint(PredictionPathPoint&& from) noexcept
    : PredictionPathPoint() {
    *this = ::std::move(from);
  }

  inline PredictionPathPoint& operator=(PredictionPathPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PredictionPathPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictionPathPoint* internal_default_instance() {
    return reinterpret_cast<const PredictionPathPoint*>(
               &_PredictionPathPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(PredictionPathPoint* other);
  friend void swap(PredictionPathPoint& a, PredictionPathPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PredictionPathPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  PredictionPathPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PredictionPathPoint& from);
  void MergeFrom(const PredictionPathPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PredictionPathPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // double heading = 3;
  void clear_heading();
  static const int kHeadingFieldNumber = 3;
  double heading() const;
  void set_heading(double value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.PredictionPathPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  double heading_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fprediction_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_perception_2fprediction_5fobstacle_2eproto::InitDefaultsPredictionPathPointImpl();
};
// -------------------------------------------------------------------

class PredictionTrajectoryPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.PredictionTrajectoryPoint) */ {
 public:
  PredictionTrajectoryPoint();
  virtual ~PredictionTrajectoryPoint();

  PredictionTrajectoryPoint(const PredictionTrajectoryPoint& from);

  inline PredictionTrajectoryPoint& operator=(const PredictionTrajectoryPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PredictionTrajectoryPoint(PredictionTrajectoryPoint&& from) noexcept
    : PredictionTrajectoryPoint() {
    *this = ::std::move(from);
  }

  inline PredictionTrajectoryPoint& operator=(PredictionTrajectoryPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PredictionTrajectoryPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictionTrajectoryPoint* internal_default_instance() {
    return reinterpret_cast<const PredictionTrajectoryPoint*>(
               &_PredictionTrajectoryPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(PredictionTrajectoryPoint* other);
  friend void swap(PredictionTrajectoryPoint& a, PredictionTrajectoryPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PredictionTrajectoryPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  PredictionTrajectoryPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PredictionTrajectoryPoint& from);
  void MergeFrom(const PredictionTrajectoryPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PredictionTrajectoryPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xsproto.perception.PredictionPathPoint path_point = 1;
  bool has_path_point() const;
  void clear_path_point();
  static const int kPathPointFieldNumber = 1;
  const ::xsproto::perception::PredictionPathPoint& path_point() const;
  ::xsproto::perception::PredictionPathPoint* release_path_point();
  ::xsproto::perception::PredictionPathPoint* mutable_path_point();
  void set_allocated_path_point(::xsproto::perception::PredictionPathPoint* path_point);

  // double timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  double timestamp() const;
  void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.PredictionTrajectoryPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xsproto::perception::PredictionPathPoint* path_point_;
  double timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fprediction_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_perception_2fprediction_5fobstacle_2eproto::InitDefaultsPredictionTrajectoryPointImpl();
};
// -------------------------------------------------------------------

class TrajectoryPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.TrajectoryPoint) */ {
 public:
  TrajectoryPoint();
  virtual ~TrajectoryPoint();

  TrajectoryPoint(const TrajectoryPoint& from);

  inline TrajectoryPoint& operator=(const TrajectoryPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrajectoryPoint(TrajectoryPoint&& from) noexcept
    : TrajectoryPoint() {
    *this = ::std::move(from);
  }

  inline TrajectoryPoint& operator=(TrajectoryPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrajectoryPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryPoint* internal_default_instance() {
    return reinterpret_cast<const TrajectoryPoint*>(
               &_TrajectoryPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(TrajectoryPoint* other);
  friend void swap(TrajectoryPoint& a, TrajectoryPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  TrajectoryPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TrajectoryPoint& from);
  void MergeFrom(const TrajectoryPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TrajectoryPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // double y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // float relative_time = 3;
  void clear_relative_time();
  static const int kRelativeTimeFieldNumber = 3;
  float relative_time() const;
  void set_relative_time(float value);

  // float linear_veloc = 4;
  void clear_linear_veloc();
  static const int kLinearVelocFieldNumber = 4;
  float linear_veloc() const;
  void set_linear_veloc(float value);

  // float linear_acc = 5;
  void clear_linear_acc();
  static const int kLinearAccFieldNumber = 5;
  float linear_acc() const;
  void set_linear_acc(float value);

  // float accum_s = 6;
  void clear_accum_s();
  static const int kAccumSFieldNumber = 6;
  float accum_s() const;
  void set_accum_s(float value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.TrajectoryPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double x_;
  double y_;
  float relative_time_;
  float linear_veloc_;
  float linear_acc_;
  float accum_s_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fprediction_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_perception_2fprediction_5fobstacle_2eproto::InitDefaultsTrajectoryPointImpl();
};
// -------------------------------------------------------------------

class Trajectory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.Trajectory) */ {
 public:
  Trajectory();
  virtual ~Trajectory();

  Trajectory(const Trajectory& from);

  inline Trajectory& operator=(const Trajectory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trajectory(Trajectory&& from) noexcept
    : Trajectory() {
    *this = ::std::move(from);
  }

  inline Trajectory& operator=(Trajectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Trajectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trajectory* internal_default_instance() {
    return reinterpret_cast<const Trajectory*>(
               &_Trajectory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Trajectory* other);
  friend void swap(Trajectory& a, Trajectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trajectory* New() const PROTOBUF_FINAL { return New(NULL); }

  Trajectory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Trajectory& from);
  void MergeFrom(const Trajectory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Trajectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.perception.TrajectoryPoint trajectory_point = 2;
  int trajectory_point_size() const;
  void clear_trajectory_point();
  static const int kTrajectoryPointFieldNumber = 2;
  const ::xsproto::perception::TrajectoryPoint& trajectory_point(int index) const;
  ::xsproto::perception::TrajectoryPoint* mutable_trajectory_point(int index);
  ::xsproto::perception::TrajectoryPoint* add_trajectory_point();
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::TrajectoryPoint >*
      mutable_trajectory_point();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::TrajectoryPoint >&
      trajectory_point() const;

  // float probability = 1;
  void clear_probability();
  static const int kProbabilityFieldNumber = 1;
  float probability() const;
  void set_probability(float value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.Trajectory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::TrajectoryPoint > trajectory_point_;
  float probability_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fprediction_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_perception_2fprediction_5fobstacle_2eproto::InitDefaultsTrajectoryImpl();
};
// -------------------------------------------------------------------

class Scenario : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.Scenario) */ {
 public:
  Scenario();
  virtual ~Scenario();

  Scenario(const Scenario& from);

  inline Scenario& operator=(const Scenario& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scenario(Scenario&& from) noexcept
    : Scenario() {
    *this = ::std::move(from);
  }

  inline Scenario& operator=(Scenario&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scenario& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scenario* internal_default_instance() {
    return reinterpret_cast<const Scenario*>(
               &_Scenario_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Scenario* other);
  friend void swap(Scenario& a, Scenario& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scenario* New() const PROTOBUF_FINAL { return New(NULL); }

  Scenario* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Scenario& from);
  void MergeFrom(const Scenario& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Scenario* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Scenario_Type Type;
  static const Type UNKNOWN =
    Scenario_Type_UNKNOWN;
  static const Type CRUISE =
    Scenario_Type_CRUISE;
  static const Type CRUISE_URBAN =
    Scenario_Type_CRUISE_URBAN;
  static const Type CRUISE_HIGHWAY =
    Scenario_Type_CRUISE_HIGHWAY;
  static const Type JUNCTION =
    Scenario_Type_JUNCTION;
  static const Type JUNCTION_TRAFFIC_LIGHT =
    Scenario_Type_JUNCTION_TRAFFIC_LIGHT;
  static const Type JUNCTION_STOP_SIGN =
    Scenario_Type_JUNCTION_STOP_SIGN;
  static inline bool Type_IsValid(int value) {
    return Scenario_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Scenario_Type_Type_MIN;
  static const Type Type_MAX =
    Scenario_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Scenario_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Scenario_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Scenario_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Scenario_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .xsproto.perception.Scenario.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::xsproto::perception::Scenario_Type type() const;
  void set_type(::xsproto::perception::Scenario_Type value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.Scenario)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fprediction_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_perception_2fprediction_5fobstacle_2eproto::InitDefaultsScenarioImpl();
};
// -------------------------------------------------------------------

class ObstaclePriority : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.ObstaclePriority) */ {
 public:
  ObstaclePriority();
  virtual ~ObstaclePriority();

  ObstaclePriority(const ObstaclePriority& from);

  inline ObstaclePriority& operator=(const ObstaclePriority& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstaclePriority(ObstaclePriority&& from) noexcept
    : ObstaclePriority() {
    *this = ::std::move(from);
  }

  inline ObstaclePriority& operator=(ObstaclePriority&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstaclePriority& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstaclePriority* internal_default_instance() {
    return reinterpret_cast<const ObstaclePriority*>(
               &_ObstaclePriority_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ObstaclePriority* other);
  friend void swap(ObstaclePriority& a, ObstaclePriority& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstaclePriority* New() const PROTOBUF_FINAL { return New(NULL); }

  ObstaclePriority* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObstaclePriority& from);
  void MergeFrom(const ObstaclePriority& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObstaclePriority* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ObstaclePriority_Priority Priority;
  static const Priority NORMAL =
    ObstaclePriority_Priority_NORMAL;
  static const Priority CAUTION =
    ObstaclePriority_Priority_CAUTION;
  static const Priority IGNORE =
    ObstaclePriority_Priority_IGNORE;
  static inline bool Priority_IsValid(int value) {
    return ObstaclePriority_Priority_IsValid(value);
  }
  static const Priority Priority_MIN =
    ObstaclePriority_Priority_Priority_MIN;
  static const Priority Priority_MAX =
    ObstaclePriority_Priority_Priority_MAX;
  static const int Priority_ARRAYSIZE =
    ObstaclePriority_Priority_Priority_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Priority_descriptor() {
    return ObstaclePriority_Priority_descriptor();
  }
  static inline const ::std::string& Priority_Name(Priority value) {
    return ObstaclePriority_Priority_Name(value);
  }
  static inline bool Priority_Parse(const ::std::string& name,
      Priority* value) {
    return ObstaclePriority_Priority_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .xsproto.perception.ObstaclePriority.Priority priority = 1;
  void clear_priority();
  static const int kPriorityFieldNumber = 1;
  ::xsproto::perception::ObstaclePriority_Priority priority() const;
  void set_priority(::xsproto::perception::ObstaclePriority_Priority value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.ObstaclePriority)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int priority_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fprediction_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_perception_2fprediction_5fobstacle_2eproto::InitDefaultsObstaclePriorityImpl();
};
// -------------------------------------------------------------------

class ObstacleInteractiveTag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.ObstacleInteractiveTag) */ {
 public:
  ObstacleInteractiveTag();
  virtual ~ObstacleInteractiveTag();

  ObstacleInteractiveTag(const ObstacleInteractiveTag& from);

  inline ObstacleInteractiveTag& operator=(const ObstacleInteractiveTag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstacleInteractiveTag(ObstacleInteractiveTag&& from) noexcept
    : ObstacleInteractiveTag() {
    *this = ::std::move(from);
  }

  inline ObstacleInteractiveTag& operator=(ObstacleInteractiveTag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleInteractiveTag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstacleInteractiveTag* internal_default_instance() {
    return reinterpret_cast<const ObstacleInteractiveTag*>(
               &_ObstacleInteractiveTag_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ObstacleInteractiveTag* other);
  friend void swap(ObstacleInteractiveTag& a, ObstacleInteractiveTag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstacleInteractiveTag* New() const PROTOBUF_FINAL { return New(NULL); }

  ObstacleInteractiveTag* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObstacleInteractiveTag& from);
  void MergeFrom(const ObstacleInteractiveTag& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObstacleInteractiveTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ObstacleInteractiveTag_InteractiveTag InteractiveTag;
  static const InteractiveTag NONINTERACTION =
    ObstacleInteractiveTag_InteractiveTag_NONINTERACTION;
  static const InteractiveTag INTERACTION =
    ObstacleInteractiveTag_InteractiveTag_INTERACTION;
  static inline bool InteractiveTag_IsValid(int value) {
    return ObstacleInteractiveTag_InteractiveTag_IsValid(value);
  }
  static const InteractiveTag InteractiveTag_MIN =
    ObstacleInteractiveTag_InteractiveTag_InteractiveTag_MIN;
  static const InteractiveTag InteractiveTag_MAX =
    ObstacleInteractiveTag_InteractiveTag_InteractiveTag_MAX;
  static const int InteractiveTag_ARRAYSIZE =
    ObstacleInteractiveTag_InteractiveTag_InteractiveTag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InteractiveTag_descriptor() {
    return ObstacleInteractiveTag_InteractiveTag_descriptor();
  }
  static inline const ::std::string& InteractiveTag_Name(InteractiveTag value) {
    return ObstacleInteractiveTag_InteractiveTag_Name(value);
  }
  static inline bool InteractiveTag_Parse(const ::std::string& name,
      InteractiveTag* value) {
    return ObstacleInteractiveTag_InteractiveTag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .xsproto.perception.ObstacleInteractiveTag.InteractiveTag interactive_tag = 1;
  void clear_interactive_tag();
  static const int kInteractiveTagFieldNumber = 1;
  ::xsproto::perception::ObstacleInteractiveTag_InteractiveTag interactive_tag() const;
  void set_interactive_tag(::xsproto::perception::ObstacleInteractiveTag_InteractiveTag value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.ObstacleInteractiveTag)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int interactive_tag_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fprediction_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_perception_2fprediction_5fobstacle_2eproto::InitDefaultsObstacleInteractiveTagImpl();
};
// -------------------------------------------------------------------

class PredictionObstacle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.PredictionObstacle) */ {
 public:
  PredictionObstacle();
  virtual ~PredictionObstacle();

  PredictionObstacle(const PredictionObstacle& from);

  inline PredictionObstacle& operator=(const PredictionObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PredictionObstacle(PredictionObstacle&& from) noexcept
    : PredictionObstacle() {
    *this = ::std::move(from);
  }

  inline PredictionObstacle& operator=(PredictionObstacle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PredictionObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictionObstacle* internal_default_instance() {
    return reinterpret_cast<const PredictionObstacle*>(
               &_PredictionObstacle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(PredictionObstacle* other);
  friend void swap(PredictionObstacle& a, PredictionObstacle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PredictionObstacle* New() const PROTOBUF_FINAL { return New(NULL); }

  PredictionObstacle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PredictionObstacle& from);
  void MergeFrom(const PredictionObstacle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PredictionObstacle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.perception.Trajectory trajectory = 8;
  int trajectory_size() const;
  void clear_trajectory();
  static const int kTrajectoryFieldNumber = 8;
  const ::xsproto::perception::Trajectory& trajectory(int index) const;
  ::xsproto::perception::Trajectory* mutable_trajectory(int index);
  ::xsproto::perception::Trajectory* add_trajectory();
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Trajectory >*
      mutable_trajectory();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Trajectory >&
      trajectory() const;

  // .xsproto.perception.ObstacleInherentIntent inherent_intent = 3;
  bool has_inherent_intent() const;
  void clear_inherent_intent();
  static const int kInherentIntentFieldNumber = 3;
  const ::xsproto::perception::ObstacleInherentIntent& inherent_intent() const;
  ::xsproto::perception::ObstacleInherentIntent* release_inherent_intent();
  ::xsproto::perception::ObstacleInherentIntent* mutable_inherent_intent();
  void set_allocated_inherent_intent(::xsproto::perception::ObstacleInherentIntent* inherent_intent);

  // .xsproto.perception.ObstacleIntent intent = 4;
  bool has_intent() const;
  void clear_intent();
  static const int kIntentFieldNumber = 4;
  const ::xsproto::perception::ObstacleIntent& intent() const;
  ::xsproto::perception::ObstacleIntent* release_intent();
  ::xsproto::perception::ObstacleIntent* mutable_intent();
  void set_allocated_intent(::xsproto::perception::ObstacleIntent* intent);

  // .xsproto.perception.ObstacleInteractiveTag interactive_tag = 5;
  bool has_interactive_tag() const;
  void clear_interactive_tag();
  static const int kInteractiveTagFieldNumber = 5;
  const ::xsproto::perception::ObstacleInteractiveTag& interactive_tag() const;
  ::xsproto::perception::ObstacleInteractiveTag* release_interactive_tag();
  ::xsproto::perception::ObstacleInteractiveTag* mutable_interactive_tag();
  void set_allocated_interactive_tag(::xsproto::perception::ObstacleInteractiveTag* interactive_tag);

  // .xsproto.perception.ObstaclePriority priority = 6;
  bool has_priority() const;
  void clear_priority();
  static const int kPriorityFieldNumber = 6;
  const ::xsproto::perception::ObstaclePriority& priority() const;
  ::xsproto::perception::ObstaclePriority* release_priority();
  ::xsproto::perception::ObstaclePriority* mutable_priority();
  void set_allocated_priority(::xsproto::perception::ObstaclePriority* priority);

  // .xsproto.perception.PerceptionObject perception_obstacle = 9;
  bool has_perception_obstacle() const;
  void clear_perception_obstacle();
  static const int kPerceptionObstacleFieldNumber = 9;
  const ::xsproto::perception::PerceptionObject& perception_obstacle() const;
  ::xsproto::perception::PerceptionObject* release_perception_obstacle();
  ::xsproto::perception::PerceptionObject* mutable_perception_obstacle();
  void set_allocated_perception_obstacle(::xsproto::perception::PerceptionObject* perception_obstacle);

  // .xsproto.perception.ObstacleFeature obstacle_feature = 10;
  bool has_obstacle_feature() const;
  void clear_obstacle_feature();
  static const int kObstacleFeatureFieldNumber = 10;
  const ::xsproto::perception::ObstacleFeature& obstacle_feature() const;
  ::xsproto::perception::ObstacleFeature* release_obstacle_feature();
  ::xsproto::perception::ObstacleFeature* mutable_obstacle_feature();
  void set_allocated_obstacle_feature(::xsproto::perception::ObstacleFeature* obstacle_feature);

  // double timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  double timestamp() const;
  void set_timestamp(double value);

  // float predicted_period = 2;
  void clear_predicted_period();
  static const int kPredictedPeriodFieldNumber = 2;
  float predicted_period() const;
  void set_predicted_period(float value);

  // bool is_static = 7;
  void clear_is_static();
  static const int kIsStaticFieldNumber = 7;
  bool is_static() const;
  void set_is_static(bool value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.PredictionObstacle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Trajectory > trajectory_;
  ::xsproto::perception::ObstacleInherentIntent* inherent_intent_;
  ::xsproto::perception::ObstacleIntent* intent_;
  ::xsproto::perception::ObstacleInteractiveTag* interactive_tag_;
  ::xsproto::perception::ObstaclePriority* priority_;
  ::xsproto::perception::PerceptionObject* perception_obstacle_;
  ::xsproto::perception::ObstacleFeature* obstacle_feature_;
  double timestamp_;
  float predicted_period_;
  bool is_static_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fprediction_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_perception_2fprediction_5fobstacle_2eproto::InitDefaultsPredictionObstacleImpl();
};
// -------------------------------------------------------------------

class ObstacleFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.ObstacleFeature) */ {
 public:
  ObstacleFeature();
  virtual ~ObstacleFeature();

  ObstacleFeature(const ObstacleFeature& from);

  inline ObstacleFeature& operator=(const ObstacleFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstacleFeature(ObstacleFeature&& from) noexcept
    : ObstacleFeature() {
    *this = ::std::move(from);
  }

  inline ObstacleFeature& operator=(ObstacleFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstacleFeature* internal_default_instance() {
    return reinterpret_cast<const ObstacleFeature*>(
               &_ObstacleFeature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ObstacleFeature* other);
  friend void swap(ObstacleFeature& a, ObstacleFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstacleFeature* New() const PROTOBUF_FINAL { return New(NULL); }

  ObstacleFeature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ObstacleFeature& from);
  void MergeFrom(const ObstacleFeature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ObstacleFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 surrounding_lane_id = 7;
  int surrounding_lane_id_size() const;
  void clear_surrounding_lane_id();
  static const int kSurroundingLaneIdFieldNumber = 7;
  ::google::protobuf::int32 surrounding_lane_id(int index) const;
  void set_surrounding_lane_id(int index, ::google::protobuf::int32 value);
  void add_surrounding_lane_id(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      surrounding_lane_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_surrounding_lane_id();

  // repeated int32 within_lane_id = 8;
  int within_lane_id_size() const;
  void clear_within_lane_id();
  static const int kWithinLaneIdFieldNumber = 8;
  ::google::protobuf::int32 within_lane_id(int index) const;
  void set_within_lane_id(int index, ::google::protobuf::int32 value);
  void add_within_lane_id(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      within_lane_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_within_lane_id();

  // repeated .xsproto.perception.PredictionTrajectoryPoint future_trajectory_points = 9;
  int future_trajectory_points_size() const;
  void clear_future_trajectory_points();
  static const int kFutureTrajectoryPointsFieldNumber = 9;
  const ::xsproto::perception::PredictionTrajectoryPoint& future_trajectory_points(int index) const;
  ::xsproto::perception::PredictionTrajectoryPoint* mutable_future_trajectory_points(int index);
  ::xsproto::perception::PredictionTrajectoryPoint* add_future_trajectory_points();
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >*
      mutable_future_trajectory_points();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >&
      future_trajectory_points() const;

  // repeated .xsproto.perception.PredictionTrajectoryPoint short_term_predicted_trajectory_points = 10;
  int short_term_predicted_trajectory_points_size() const;
  void clear_short_term_predicted_trajectory_points();
  static const int kShortTermPredictedTrajectoryPointsFieldNumber = 10;
  const ::xsproto::perception::PredictionTrajectoryPoint& short_term_predicted_trajectory_points(int index) const;
  ::xsproto::perception::PredictionTrajectoryPoint* mutable_short_term_predicted_trajectory_points(int index);
  ::xsproto::perception::PredictionTrajectoryPoint* add_short_term_predicted_trajectory_points();
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >*
      mutable_short_term_predicted_trajectory_points();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >&
      short_term_predicted_trajectory_points() const;

  // repeated .xsproto.perception.PredictionTrajectoryPoint predicted_trajectory = 11;
  int predicted_trajectory_size() const;
  void clear_predicted_trajectory();
  static const int kPredictedTrajectoryFieldNumber = 11;
  const ::xsproto::perception::PredictionTrajectoryPoint& predicted_trajectory(int index) const;
  ::xsproto::perception::PredictionTrajectoryPoint* mutable_predicted_trajectory(int index);
  ::xsproto::perception::PredictionTrajectoryPoint* add_predicted_trajectory();
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >*
      mutable_predicted_trajectory();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >&
      predicted_trajectory() const;

  // repeated .xsproto.perception.PredictionTrajectoryPoint adc_trajectory_points = 12;
  int adc_trajectory_points_size() const;
  void clear_adc_trajectory_points();
  static const int kAdcTrajectoryPointsFieldNumber = 12;
  const ::xsproto::perception::PredictionTrajectoryPoint& adc_trajectory_points(int index) const;
  ::xsproto::perception::PredictionTrajectoryPoint* mutable_adc_trajectory_points(int index);
  ::xsproto::perception::PredictionTrajectoryPoint* add_adc_trajectory_points();
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >*
      mutable_adc_trajectory_points();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >&
      adc_trajectory_points() const;

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // float linear_veloc = 2;
  void clear_linear_veloc();
  static const int kLinearVelocFieldNumber = 2;
  float linear_veloc() const;
  void set_linear_veloc(float value);

  // float linear_veloc_angle = 3;
  void clear_linear_veloc_angle();
  static const int kLinearVelocAngleFieldNumber = 3;
  float linear_veloc_angle() const;
  void set_linear_veloc_angle(float value);

  // float raw_linear_speed_angle = 4;
  void clear_raw_linear_speed_angle();
  static const int kRawLinearSpeedAngleFieldNumber = 4;
  float raw_linear_speed_angle() const;
  void set_raw_linear_speed_angle(float value);

  // float raw_linear_speed = 5;
  void clear_raw_linear_speed();
  static const int kRawLinearSpeedFieldNumber = 5;
  float raw_linear_speed() const;
  void set_raw_linear_speed(float value);

  // bool is_near_junction = 6;
  void clear_is_near_junction();
  static const int kIsNearJunctionFieldNumber = 6;
  bool is_near_junction() const;
  void set_is_near_junction(bool value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.ObstacleFeature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > surrounding_lane_id_;
  mutable int _surrounding_lane_id_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > within_lane_id_;
  mutable int _within_lane_id_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint > future_trajectory_points_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint > short_term_predicted_trajectory_points_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint > predicted_trajectory_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint > adc_trajectory_points_;
  ::google::protobuf::int32 id_;
  float linear_veloc_;
  float linear_veloc_angle_;
  float raw_linear_speed_angle_;
  float raw_linear_speed_;
  bool is_near_junction_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fprediction_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_perception_2fprediction_5fobstacle_2eproto::InitDefaultsObstacleFeatureImpl();
};
// -------------------------------------------------------------------

class PredictionObstacles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.PredictionObstacles) */ {
 public:
  PredictionObstacles();
  virtual ~PredictionObstacles();

  PredictionObstacles(const PredictionObstacles& from);

  inline PredictionObstacles& operator=(const PredictionObstacles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PredictionObstacles(PredictionObstacles&& from) noexcept
    : PredictionObstacles() {
    *this = ::std::move(from);
  }

  inline PredictionObstacles& operator=(PredictionObstacles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PredictionObstacles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PredictionObstacles* internal_default_instance() {
    return reinterpret_cast<const PredictionObstacles*>(
               &_PredictionObstacles_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(PredictionObstacles* other);
  friend void swap(PredictionObstacles& a, PredictionObstacles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PredictionObstacles* New() const PROTOBUF_FINAL { return New(NULL); }

  PredictionObstacles* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PredictionObstacles& from);
  void MergeFrom(const PredictionObstacles& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PredictionObstacles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xsproto.perception.PredictionObstacle prediction_obstacles = 2;
  int prediction_obstacles_size() const;
  void clear_prediction_obstacles();
  static const int kPredictionObstaclesFieldNumber = 2;
  const ::xsproto::perception::PredictionObstacle& prediction_obstacles(int index) const;
  ::xsproto::perception::PredictionObstacle* mutable_prediction_obstacles(int index);
  ::xsproto::perception::PredictionObstacle* add_prediction_obstacles();
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionObstacle >*
      mutable_prediction_obstacles();
  const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionObstacle >&
      prediction_obstacles() const;

  // .xsproto.base.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xsproto::base::Header& header() const;
  ::xsproto::base::Header* release_header();
  ::xsproto::base::Header* mutable_header();
  void set_allocated_header(::xsproto::base::Header* header);

  // .xsproto.perception.Scenario scenario = 5;
  bool has_scenario() const;
  void clear_scenario();
  static const int kScenarioFieldNumber = 5;
  const ::xsproto::perception::Scenario& scenario() const;
  ::xsproto::perception::Scenario* release_scenario();
  ::xsproto::perception::Scenario* mutable_scenario();
  void set_allocated_scenario(::xsproto::perception::Scenario* scenario);

  // double start_timestamp = 3;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 3;
  double start_timestamp() const;
  void set_start_timestamp(double value);

  // double end_timestamp = 4;
  void clear_end_timestamp();
  static const int kEndTimestampFieldNumber = 4;
  double end_timestamp() const;
  void set_end_timestamp(double value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.PredictionObstacles)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionObstacle > prediction_obstacles_;
  ::xsproto::base::Header* header_;
  ::xsproto::perception::Scenario* scenario_;
  double start_timestamp_;
  double end_timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2fprediction_5fobstacle_2eproto::TableStruct;
  friend void ::protobuf_perception_2fprediction_5fobstacle_2eproto::InitDefaultsPredictionObstaclesImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ObstacleInherentIntent

// .xsproto.perception.ObstacleInherentIntent.InherentIntentType inherent_intent_type = 1;
inline void ObstacleInherentIntent::clear_inherent_intent_type() {
  inherent_intent_type_ = 0;
}
inline ::xsproto::perception::ObstacleInherentIntent_InherentIntentType ObstacleInherentIntent::inherent_intent_type() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleInherentIntent.inherent_intent_type)
  return static_cast< ::xsproto::perception::ObstacleInherentIntent_InherentIntentType >(inherent_intent_type_);
}
inline void ObstacleInherentIntent::set_inherent_intent_type(::xsproto::perception::ObstacleInherentIntent_InherentIntentType value) {
  
  inherent_intent_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.ObstacleInherentIntent.inherent_intent_type)
}

// -------------------------------------------------------------------

// ObstacleIntent

// .xsproto.perception.ObstacleIntent.IntentType intent_type = 1;
inline void ObstacleIntent::clear_intent_type() {
  intent_type_ = 0;
}
inline ::xsproto::perception::ObstacleIntent_IntentType ObstacleIntent::intent_type() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleIntent.intent_type)
  return static_cast< ::xsproto::perception::ObstacleIntent_IntentType >(intent_type_);
}
inline void ObstacleIntent::set_intent_type(::xsproto::perception::ObstacleIntent_IntentType value) {
  
  intent_type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.ObstacleIntent.intent_type)
}

// -------------------------------------------------------------------

// PredictionPathPoint

// double x = 1;
inline void PredictionPathPoint::clear_x() {
  x_ = 0;
}
inline double PredictionPathPoint::x() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionPathPoint.x)
  return x_;
}
inline void PredictionPathPoint::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PredictionPathPoint.x)
}

// double y = 2;
inline void PredictionPathPoint::clear_y() {
  y_ = 0;
}
inline double PredictionPathPoint::y() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionPathPoint.y)
  return y_;
}
inline void PredictionPathPoint::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PredictionPathPoint.y)
}

// double heading = 3;
inline void PredictionPathPoint::clear_heading() {
  heading_ = 0;
}
inline double PredictionPathPoint::heading() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionPathPoint.heading)
  return heading_;
}
inline void PredictionPathPoint::set_heading(double value) {
  
  heading_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PredictionPathPoint.heading)
}

// -------------------------------------------------------------------

// PredictionTrajectoryPoint

// .xsproto.perception.PredictionPathPoint path_point = 1;
inline bool PredictionTrajectoryPoint::has_path_point() const {
  return this != internal_default_instance() && path_point_ != NULL;
}
inline void PredictionTrajectoryPoint::clear_path_point() {
  if (GetArenaNoVirtual() == NULL && path_point_ != NULL) {
    delete path_point_;
  }
  path_point_ = NULL;
}
inline const ::xsproto::perception::PredictionPathPoint& PredictionTrajectoryPoint::path_point() const {
  const ::xsproto::perception::PredictionPathPoint* p = path_point_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionTrajectoryPoint.path_point)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::PredictionPathPoint*>(
      &::xsproto::perception::_PredictionPathPoint_default_instance_);
}
inline ::xsproto::perception::PredictionPathPoint* PredictionTrajectoryPoint::release_path_point() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PredictionTrajectoryPoint.path_point)
  
  ::xsproto::perception::PredictionPathPoint* temp = path_point_;
  path_point_ = NULL;
  return temp;
}
inline ::xsproto::perception::PredictionPathPoint* PredictionTrajectoryPoint::mutable_path_point() {
  
  if (path_point_ == NULL) {
    path_point_ = new ::xsproto::perception::PredictionPathPoint;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PredictionTrajectoryPoint.path_point)
  return path_point_;
}
inline void PredictionTrajectoryPoint::set_allocated_path_point(::xsproto::perception::PredictionPathPoint* path_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete path_point_;
  }
  if (path_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      path_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, path_point, submessage_arena);
    }
    
  } else {
    
  }
  path_point_ = path_point;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PredictionTrajectoryPoint.path_point)
}

// double timestamp = 2;
inline void PredictionTrajectoryPoint::clear_timestamp() {
  timestamp_ = 0;
}
inline double PredictionTrajectoryPoint::timestamp() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionTrajectoryPoint.timestamp)
  return timestamp_;
}
inline void PredictionTrajectoryPoint::set_timestamp(double value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PredictionTrajectoryPoint.timestamp)
}

// -------------------------------------------------------------------

// TrajectoryPoint

// double x = 1;
inline void TrajectoryPoint::clear_x() {
  x_ = 0;
}
inline double TrajectoryPoint::x() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.TrajectoryPoint.x)
  return x_;
}
inline void TrajectoryPoint::set_x(double value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.TrajectoryPoint.x)
}

// double y = 2;
inline void TrajectoryPoint::clear_y() {
  y_ = 0;
}
inline double TrajectoryPoint::y() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.TrajectoryPoint.y)
  return y_;
}
inline void TrajectoryPoint::set_y(double value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.TrajectoryPoint.y)
}

// float relative_time = 3;
inline void TrajectoryPoint::clear_relative_time() {
  relative_time_ = 0;
}
inline float TrajectoryPoint::relative_time() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.TrajectoryPoint.relative_time)
  return relative_time_;
}
inline void TrajectoryPoint::set_relative_time(float value) {
  
  relative_time_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.TrajectoryPoint.relative_time)
}

// float linear_veloc = 4;
inline void TrajectoryPoint::clear_linear_veloc() {
  linear_veloc_ = 0;
}
inline float TrajectoryPoint::linear_veloc() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.TrajectoryPoint.linear_veloc)
  return linear_veloc_;
}
inline void TrajectoryPoint::set_linear_veloc(float value) {
  
  linear_veloc_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.TrajectoryPoint.linear_veloc)
}

// float linear_acc = 5;
inline void TrajectoryPoint::clear_linear_acc() {
  linear_acc_ = 0;
}
inline float TrajectoryPoint::linear_acc() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.TrajectoryPoint.linear_acc)
  return linear_acc_;
}
inline void TrajectoryPoint::set_linear_acc(float value) {
  
  linear_acc_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.TrajectoryPoint.linear_acc)
}

// float accum_s = 6;
inline void TrajectoryPoint::clear_accum_s() {
  accum_s_ = 0;
}
inline float TrajectoryPoint::accum_s() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.TrajectoryPoint.accum_s)
  return accum_s_;
}
inline void TrajectoryPoint::set_accum_s(float value) {
  
  accum_s_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.TrajectoryPoint.accum_s)
}

// -------------------------------------------------------------------

// Trajectory

// float probability = 1;
inline void Trajectory::clear_probability() {
  probability_ = 0;
}
inline float Trajectory::probability() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.Trajectory.probability)
  return probability_;
}
inline void Trajectory::set_probability(float value) {
  
  probability_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.Trajectory.probability)
}

// repeated .xsproto.perception.TrajectoryPoint trajectory_point = 2;
inline int Trajectory::trajectory_point_size() const {
  return trajectory_point_.size();
}
inline void Trajectory::clear_trajectory_point() {
  trajectory_point_.Clear();
}
inline const ::xsproto::perception::TrajectoryPoint& Trajectory::trajectory_point(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.Trajectory.trajectory_point)
  return trajectory_point_.Get(index);
}
inline ::xsproto::perception::TrajectoryPoint* Trajectory::mutable_trajectory_point(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.perception.Trajectory.trajectory_point)
  return trajectory_point_.Mutable(index);
}
inline ::xsproto::perception::TrajectoryPoint* Trajectory::add_trajectory_point() {
  // @@protoc_insertion_point(field_add:xsproto.perception.Trajectory.trajectory_point)
  return trajectory_point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::perception::TrajectoryPoint >*
Trajectory::mutable_trajectory_point() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.Trajectory.trajectory_point)
  return &trajectory_point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::TrajectoryPoint >&
Trajectory::trajectory_point() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.Trajectory.trajectory_point)
  return trajectory_point_;
}

// -------------------------------------------------------------------

// Scenario

// .xsproto.perception.Scenario.Type type = 1;
inline void Scenario::clear_type() {
  type_ = 0;
}
inline ::xsproto::perception::Scenario_Type Scenario::type() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.Scenario.type)
  return static_cast< ::xsproto::perception::Scenario_Type >(type_);
}
inline void Scenario::set_type(::xsproto::perception::Scenario_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.Scenario.type)
}

// -------------------------------------------------------------------

// ObstaclePriority

// .xsproto.perception.ObstaclePriority.Priority priority = 1;
inline void ObstaclePriority::clear_priority() {
  priority_ = 0;
}
inline ::xsproto::perception::ObstaclePriority_Priority ObstaclePriority::priority() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstaclePriority.priority)
  return static_cast< ::xsproto::perception::ObstaclePriority_Priority >(priority_);
}
inline void ObstaclePriority::set_priority(::xsproto::perception::ObstaclePriority_Priority value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.ObstaclePriority.priority)
}

// -------------------------------------------------------------------

// ObstacleInteractiveTag

// .xsproto.perception.ObstacleInteractiveTag.InteractiveTag interactive_tag = 1;
inline void ObstacleInteractiveTag::clear_interactive_tag() {
  interactive_tag_ = 0;
}
inline ::xsproto::perception::ObstacleInteractiveTag_InteractiveTag ObstacleInteractiveTag::interactive_tag() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleInteractiveTag.interactive_tag)
  return static_cast< ::xsproto::perception::ObstacleInteractiveTag_InteractiveTag >(interactive_tag_);
}
inline void ObstacleInteractiveTag::set_interactive_tag(::xsproto::perception::ObstacleInteractiveTag_InteractiveTag value) {
  
  interactive_tag_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.ObstacleInteractiveTag.interactive_tag)
}

// -------------------------------------------------------------------

// PredictionObstacle

// double timestamp = 1;
inline void PredictionObstacle::clear_timestamp() {
  timestamp_ = 0;
}
inline double PredictionObstacle::timestamp() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacle.timestamp)
  return timestamp_;
}
inline void PredictionObstacle::set_timestamp(double value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PredictionObstacle.timestamp)
}

// float predicted_period = 2;
inline void PredictionObstacle::clear_predicted_period() {
  predicted_period_ = 0;
}
inline float PredictionObstacle::predicted_period() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacle.predicted_period)
  return predicted_period_;
}
inline void PredictionObstacle::set_predicted_period(float value) {
  
  predicted_period_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PredictionObstacle.predicted_period)
}

// .xsproto.perception.ObstacleInherentIntent inherent_intent = 3;
inline bool PredictionObstacle::has_inherent_intent() const {
  return this != internal_default_instance() && inherent_intent_ != NULL;
}
inline void PredictionObstacle::clear_inherent_intent() {
  if (GetArenaNoVirtual() == NULL && inherent_intent_ != NULL) {
    delete inherent_intent_;
  }
  inherent_intent_ = NULL;
}
inline const ::xsproto::perception::ObstacleInherentIntent& PredictionObstacle::inherent_intent() const {
  const ::xsproto::perception::ObstacleInherentIntent* p = inherent_intent_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacle.inherent_intent)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::ObstacleInherentIntent*>(
      &::xsproto::perception::_ObstacleInherentIntent_default_instance_);
}
inline ::xsproto::perception::ObstacleInherentIntent* PredictionObstacle::release_inherent_intent() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PredictionObstacle.inherent_intent)
  
  ::xsproto::perception::ObstacleInherentIntent* temp = inherent_intent_;
  inherent_intent_ = NULL;
  return temp;
}
inline ::xsproto::perception::ObstacleInherentIntent* PredictionObstacle::mutable_inherent_intent() {
  
  if (inherent_intent_ == NULL) {
    inherent_intent_ = new ::xsproto::perception::ObstacleInherentIntent;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PredictionObstacle.inherent_intent)
  return inherent_intent_;
}
inline void PredictionObstacle::set_allocated_inherent_intent(::xsproto::perception::ObstacleInherentIntent* inherent_intent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete inherent_intent_;
  }
  if (inherent_intent) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      inherent_intent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inherent_intent, submessage_arena);
    }
    
  } else {
    
  }
  inherent_intent_ = inherent_intent;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PredictionObstacle.inherent_intent)
}

// .xsproto.perception.ObstacleIntent intent = 4;
inline bool PredictionObstacle::has_intent() const {
  return this != internal_default_instance() && intent_ != NULL;
}
inline void PredictionObstacle::clear_intent() {
  if (GetArenaNoVirtual() == NULL && intent_ != NULL) {
    delete intent_;
  }
  intent_ = NULL;
}
inline const ::xsproto::perception::ObstacleIntent& PredictionObstacle::intent() const {
  const ::xsproto::perception::ObstacleIntent* p = intent_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacle.intent)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::ObstacleIntent*>(
      &::xsproto::perception::_ObstacleIntent_default_instance_);
}
inline ::xsproto::perception::ObstacleIntent* PredictionObstacle::release_intent() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PredictionObstacle.intent)
  
  ::xsproto::perception::ObstacleIntent* temp = intent_;
  intent_ = NULL;
  return temp;
}
inline ::xsproto::perception::ObstacleIntent* PredictionObstacle::mutable_intent() {
  
  if (intent_ == NULL) {
    intent_ = new ::xsproto::perception::ObstacleIntent;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PredictionObstacle.intent)
  return intent_;
}
inline void PredictionObstacle::set_allocated_intent(::xsproto::perception::ObstacleIntent* intent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete intent_;
  }
  if (intent) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      intent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, intent, submessage_arena);
    }
    
  } else {
    
  }
  intent_ = intent;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PredictionObstacle.intent)
}

// .xsproto.perception.ObstacleInteractiveTag interactive_tag = 5;
inline bool PredictionObstacle::has_interactive_tag() const {
  return this != internal_default_instance() && interactive_tag_ != NULL;
}
inline void PredictionObstacle::clear_interactive_tag() {
  if (GetArenaNoVirtual() == NULL && interactive_tag_ != NULL) {
    delete interactive_tag_;
  }
  interactive_tag_ = NULL;
}
inline const ::xsproto::perception::ObstacleInteractiveTag& PredictionObstacle::interactive_tag() const {
  const ::xsproto::perception::ObstacleInteractiveTag* p = interactive_tag_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacle.interactive_tag)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::ObstacleInteractiveTag*>(
      &::xsproto::perception::_ObstacleInteractiveTag_default_instance_);
}
inline ::xsproto::perception::ObstacleInteractiveTag* PredictionObstacle::release_interactive_tag() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PredictionObstacle.interactive_tag)
  
  ::xsproto::perception::ObstacleInteractiveTag* temp = interactive_tag_;
  interactive_tag_ = NULL;
  return temp;
}
inline ::xsproto::perception::ObstacleInteractiveTag* PredictionObstacle::mutable_interactive_tag() {
  
  if (interactive_tag_ == NULL) {
    interactive_tag_ = new ::xsproto::perception::ObstacleInteractiveTag;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PredictionObstacle.interactive_tag)
  return interactive_tag_;
}
inline void PredictionObstacle::set_allocated_interactive_tag(::xsproto::perception::ObstacleInteractiveTag* interactive_tag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete interactive_tag_;
  }
  if (interactive_tag) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      interactive_tag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, interactive_tag, submessage_arena);
    }
    
  } else {
    
  }
  interactive_tag_ = interactive_tag;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PredictionObstacle.interactive_tag)
}

// .xsproto.perception.ObstaclePriority priority = 6;
inline bool PredictionObstacle::has_priority() const {
  return this != internal_default_instance() && priority_ != NULL;
}
inline void PredictionObstacle::clear_priority() {
  if (GetArenaNoVirtual() == NULL && priority_ != NULL) {
    delete priority_;
  }
  priority_ = NULL;
}
inline const ::xsproto::perception::ObstaclePriority& PredictionObstacle::priority() const {
  const ::xsproto::perception::ObstaclePriority* p = priority_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacle.priority)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::ObstaclePriority*>(
      &::xsproto::perception::_ObstaclePriority_default_instance_);
}
inline ::xsproto::perception::ObstaclePriority* PredictionObstacle::release_priority() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PredictionObstacle.priority)
  
  ::xsproto::perception::ObstaclePriority* temp = priority_;
  priority_ = NULL;
  return temp;
}
inline ::xsproto::perception::ObstaclePriority* PredictionObstacle::mutable_priority() {
  
  if (priority_ == NULL) {
    priority_ = new ::xsproto::perception::ObstaclePriority;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PredictionObstacle.priority)
  return priority_;
}
inline void PredictionObstacle::set_allocated_priority(::xsproto::perception::ObstaclePriority* priority) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete priority_;
  }
  if (priority) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      priority = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, priority, submessage_arena);
    }
    
  } else {
    
  }
  priority_ = priority;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PredictionObstacle.priority)
}

// bool is_static = 7;
inline void PredictionObstacle::clear_is_static() {
  is_static_ = false;
}
inline bool PredictionObstacle::is_static() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacle.is_static)
  return is_static_;
}
inline void PredictionObstacle::set_is_static(bool value) {
  
  is_static_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PredictionObstacle.is_static)
}

// repeated .xsproto.perception.Trajectory trajectory = 8;
inline int PredictionObstacle::trajectory_size() const {
  return trajectory_.size();
}
inline void PredictionObstacle::clear_trajectory() {
  trajectory_.Clear();
}
inline const ::xsproto::perception::Trajectory& PredictionObstacle::trajectory(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacle.trajectory)
  return trajectory_.Get(index);
}
inline ::xsproto::perception::Trajectory* PredictionObstacle::mutable_trajectory(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PredictionObstacle.trajectory)
  return trajectory_.Mutable(index);
}
inline ::xsproto::perception::Trajectory* PredictionObstacle::add_trajectory() {
  // @@protoc_insertion_point(field_add:xsproto.perception.PredictionObstacle.trajectory)
  return trajectory_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Trajectory >*
PredictionObstacle::mutable_trajectory() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.PredictionObstacle.trajectory)
  return &trajectory_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::Trajectory >&
PredictionObstacle::trajectory() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.PredictionObstacle.trajectory)
  return trajectory_;
}

// .xsproto.perception.PerceptionObject perception_obstacle = 9;
inline bool PredictionObstacle::has_perception_obstacle() const {
  return this != internal_default_instance() && perception_obstacle_ != NULL;
}
inline const ::xsproto::perception::PerceptionObject& PredictionObstacle::perception_obstacle() const {
  const ::xsproto::perception::PerceptionObject* p = perception_obstacle_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacle.perception_obstacle)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::PerceptionObject*>(
      &::xsproto::perception::_PerceptionObject_default_instance_);
}
inline ::xsproto::perception::PerceptionObject* PredictionObstacle::release_perception_obstacle() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PredictionObstacle.perception_obstacle)
  
  ::xsproto::perception::PerceptionObject* temp = perception_obstacle_;
  perception_obstacle_ = NULL;
  return temp;
}
inline ::xsproto::perception::PerceptionObject* PredictionObstacle::mutable_perception_obstacle() {
  
  if (perception_obstacle_ == NULL) {
    perception_obstacle_ = new ::xsproto::perception::PerceptionObject;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PredictionObstacle.perception_obstacle)
  return perception_obstacle_;
}
inline void PredictionObstacle::set_allocated_perception_obstacle(::xsproto::perception::PerceptionObject* perception_obstacle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(perception_obstacle_);
  }
  if (perception_obstacle) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      perception_obstacle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, perception_obstacle, submessage_arena);
    }
    
  } else {
    
  }
  perception_obstacle_ = perception_obstacle;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PredictionObstacle.perception_obstacle)
}

// .xsproto.perception.ObstacleFeature obstacle_feature = 10;
inline bool PredictionObstacle::has_obstacle_feature() const {
  return this != internal_default_instance() && obstacle_feature_ != NULL;
}
inline void PredictionObstacle::clear_obstacle_feature() {
  if (GetArenaNoVirtual() == NULL && obstacle_feature_ != NULL) {
    delete obstacle_feature_;
  }
  obstacle_feature_ = NULL;
}
inline const ::xsproto::perception::ObstacleFeature& PredictionObstacle::obstacle_feature() const {
  const ::xsproto::perception::ObstacleFeature* p = obstacle_feature_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacle.obstacle_feature)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::ObstacleFeature*>(
      &::xsproto::perception::_ObstacleFeature_default_instance_);
}
inline ::xsproto::perception::ObstacleFeature* PredictionObstacle::release_obstacle_feature() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PredictionObstacle.obstacle_feature)
  
  ::xsproto::perception::ObstacleFeature* temp = obstacle_feature_;
  obstacle_feature_ = NULL;
  return temp;
}
inline ::xsproto::perception::ObstacleFeature* PredictionObstacle::mutable_obstacle_feature() {
  
  if (obstacle_feature_ == NULL) {
    obstacle_feature_ = new ::xsproto::perception::ObstacleFeature;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PredictionObstacle.obstacle_feature)
  return obstacle_feature_;
}
inline void PredictionObstacle::set_allocated_obstacle_feature(::xsproto::perception::ObstacleFeature* obstacle_feature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete obstacle_feature_;
  }
  if (obstacle_feature) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      obstacle_feature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, obstacle_feature, submessage_arena);
    }
    
  } else {
    
  }
  obstacle_feature_ = obstacle_feature;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PredictionObstacle.obstacle_feature)
}

// -------------------------------------------------------------------

// ObstacleFeature

// int32 id = 1;
inline void ObstacleFeature::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 ObstacleFeature::id() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleFeature.id)
  return id_;
}
inline void ObstacleFeature::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.ObstacleFeature.id)
}

// float linear_veloc = 2;
inline void ObstacleFeature::clear_linear_veloc() {
  linear_veloc_ = 0;
}
inline float ObstacleFeature::linear_veloc() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleFeature.linear_veloc)
  return linear_veloc_;
}
inline void ObstacleFeature::set_linear_veloc(float value) {
  
  linear_veloc_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.ObstacleFeature.linear_veloc)
}

// float linear_veloc_angle = 3;
inline void ObstacleFeature::clear_linear_veloc_angle() {
  linear_veloc_angle_ = 0;
}
inline float ObstacleFeature::linear_veloc_angle() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleFeature.linear_veloc_angle)
  return linear_veloc_angle_;
}
inline void ObstacleFeature::set_linear_veloc_angle(float value) {
  
  linear_veloc_angle_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.ObstacleFeature.linear_veloc_angle)
}

// float raw_linear_speed_angle = 4;
inline void ObstacleFeature::clear_raw_linear_speed_angle() {
  raw_linear_speed_angle_ = 0;
}
inline float ObstacleFeature::raw_linear_speed_angle() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleFeature.raw_linear_speed_angle)
  return raw_linear_speed_angle_;
}
inline void ObstacleFeature::set_raw_linear_speed_angle(float value) {
  
  raw_linear_speed_angle_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.ObstacleFeature.raw_linear_speed_angle)
}

// float raw_linear_speed = 5;
inline void ObstacleFeature::clear_raw_linear_speed() {
  raw_linear_speed_ = 0;
}
inline float ObstacleFeature::raw_linear_speed() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleFeature.raw_linear_speed)
  return raw_linear_speed_;
}
inline void ObstacleFeature::set_raw_linear_speed(float value) {
  
  raw_linear_speed_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.ObstacleFeature.raw_linear_speed)
}

// bool is_near_junction = 6;
inline void ObstacleFeature::clear_is_near_junction() {
  is_near_junction_ = false;
}
inline bool ObstacleFeature::is_near_junction() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleFeature.is_near_junction)
  return is_near_junction_;
}
inline void ObstacleFeature::set_is_near_junction(bool value) {
  
  is_near_junction_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.ObstacleFeature.is_near_junction)
}

// repeated int32 surrounding_lane_id = 7;
inline int ObstacleFeature::surrounding_lane_id_size() const {
  return surrounding_lane_id_.size();
}
inline void ObstacleFeature::clear_surrounding_lane_id() {
  surrounding_lane_id_.Clear();
}
inline ::google::protobuf::int32 ObstacleFeature::surrounding_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleFeature.surrounding_lane_id)
  return surrounding_lane_id_.Get(index);
}
inline void ObstacleFeature::set_surrounding_lane_id(int index, ::google::protobuf::int32 value) {
  surrounding_lane_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.perception.ObstacleFeature.surrounding_lane_id)
}
inline void ObstacleFeature::add_surrounding_lane_id(::google::protobuf::int32 value) {
  surrounding_lane_id_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.perception.ObstacleFeature.surrounding_lane_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ObstacleFeature::surrounding_lane_id() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.ObstacleFeature.surrounding_lane_id)
  return surrounding_lane_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ObstacleFeature::mutable_surrounding_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.ObstacleFeature.surrounding_lane_id)
  return &surrounding_lane_id_;
}

// repeated int32 within_lane_id = 8;
inline int ObstacleFeature::within_lane_id_size() const {
  return within_lane_id_.size();
}
inline void ObstacleFeature::clear_within_lane_id() {
  within_lane_id_.Clear();
}
inline ::google::protobuf::int32 ObstacleFeature::within_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleFeature.within_lane_id)
  return within_lane_id_.Get(index);
}
inline void ObstacleFeature::set_within_lane_id(int index, ::google::protobuf::int32 value) {
  within_lane_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:xsproto.perception.ObstacleFeature.within_lane_id)
}
inline void ObstacleFeature::add_within_lane_id(::google::protobuf::int32 value) {
  within_lane_id_.Add(value);
  // @@protoc_insertion_point(field_add:xsproto.perception.ObstacleFeature.within_lane_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ObstacleFeature::within_lane_id() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.ObstacleFeature.within_lane_id)
  return within_lane_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ObstacleFeature::mutable_within_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.ObstacleFeature.within_lane_id)
  return &within_lane_id_;
}

// repeated .xsproto.perception.PredictionTrajectoryPoint future_trajectory_points = 9;
inline int ObstacleFeature::future_trajectory_points_size() const {
  return future_trajectory_points_.size();
}
inline void ObstacleFeature::clear_future_trajectory_points() {
  future_trajectory_points_.Clear();
}
inline const ::xsproto::perception::PredictionTrajectoryPoint& ObstacleFeature::future_trajectory_points(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleFeature.future_trajectory_points)
  return future_trajectory_points_.Get(index);
}
inline ::xsproto::perception::PredictionTrajectoryPoint* ObstacleFeature::mutable_future_trajectory_points(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.perception.ObstacleFeature.future_trajectory_points)
  return future_trajectory_points_.Mutable(index);
}
inline ::xsproto::perception::PredictionTrajectoryPoint* ObstacleFeature::add_future_trajectory_points() {
  // @@protoc_insertion_point(field_add:xsproto.perception.ObstacleFeature.future_trajectory_points)
  return future_trajectory_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >*
ObstacleFeature::mutable_future_trajectory_points() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.ObstacleFeature.future_trajectory_points)
  return &future_trajectory_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >&
ObstacleFeature::future_trajectory_points() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.ObstacleFeature.future_trajectory_points)
  return future_trajectory_points_;
}

// repeated .xsproto.perception.PredictionTrajectoryPoint short_term_predicted_trajectory_points = 10;
inline int ObstacleFeature::short_term_predicted_trajectory_points_size() const {
  return short_term_predicted_trajectory_points_.size();
}
inline void ObstacleFeature::clear_short_term_predicted_trajectory_points() {
  short_term_predicted_trajectory_points_.Clear();
}
inline const ::xsproto::perception::PredictionTrajectoryPoint& ObstacleFeature::short_term_predicted_trajectory_points(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleFeature.short_term_predicted_trajectory_points)
  return short_term_predicted_trajectory_points_.Get(index);
}
inline ::xsproto::perception::PredictionTrajectoryPoint* ObstacleFeature::mutable_short_term_predicted_trajectory_points(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.perception.ObstacleFeature.short_term_predicted_trajectory_points)
  return short_term_predicted_trajectory_points_.Mutable(index);
}
inline ::xsproto::perception::PredictionTrajectoryPoint* ObstacleFeature::add_short_term_predicted_trajectory_points() {
  // @@protoc_insertion_point(field_add:xsproto.perception.ObstacleFeature.short_term_predicted_trajectory_points)
  return short_term_predicted_trajectory_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >*
ObstacleFeature::mutable_short_term_predicted_trajectory_points() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.ObstacleFeature.short_term_predicted_trajectory_points)
  return &short_term_predicted_trajectory_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >&
ObstacleFeature::short_term_predicted_trajectory_points() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.ObstacleFeature.short_term_predicted_trajectory_points)
  return short_term_predicted_trajectory_points_;
}

// repeated .xsproto.perception.PredictionTrajectoryPoint predicted_trajectory = 11;
inline int ObstacleFeature::predicted_trajectory_size() const {
  return predicted_trajectory_.size();
}
inline void ObstacleFeature::clear_predicted_trajectory() {
  predicted_trajectory_.Clear();
}
inline const ::xsproto::perception::PredictionTrajectoryPoint& ObstacleFeature::predicted_trajectory(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleFeature.predicted_trajectory)
  return predicted_trajectory_.Get(index);
}
inline ::xsproto::perception::PredictionTrajectoryPoint* ObstacleFeature::mutable_predicted_trajectory(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.perception.ObstacleFeature.predicted_trajectory)
  return predicted_trajectory_.Mutable(index);
}
inline ::xsproto::perception::PredictionTrajectoryPoint* ObstacleFeature::add_predicted_trajectory() {
  // @@protoc_insertion_point(field_add:xsproto.perception.ObstacleFeature.predicted_trajectory)
  return predicted_trajectory_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >*
ObstacleFeature::mutable_predicted_trajectory() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.ObstacleFeature.predicted_trajectory)
  return &predicted_trajectory_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >&
ObstacleFeature::predicted_trajectory() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.ObstacleFeature.predicted_trajectory)
  return predicted_trajectory_;
}

// repeated .xsproto.perception.PredictionTrajectoryPoint adc_trajectory_points = 12;
inline int ObstacleFeature::adc_trajectory_points_size() const {
  return adc_trajectory_points_.size();
}
inline void ObstacleFeature::clear_adc_trajectory_points() {
  adc_trajectory_points_.Clear();
}
inline const ::xsproto::perception::PredictionTrajectoryPoint& ObstacleFeature::adc_trajectory_points(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.ObstacleFeature.adc_trajectory_points)
  return adc_trajectory_points_.Get(index);
}
inline ::xsproto::perception::PredictionTrajectoryPoint* ObstacleFeature::mutable_adc_trajectory_points(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.perception.ObstacleFeature.adc_trajectory_points)
  return adc_trajectory_points_.Mutable(index);
}
inline ::xsproto::perception::PredictionTrajectoryPoint* ObstacleFeature::add_adc_trajectory_points() {
  // @@protoc_insertion_point(field_add:xsproto.perception.ObstacleFeature.adc_trajectory_points)
  return adc_trajectory_points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >*
ObstacleFeature::mutable_adc_trajectory_points() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.ObstacleFeature.adc_trajectory_points)
  return &adc_trajectory_points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionTrajectoryPoint >&
ObstacleFeature::adc_trajectory_points() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.ObstacleFeature.adc_trajectory_points)
  return adc_trajectory_points_;
}

// -------------------------------------------------------------------

// PredictionObstacles

// .xsproto.base.Header header = 1;
inline bool PredictionObstacles::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::xsproto::base::Header& PredictionObstacles::header() const {
  const ::xsproto::base::Header* p = header_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacles.header)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::base::Header*>(
      &::xsproto::base::_Header_default_instance_);
}
inline ::xsproto::base::Header* PredictionObstacles::release_header() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PredictionObstacles.header)
  
  ::xsproto::base::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::xsproto::base::Header* PredictionObstacles::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::xsproto::base::Header;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PredictionObstacles.header)
  return header_;
}
inline void PredictionObstacles::set_allocated_header(::xsproto::base::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PredictionObstacles.header)
}

// repeated .xsproto.perception.PredictionObstacle prediction_obstacles = 2;
inline int PredictionObstacles::prediction_obstacles_size() const {
  return prediction_obstacles_.size();
}
inline void PredictionObstacles::clear_prediction_obstacles() {
  prediction_obstacles_.Clear();
}
inline const ::xsproto::perception::PredictionObstacle& PredictionObstacles::prediction_obstacles(int index) const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacles.prediction_obstacles)
  return prediction_obstacles_.Get(index);
}
inline ::xsproto::perception::PredictionObstacle* PredictionObstacles::mutable_prediction_obstacles(int index) {
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PredictionObstacles.prediction_obstacles)
  return prediction_obstacles_.Mutable(index);
}
inline ::xsproto::perception::PredictionObstacle* PredictionObstacles::add_prediction_obstacles() {
  // @@protoc_insertion_point(field_add:xsproto.perception.PredictionObstacles.prediction_obstacles)
  return prediction_obstacles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionObstacle >*
PredictionObstacles::mutable_prediction_obstacles() {
  // @@protoc_insertion_point(field_mutable_list:xsproto.perception.PredictionObstacles.prediction_obstacles)
  return &prediction_obstacles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::xsproto::perception::PredictionObstacle >&
PredictionObstacles::prediction_obstacles() const {
  // @@protoc_insertion_point(field_list:xsproto.perception.PredictionObstacles.prediction_obstacles)
  return prediction_obstacles_;
}

// double start_timestamp = 3;
inline void PredictionObstacles::clear_start_timestamp() {
  start_timestamp_ = 0;
}
inline double PredictionObstacles::start_timestamp() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacles.start_timestamp)
  return start_timestamp_;
}
inline void PredictionObstacles::set_start_timestamp(double value) {
  
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PredictionObstacles.start_timestamp)
}

// double end_timestamp = 4;
inline void PredictionObstacles::clear_end_timestamp() {
  end_timestamp_ = 0;
}
inline double PredictionObstacles::end_timestamp() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacles.end_timestamp)
  return end_timestamp_;
}
inline void PredictionObstacles::set_end_timestamp(double value) {
  
  end_timestamp_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.PredictionObstacles.end_timestamp)
}

// .xsproto.perception.Scenario scenario = 5;
inline bool PredictionObstacles::has_scenario() const {
  return this != internal_default_instance() && scenario_ != NULL;
}
inline void PredictionObstacles::clear_scenario() {
  if (GetArenaNoVirtual() == NULL && scenario_ != NULL) {
    delete scenario_;
  }
  scenario_ = NULL;
}
inline const ::xsproto::perception::Scenario& PredictionObstacles::scenario() const {
  const ::xsproto::perception::Scenario* p = scenario_;
  // @@protoc_insertion_point(field_get:xsproto.perception.PredictionObstacles.scenario)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::Scenario*>(
      &::xsproto::perception::_Scenario_default_instance_);
}
inline ::xsproto::perception::Scenario* PredictionObstacles::release_scenario() {
  // @@protoc_insertion_point(field_release:xsproto.perception.PredictionObstacles.scenario)
  
  ::xsproto::perception::Scenario* temp = scenario_;
  scenario_ = NULL;
  return temp;
}
inline ::xsproto::perception::Scenario* PredictionObstacles::mutable_scenario() {
  
  if (scenario_ == NULL) {
    scenario_ = new ::xsproto::perception::Scenario;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.PredictionObstacles.scenario)
  return scenario_;
}
inline void PredictionObstacles::set_allocated_scenario(::xsproto::perception::Scenario* scenario) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete scenario_;
  }
  if (scenario) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      scenario = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scenario, submessage_arena);
    }
    
  } else {
    
  }
  scenario_ = scenario;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.PredictionObstacles.scenario)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception
}  // namespace xsproto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::xsproto::perception::ObstacleInherentIntent_InherentIntentType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::perception::ObstacleInherentIntent_InherentIntentType>() {
  return ::xsproto::perception::ObstacleInherentIntent_InherentIntentType_descriptor();
}
template <> struct is_proto_enum< ::xsproto::perception::ObstacleIntent_IntentType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::perception::ObstacleIntent_IntentType>() {
  return ::xsproto::perception::ObstacleIntent_IntentType_descriptor();
}
template <> struct is_proto_enum< ::xsproto::perception::Scenario_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::perception::Scenario_Type>() {
  return ::xsproto::perception::Scenario_Type_descriptor();
}
template <> struct is_proto_enum< ::xsproto::perception::ObstaclePriority_Priority> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::perception::ObstaclePriority_Priority>() {
  return ::xsproto::perception::ObstaclePriority_Priority_descriptor();
}
template <> struct is_proto_enum< ::xsproto::perception::ObstacleInteractiveTag_InteractiveTag> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::perception::ObstacleInteractiveTag_InteractiveTag>() {
  return ::xsproto::perception::ObstacleInteractiveTag_InteractiveTag_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perception_2fprediction_5fobstacle_2eproto__INCLUDED
