// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perception/lidar_data.proto

#ifndef PROTOBUF_perception_2flidar_5fdata_2eproto__INCLUDED
#define PROTOBUF_perception_2flidar_5fdata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "base/header.pb.h"
#include "perception/perception_common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_perception_2flidar_5fdata_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsLidarStatusImpl();
void InitDefaultsLidarStatus();
void InitDefaultsLidarDataImpl();
void InitDefaultsLidarData();
inline void InitDefaults() {
  InitDefaultsLidarStatus();
  InitDefaultsLidarData();
}
}  // namespace protobuf_perception_2flidar_5fdata_2eproto
namespace xsproto {
namespace perception {
class LidarData;
class LidarDataDefaultTypeInternal;
extern LidarDataDefaultTypeInternal _LidarData_default_instance_;
class LidarStatus;
class LidarStatusDefaultTypeInternal;
extern LidarStatusDefaultTypeInternal _LidarStatus_default_instance_;
}  // namespace perception
}  // namespace xsproto
namespace xsproto {
namespace perception {

enum ReturnMode {
  FirstReturn = 0,
  LastReturn = 1,
  StronggestReturn = 2,
  DualReturn = 3,
  TripleReturn = 4,
  ReturnMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReturnMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ReturnMode_IsValid(int value);
const ReturnMode ReturnMode_MIN = FirstReturn;
const ReturnMode ReturnMode_MAX = TripleReturn;
const int ReturnMode_ARRAYSIZE = ReturnMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReturnMode_descriptor();
inline const ::std::string& ReturnMode_Name(ReturnMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReturnMode_descriptor(), value);
}
inline bool ReturnMode_Parse(
    const ::std::string& name, ReturnMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReturnMode>(
    ReturnMode_descriptor(), name, value);
}
enum SyncMode {
  PPS = 0,
  GPS = 1,
  PTP = 2,
  gPTP = 3,
  SyncMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SyncMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SyncMode_IsValid(int value);
const SyncMode SyncMode_MIN = PPS;
const SyncMode SyncMode_MAX = gPTP;
const int SyncMode_ARRAYSIZE = SyncMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* SyncMode_descriptor();
inline const ::std::string& SyncMode_Name(SyncMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    SyncMode_descriptor(), value);
}
inline bool SyncMode_Parse(
    const ::std::string& name, SyncMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SyncMode>(
    SyncMode_descriptor(), name, value);
}
// ===================================================================

class LidarStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.LidarStatus) */ {
 public:
  LidarStatus();
  virtual ~LidarStatus();

  LidarStatus(const LidarStatus& from);

  inline LidarStatus& operator=(const LidarStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LidarStatus(LidarStatus&& from) noexcept
    : LidarStatus() {
    *this = ::std::move(from);
  }

  inline LidarStatus& operator=(LidarStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LidarStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarStatus* internal_default_instance() {
    return reinterpret_cast<const LidarStatus*>(
               &_LidarStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LidarStatus* other);
  friend void swap(LidarStatus& a, LidarStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LidarStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  LidarStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LidarStatus& from);
  void MergeFrom(const LidarStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LidarStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // bytes sn = 2;
  void clear_sn();
  static const int kSnFieldNumber = 2;
  const ::std::string& sn() const;
  void set_sn(const ::std::string& value);
  #if LANG_CXX11
  void set_sn(::std::string&& value);
  #endif
  void set_sn(const char* value);
  void set_sn(const void* value, size_t size);
  ::std::string* mutable_sn();
  ::std::string* release_sn();
  void set_allocated_sn(::std::string* sn);

  // bytes top_frm = 3;
  void clear_top_frm();
  static const int kTopFrmFieldNumber = 3;
  const ::std::string& top_frm() const;
  void set_top_frm(const ::std::string& value);
  #if LANG_CXX11
  void set_top_frm(::std::string&& value);
  #endif
  void set_top_frm(const char* value);
  void set_top_frm(const void* value, size_t size);
  ::std::string* mutable_top_frm();
  ::std::string* release_top_frm();
  void set_allocated_top_frm(::std::string* top_frm);

  // bytes bot_frm = 4;
  void clear_bot_frm();
  static const int kBotFrmFieldNumber = 4;
  const ::std::string& bot_frm() const;
  void set_bot_frm(const ::std::string& value);
  #if LANG_CXX11
  void set_bot_frm(::std::string&& value);
  #endif
  void set_bot_frm(const char* value);
  void set_bot_frm(const void* value, size_t size);
  ::std::string* mutable_bot_frm();
  ::std::string* release_bot_frm();
  void set_allocated_bot_frm(::std::string* bot_frm);

  // bytes sw_frm = 5;
  void clear_sw_frm();
  static const int kSwFrmFieldNumber = 5;
  const ::std::string& sw_frm() const;
  void set_sw_frm(const ::std::string& value);
  #if LANG_CXX11
  void set_sw_frm(::std::string&& value);
  #endif
  void set_sw_frm(const char* value);
  void set_sw_frm(const void* value, size_t size);
  ::std::string* mutable_sw_frm();
  ::std::string* release_sw_frm();
  void set_allocated_sw_frm(::std::string* sw_frm);

  // .xsproto.perception.ReturnMode return_mode = 6;
  void clear_return_mode();
  static const int kReturnModeFieldNumber = 6;
  ::xsproto::perception::ReturnMode return_mode() const;
  void set_return_mode(::xsproto::perception::ReturnMode value);

  // .xsproto.perception.SyncMode sync_mode = 7;
  void clear_sync_mode();
  static const int kSyncModeFieldNumber = 7;
  ::xsproto::perception::SyncMode sync_mode() const;
  void set_sync_mode(::xsproto::perception::SyncMode value);

  // bool temp_status = 8;
  void clear_temp_status();
  static const int kTempStatusFieldNumber = 8;
  bool temp_status() const;
  void set_temp_status(bool value);

  // bool motor_status = 9;
  void clear_motor_status();
  static const int kMotorStatusFieldNumber = 9;
  bool motor_status() const;
  void set_motor_status(bool value);

  // bool sync_status = 10;
  void clear_sync_status();
  static const int kSyncStatusFieldNumber = 10;
  bool sync_status() const;
  void set_sync_status(bool value);

  // bool calib_status = 11;
  void clear_calib_status();
  static const int kCalibStatusFieldNumber = 11;
  bool calib_status() const;
  void set_calib_status(bool value);

  // bool data_status = 12;
  void clear_data_status();
  static const int kDataStatusFieldNumber = 12;
  bool data_status() const;
  void set_data_status(bool value);

  // uint32 total_time = 13;
  void clear_total_time();
  static const int kTotalTimeFieldNumber = 13;
  ::google::protobuf::uint32 total_time() const;
  void set_total_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.LidarStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr sn_;
  ::google::protobuf::internal::ArenaStringPtr top_frm_;
  ::google::protobuf::internal::ArenaStringPtr bot_frm_;
  ::google::protobuf::internal::ArenaStringPtr sw_frm_;
  int return_mode_;
  int sync_mode_;
  bool temp_status_;
  bool motor_status_;
  bool sync_status_;
  bool calib_status_;
  bool data_status_;
  ::google::protobuf::uint32 total_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2flidar_5fdata_2eproto::TableStruct;
  friend void ::protobuf_perception_2flidar_5fdata_2eproto::InitDefaultsLidarStatusImpl();
};
// -------------------------------------------------------------------

class LidarData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xsproto.perception.LidarData) */ {
 public:
  LidarData();
  virtual ~LidarData();

  LidarData(const LidarData& from);

  inline LidarData& operator=(const LidarData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LidarData(LidarData&& from) noexcept
    : LidarData() {
    *this = ::std::move(from);
  }

  inline LidarData& operator=(LidarData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LidarData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarData* internal_default_instance() {
    return reinterpret_cast<const LidarData*>(
               &_LidarData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(LidarData* other);
  friend void swap(LidarData& a, LidarData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LidarData* New() const PROTOBUF_FINAL { return New(NULL); }

  LidarData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LidarData& from);
  void MergeFrom(const LidarData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LidarData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 8;
  void clear_data();
  static const int kDataFieldNumber = 8;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // .xsproto.base.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::xsproto::base::Header& header() const;
  ::xsproto::base::Header* release_header();
  ::xsproto::base::Header* mutable_header();
  void set_allocated_header(::xsproto::base::Header* header);

  // .xsproto.perception.ExtrinsicParameters extrinsic_params = 6;
  bool has_extrinsic_params() const;
  void clear_extrinsic_params();
  static const int kExtrinsicParamsFieldNumber = 6;
  const ::xsproto::perception::ExtrinsicParameters& extrinsic_params() const;
  ::xsproto::perception::ExtrinsicParameters* release_extrinsic_params();
  ::xsproto::perception::ExtrinsicParameters* mutable_extrinsic_params();
  void set_allocated_extrinsic_params(::xsproto::perception::ExtrinsicParameters* extrinsic_params);

  // .xsproto.perception.LidarStatus lidar_status = 7;
  bool has_lidar_status() const;
  void clear_lidar_status();
  static const int kLidarStatusFieldNumber = 7;
  const ::xsproto::perception::LidarStatus& lidar_status() const;
  ::xsproto::perception::LidarStatus* release_lidar_status();
  ::xsproto::perception::LidarStatus* mutable_lidar_status();
  void set_allocated_lidar_status(::xsproto::perception::LidarStatus* lidar_status);

  // uint32 line_num = 2;
  void clear_line_num();
  static const int kLineNumFieldNumber = 2;
  ::google::protobuf::uint32 line_num() const;
  void set_line_num(::google::protobuf::uint32 value);

  // uint32 scan_num = 3;
  void clear_scan_num();
  static const int kScanNumFieldNumber = 3;
  ::google::protobuf::uint32 scan_num() const;
  void set_scan_num(::google::protobuf::uint32 value);

  // double start_time = 4;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 4;
  double start_time() const;
  void set_start_time(double value);

  // double end_time = 5;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 5;
  double end_time() const;
  void set_end_time(double value);

  // @@protoc_insertion_point(class_scope:xsproto.perception.LidarData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::xsproto::base::Header* header_;
  ::xsproto::perception::ExtrinsicParameters* extrinsic_params_;
  ::xsproto::perception::LidarStatus* lidar_status_;
  ::google::protobuf::uint32 line_num_;
  ::google::protobuf::uint32 scan_num_;
  double start_time_;
  double end_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_perception_2flidar_5fdata_2eproto::TableStruct;
  friend void ::protobuf_perception_2flidar_5fdata_2eproto::InitDefaultsLidarDataImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LidarStatus

// string type = 1;
inline void LidarStatus::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LidarStatus::type() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarStatus.type)
  return type_.GetNoArena();
}
inline void LidarStatus::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarStatus.type)
}
#if LANG_CXX11
inline void LidarStatus::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.perception.LidarStatus.type)
}
#endif
inline void LidarStatus::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.perception.LidarStatus.type)
}
inline void LidarStatus::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.perception.LidarStatus.type)
}
inline ::std::string* LidarStatus::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.perception.LidarStatus.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LidarStatus::release_type() {
  // @@protoc_insertion_point(field_release:xsproto.perception.LidarStatus.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LidarStatus::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.LidarStatus.type)
}

// bytes sn = 2;
inline void LidarStatus::clear_sn() {
  sn_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LidarStatus::sn() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarStatus.sn)
  return sn_.GetNoArena();
}
inline void LidarStatus::set_sn(const ::std::string& value) {
  
  sn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarStatus.sn)
}
#if LANG_CXX11
inline void LidarStatus::set_sn(::std::string&& value) {
  
  sn_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.perception.LidarStatus.sn)
}
#endif
inline void LidarStatus::set_sn(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.perception.LidarStatus.sn)
}
inline void LidarStatus::set_sn(const void* value, size_t size) {
  
  sn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.perception.LidarStatus.sn)
}
inline ::std::string* LidarStatus::mutable_sn() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.perception.LidarStatus.sn)
  return sn_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LidarStatus::release_sn() {
  // @@protoc_insertion_point(field_release:xsproto.perception.LidarStatus.sn)
  
  return sn_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LidarStatus::set_allocated_sn(::std::string* sn) {
  if (sn != NULL) {
    
  } else {
    
  }
  sn_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sn);
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.LidarStatus.sn)
}

// bytes top_frm = 3;
inline void LidarStatus::clear_top_frm() {
  top_frm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LidarStatus::top_frm() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarStatus.top_frm)
  return top_frm_.GetNoArena();
}
inline void LidarStatus::set_top_frm(const ::std::string& value) {
  
  top_frm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarStatus.top_frm)
}
#if LANG_CXX11
inline void LidarStatus::set_top_frm(::std::string&& value) {
  
  top_frm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.perception.LidarStatus.top_frm)
}
#endif
inline void LidarStatus::set_top_frm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  top_frm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.perception.LidarStatus.top_frm)
}
inline void LidarStatus::set_top_frm(const void* value, size_t size) {
  
  top_frm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.perception.LidarStatus.top_frm)
}
inline ::std::string* LidarStatus::mutable_top_frm() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.perception.LidarStatus.top_frm)
  return top_frm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LidarStatus::release_top_frm() {
  // @@protoc_insertion_point(field_release:xsproto.perception.LidarStatus.top_frm)
  
  return top_frm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LidarStatus::set_allocated_top_frm(::std::string* top_frm) {
  if (top_frm != NULL) {
    
  } else {
    
  }
  top_frm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), top_frm);
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.LidarStatus.top_frm)
}

// bytes bot_frm = 4;
inline void LidarStatus::clear_bot_frm() {
  bot_frm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LidarStatus::bot_frm() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarStatus.bot_frm)
  return bot_frm_.GetNoArena();
}
inline void LidarStatus::set_bot_frm(const ::std::string& value) {
  
  bot_frm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarStatus.bot_frm)
}
#if LANG_CXX11
inline void LidarStatus::set_bot_frm(::std::string&& value) {
  
  bot_frm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.perception.LidarStatus.bot_frm)
}
#endif
inline void LidarStatus::set_bot_frm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bot_frm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.perception.LidarStatus.bot_frm)
}
inline void LidarStatus::set_bot_frm(const void* value, size_t size) {
  
  bot_frm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.perception.LidarStatus.bot_frm)
}
inline ::std::string* LidarStatus::mutable_bot_frm() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.perception.LidarStatus.bot_frm)
  return bot_frm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LidarStatus::release_bot_frm() {
  // @@protoc_insertion_point(field_release:xsproto.perception.LidarStatus.bot_frm)
  
  return bot_frm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LidarStatus::set_allocated_bot_frm(::std::string* bot_frm) {
  if (bot_frm != NULL) {
    
  } else {
    
  }
  bot_frm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bot_frm);
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.LidarStatus.bot_frm)
}

// bytes sw_frm = 5;
inline void LidarStatus::clear_sw_frm() {
  sw_frm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LidarStatus::sw_frm() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarStatus.sw_frm)
  return sw_frm_.GetNoArena();
}
inline void LidarStatus::set_sw_frm(const ::std::string& value) {
  
  sw_frm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarStatus.sw_frm)
}
#if LANG_CXX11
inline void LidarStatus::set_sw_frm(::std::string&& value) {
  
  sw_frm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.perception.LidarStatus.sw_frm)
}
#endif
inline void LidarStatus::set_sw_frm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sw_frm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.perception.LidarStatus.sw_frm)
}
inline void LidarStatus::set_sw_frm(const void* value, size_t size) {
  
  sw_frm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.perception.LidarStatus.sw_frm)
}
inline ::std::string* LidarStatus::mutable_sw_frm() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.perception.LidarStatus.sw_frm)
  return sw_frm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LidarStatus::release_sw_frm() {
  // @@protoc_insertion_point(field_release:xsproto.perception.LidarStatus.sw_frm)
  
  return sw_frm_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LidarStatus::set_allocated_sw_frm(::std::string* sw_frm) {
  if (sw_frm != NULL) {
    
  } else {
    
  }
  sw_frm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sw_frm);
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.LidarStatus.sw_frm)
}

// .xsproto.perception.ReturnMode return_mode = 6;
inline void LidarStatus::clear_return_mode() {
  return_mode_ = 0;
}
inline ::xsproto::perception::ReturnMode LidarStatus::return_mode() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarStatus.return_mode)
  return static_cast< ::xsproto::perception::ReturnMode >(return_mode_);
}
inline void LidarStatus::set_return_mode(::xsproto::perception::ReturnMode value) {
  
  return_mode_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarStatus.return_mode)
}

// .xsproto.perception.SyncMode sync_mode = 7;
inline void LidarStatus::clear_sync_mode() {
  sync_mode_ = 0;
}
inline ::xsproto::perception::SyncMode LidarStatus::sync_mode() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarStatus.sync_mode)
  return static_cast< ::xsproto::perception::SyncMode >(sync_mode_);
}
inline void LidarStatus::set_sync_mode(::xsproto::perception::SyncMode value) {
  
  sync_mode_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarStatus.sync_mode)
}

// bool temp_status = 8;
inline void LidarStatus::clear_temp_status() {
  temp_status_ = false;
}
inline bool LidarStatus::temp_status() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarStatus.temp_status)
  return temp_status_;
}
inline void LidarStatus::set_temp_status(bool value) {
  
  temp_status_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarStatus.temp_status)
}

// bool motor_status = 9;
inline void LidarStatus::clear_motor_status() {
  motor_status_ = false;
}
inline bool LidarStatus::motor_status() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarStatus.motor_status)
  return motor_status_;
}
inline void LidarStatus::set_motor_status(bool value) {
  
  motor_status_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarStatus.motor_status)
}

// bool sync_status = 10;
inline void LidarStatus::clear_sync_status() {
  sync_status_ = false;
}
inline bool LidarStatus::sync_status() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarStatus.sync_status)
  return sync_status_;
}
inline void LidarStatus::set_sync_status(bool value) {
  
  sync_status_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarStatus.sync_status)
}

// bool calib_status = 11;
inline void LidarStatus::clear_calib_status() {
  calib_status_ = false;
}
inline bool LidarStatus::calib_status() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarStatus.calib_status)
  return calib_status_;
}
inline void LidarStatus::set_calib_status(bool value) {
  
  calib_status_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarStatus.calib_status)
}

// bool data_status = 12;
inline void LidarStatus::clear_data_status() {
  data_status_ = false;
}
inline bool LidarStatus::data_status() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarStatus.data_status)
  return data_status_;
}
inline void LidarStatus::set_data_status(bool value) {
  
  data_status_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarStatus.data_status)
}

// uint32 total_time = 13;
inline void LidarStatus::clear_total_time() {
  total_time_ = 0u;
}
inline ::google::protobuf::uint32 LidarStatus::total_time() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarStatus.total_time)
  return total_time_;
}
inline void LidarStatus::set_total_time(::google::protobuf::uint32 value) {
  
  total_time_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarStatus.total_time)
}

// -------------------------------------------------------------------

// LidarData

// .xsproto.base.Header header = 1;
inline bool LidarData::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::xsproto::base::Header& LidarData::header() const {
  const ::xsproto::base::Header* p = header_;
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarData.header)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::base::Header*>(
      &::xsproto::base::_Header_default_instance_);
}
inline ::xsproto::base::Header* LidarData::release_header() {
  // @@protoc_insertion_point(field_release:xsproto.perception.LidarData.header)
  
  ::xsproto::base::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::xsproto::base::Header* LidarData::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::xsproto::base::Header;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.LidarData.header)
  return header_;
}
inline void LidarData::set_allocated_header(::xsproto::base::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.LidarData.header)
}

// uint32 line_num = 2;
inline void LidarData::clear_line_num() {
  line_num_ = 0u;
}
inline ::google::protobuf::uint32 LidarData::line_num() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarData.line_num)
  return line_num_;
}
inline void LidarData::set_line_num(::google::protobuf::uint32 value) {
  
  line_num_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarData.line_num)
}

// uint32 scan_num = 3;
inline void LidarData::clear_scan_num() {
  scan_num_ = 0u;
}
inline ::google::protobuf::uint32 LidarData::scan_num() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarData.scan_num)
  return scan_num_;
}
inline void LidarData::set_scan_num(::google::protobuf::uint32 value) {
  
  scan_num_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarData.scan_num)
}

// double start_time = 4;
inline void LidarData::clear_start_time() {
  start_time_ = 0;
}
inline double LidarData::start_time() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarData.start_time)
  return start_time_;
}
inline void LidarData::set_start_time(double value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarData.start_time)
}

// double end_time = 5;
inline void LidarData::clear_end_time() {
  end_time_ = 0;
}
inline double LidarData::end_time() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarData.end_time)
  return end_time_;
}
inline void LidarData::set_end_time(double value) {
  
  end_time_ = value;
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarData.end_time)
}

// .xsproto.perception.ExtrinsicParameters extrinsic_params = 6;
inline bool LidarData::has_extrinsic_params() const {
  return this != internal_default_instance() && extrinsic_params_ != NULL;
}
inline const ::xsproto::perception::ExtrinsicParameters& LidarData::extrinsic_params() const {
  const ::xsproto::perception::ExtrinsicParameters* p = extrinsic_params_;
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarData.extrinsic_params)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::ExtrinsicParameters*>(
      &::xsproto::perception::_ExtrinsicParameters_default_instance_);
}
inline ::xsproto::perception::ExtrinsicParameters* LidarData::release_extrinsic_params() {
  // @@protoc_insertion_point(field_release:xsproto.perception.LidarData.extrinsic_params)
  
  ::xsproto::perception::ExtrinsicParameters* temp = extrinsic_params_;
  extrinsic_params_ = NULL;
  return temp;
}
inline ::xsproto::perception::ExtrinsicParameters* LidarData::mutable_extrinsic_params() {
  
  if (extrinsic_params_ == NULL) {
    extrinsic_params_ = new ::xsproto::perception::ExtrinsicParameters;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.LidarData.extrinsic_params)
  return extrinsic_params_;
}
inline void LidarData::set_allocated_extrinsic_params(::xsproto::perception::ExtrinsicParameters* extrinsic_params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(extrinsic_params_);
  }
  if (extrinsic_params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      extrinsic_params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, extrinsic_params, submessage_arena);
    }
    
  } else {
    
  }
  extrinsic_params_ = extrinsic_params;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.LidarData.extrinsic_params)
}

// .xsproto.perception.LidarStatus lidar_status = 7;
inline bool LidarData::has_lidar_status() const {
  return this != internal_default_instance() && lidar_status_ != NULL;
}
inline void LidarData::clear_lidar_status() {
  if (GetArenaNoVirtual() == NULL && lidar_status_ != NULL) {
    delete lidar_status_;
  }
  lidar_status_ = NULL;
}
inline const ::xsproto::perception::LidarStatus& LidarData::lidar_status() const {
  const ::xsproto::perception::LidarStatus* p = lidar_status_;
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarData.lidar_status)
  return p != NULL ? *p : *reinterpret_cast<const ::xsproto::perception::LidarStatus*>(
      &::xsproto::perception::_LidarStatus_default_instance_);
}
inline ::xsproto::perception::LidarStatus* LidarData::release_lidar_status() {
  // @@protoc_insertion_point(field_release:xsproto.perception.LidarData.lidar_status)
  
  ::xsproto::perception::LidarStatus* temp = lidar_status_;
  lidar_status_ = NULL;
  return temp;
}
inline ::xsproto::perception::LidarStatus* LidarData::mutable_lidar_status() {
  
  if (lidar_status_ == NULL) {
    lidar_status_ = new ::xsproto::perception::LidarStatus;
  }
  // @@protoc_insertion_point(field_mutable:xsproto.perception.LidarData.lidar_status)
  return lidar_status_;
}
inline void LidarData::set_allocated_lidar_status(::xsproto::perception::LidarStatus* lidar_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lidar_status_;
  }
  if (lidar_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lidar_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lidar_status, submessage_arena);
    }
    
  } else {
    
  }
  lidar_status_ = lidar_status;
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.LidarData.lidar_status)
}

// bytes data = 8;
inline void LidarData::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LidarData::data() const {
  // @@protoc_insertion_point(field_get:xsproto.perception.LidarData.data)
  return data_.GetNoArena();
}
inline void LidarData::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xsproto.perception.LidarData.data)
}
#if LANG_CXX11
inline void LidarData::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xsproto.perception.LidarData.data)
}
#endif
inline void LidarData::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xsproto.perception.LidarData.data)
}
inline void LidarData::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xsproto.perception.LidarData.data)
}
inline ::std::string* LidarData::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:xsproto.perception.LidarData.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LidarData::release_data() {
  // @@protoc_insertion_point(field_release:xsproto.perception.LidarData.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LidarData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:xsproto.perception.LidarData.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception
}  // namespace xsproto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::xsproto::perception::ReturnMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::perception::ReturnMode>() {
  return ::xsproto::perception::ReturnMode_descriptor();
}
template <> struct is_proto_enum< ::xsproto::perception::SyncMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xsproto::perception::SyncMode>() {
  return ::xsproto::perception::SyncMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perception_2flidar_5fdata_2eproto__INCLUDED
